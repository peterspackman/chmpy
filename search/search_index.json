{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"chmpy","text":"<p>A library for computational chemistry in python. Featuring support for molecules, crystals, Hirshfeld &amp; promolecule density isosurfaces, spherical harmonic shape descriptors and much more...</p>"},{"location":"#features","title":"Features","text":"<p>While the library is intended to be flexible and make it easy to build complex pipelines or properties, the following is a brief summary of  intended features:</p> <ul> <li>Load crystal structures from <code>.cif</code>, <code>.res</code>, <code>POSCAR</code> files,  and molecules from <code>.xyz</code>, <code>.sdf</code> files.</li> <li>Evaluate promolecule and procrystal electron densities.</li> <li>Easily generate Hirshfeld or promolecule isosurfaces and associated properties.</li> <li>Easily generate spherical harmonic shape descriptors for atoms, molecules, or molecular fragments.</li> <li>Efficiently calculate crystal slabs, periodic connectivity and more...</li> </ul> <p>It should also serve as a simple, easy to read library for learning how to represent crystal structures, molecules etc. and evaluate scientifically relevant information quickly and efficiently using python.</p>"},{"location":"#crystal-structures-and-molecules","title":"Crystal structures and molecules","text":"<p>Loading a crystal structure from a CIF (<code>.cif</code>) or SHELX (<code>.res</code>) file, or a molecule from an XMOL (<code>.xyz</code>) file is straightforward:</p> chmpy_basics.py<pre><code>from chmpy import Crystal, Molecule\nc = Crystal.load(\"tests/test_files/acetic_acid.cif\")\nc\n# &lt;Crystal C2H4O2 Pna2_1&gt;\n\n# Calculate the unique molecules in this crystal\nc.symmetry_unique_molecules()\n# [&lt;Molecule: C2H4O2(2.12,1.15,0.97)&gt;]\n\nm = Molecule.load(\"tests/test_files/water.xyz\")\nm\n# &lt;Molecule: H2O(-0.67,-0.00,0.01)&gt;\n</code></pre>"},{"location":"#hirshfeld-and-promolecule-density-isosurfaces","title":"Hirshfeld and promolecule density isosurfaces","text":"<p>Generation of surfaces with the default settings can be done with minimal hassle, simply by using the corresponding members of the <code>Crystal</code> class:</p> <pre><code>c = Crystal.load(\"tests/test_files/acetic_acid.cif\")\n\n# This will generate a high resolution surface\n# for each symmetry unique molecule in the crystal\nsurfaces = c.hirshfeld_surfaces()\nsurfaces\n# [&lt;trimesh.Trimesh(vertices.shape=(3598, 3), faces.shape=(7192, 3))&gt;]\n\n# We can generate lower resolution surfaces with the separation parameter\nsurfaces = c.hirshfeld_surfaces(separation=0.5)\nsurfaces\n# [&lt;trimesh.Trimesh(vertices.shape=(584, 3), faces.shape=(1164, 3))&gt;]\n\n# Surfaces can be saved via trimesh\nsurfaces[0].export(\"acetic_acid_trimesh.ply\", \"ply\")\n# or a utility function provided in chmpy\nfrom chmpy.util.mesh import save_mesh\nsave_mesh(surfaces[0], \"acetic_acid.ply\")\n</code></pre>"},{"location":"parallel/","title":"Parallelization","text":"<p>Some of the <code>Cython</code> code in <code>chmpy</code> makes use of OpenMP parallelism. If this is interfering with your own parallelism at a higher level, or you simply wish to modify how many cores the code should make use of, consider setting the environment variable <code>OMP_NUM_THREADS</code> to the desired number of threads.</p> <pre><code>export OMP_NUM_THREADS=1\n</code></pre>"},{"location":"shape_descriptors/","title":"Shape descriptors","text":""},{"location":"shape_descriptors/#what-they-are","title":"What they are","text":"<p>A rotation invariant description of a shape. In essence, these are rotation invariants calculated from the coefficients of the spherical harmonic transform of a shape function, which in our case is either the radius (distance from the origin) of an isosurface as a function of the spherical angles theta and phi.</p>"},{"location":"shape_descriptors/#references","title":"References:","text":"<ol> <li>PR Spackman et al. Sci. Rep. 6, 22204 (2016)</li> <li>PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)</li> </ol>"},{"location":"shape_descriptors/#how-to-calculate-shape-descriptors","title":"How to calculate shape descriptors","text":""},{"location":"shape_descriptors/#molecules-in-crystals","title":"Molecules in crystals","text":"<pre><code>from chmpy import Crystal\nc = Crystal.load(\"tests/test_files/acetic_acid.cif\")\n\n# calculate shape descriptors for each molecule in the asymmetric unit\ndesc = c.molecular_shape_descriptors()\n</code></pre>"},{"location":"shape_descriptors/#atoms-in-crystals","title":"Atoms in crystals","text":"<p>Likewise, atomic shape descriptors can be conveniently calculated directly from the <code>Crystal</code> object:</p> <pre><code>from chmpy import Crystal\nc = Crystal.load(\"tests/test_files/acetic_acid.cif\")\n\n# calculate shape descriptors for each atom in the asymmetric unit\ndesc = c.atomic_shape_descriptors()\n</code></pre>"},{"location":"shape_descriptors/#isolated-molecules","title":"Isolated molecules","text":"<p>Hirshfeld surfaces typically only have a sensible definition in a crystal (or at least in a environment where the molecule is not isolated). As such, the more sensible descriptor to utilise may be one of the Promolecule density isosurface.</p> <p>This can be readily calculated using the <code>Molecule</code> object:</p> <pre><code>from chmpy import Molecule\nm = Molecule.load(\"tests/test_files/water.xyz\")\ndesc = m.shape_descriptors()\n\n# use EEM calculated charges to describe the shape and the ESP\n# up to maximum angular momentum 16\ndesc_with_esp = m.shape_descriptors(l_max=16, with_property=\"esp\")\n</code></pre> <p>However, another useful descriptor of atomic environments is a Hirshfeld-type descriptor in a molecule, where in order to 'close' the exterior of the surface we introduce a <code>background</code> density, as follows:</p> <pre><code>from chmpy import Molecule\nm = Molecule.load(\"tests/test_files/water.xyz\")\n# with the default background density\ndesc = m.atomic_shape_descriptors()\n\n# or with, a larger background density, contracting the atoms\ndesc = m.atomic_shape_descriptors(background=0.0001)\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>chmpy<ul> <li>cmd<ul> <li>convert</li> </ul> </li> <li>core<ul> <li>dimer</li> <li>eeq</li> <li>element</li> <li>molecule</li> <li>wolf</li> </ul> </li> <li>crystal<ul> <li>asymmetric_unit</li> <li>crystal</li> <li>eeq_pbc</li> <li>fingerprint</li> <li>point_group</li> <li>powder</li> <li>space_group</li> <li>symmetry_operation</li> <li>unit_cell</li> <li>wulff</li> </ul> </li> <li>descriptors<ul> <li>symmetry_function_ani1</li> </ul> </li> <li>exe<ul> <li>exe</li> <li>gaussian</li> <li>gulp</li> <li>raspa</li> <li>tonto</li> <li>xtb</li> </ul> </li> <li>ext<ul> <li>ase</li> <li>charges</li> <li>cosmo</li> <li>crystal</li> <li>cx</li> <li>elastic_tensor</li> <li>excitations</li> <li>solvation_parameters</li> <li>traj</li> <li>vasp</li> </ul> </li> <li>ff<ul> <li>params</li> </ul> </li> <li>fmt<ul> <li>ascii</li> <li>ase</li> <li>cif</li> <li>crystal17</li> <li>cube</li> <li>fchk</li> <li>gaussian_log</li> <li>gen</li> <li>gmf</li> <li>grd</li> <li>gulp</li> <li>mol2</li> <li>nwchem</li> <li>pdb</li> <li>raspa</li> <li>sdf</li> <li>shelx</li> <li>smiles</li> <li>tmol</li> <li>vasp</li> <li>xtb</li> <li>xyz_file</li> </ul> </li> <li>interpolate<ul> <li>density</li> <li>lerp</li> </ul> </li> <li>ints<ul> <li>lebedev</li> <li>solvation</li> </ul> </li> <li>mc<ul> <li>_mc</li> <li>lookup_tables</li> </ul> </li> <li>opt<ul> <li>gulp</li> <li>xtb</li> </ul> </li> <li>shape<ul> <li>assoc_legendre</li> <li>convex_hull</li> <li>reconstruct</li> <li>shape_descriptors</li> <li>sht</li> <li>spherical_harmonics</li> </ul> </li> <li>surface</li> <li>util<ul> <li>color</li> <li>dict</li> <li>exe</li> <li>mesh</li> <li>num</li> <li>path</li> <li>text</li> <li>unit</li> <li>util</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/chmpy/surface/","title":"surface","text":"<p>Isosurfaces for molecules in crystals or isolation.</p>"},{"location":"reference/chmpy/surface/#chmpy.surface.promolecule_density_isosurface","title":"<code>promolecule_density_isosurface(promol, isovalue=0.002, sep=0.2, props=True, extra_props=None, smoothing='laplacian')</code>","text":"<p>Calculate the promolecule density isosurface.</p> <p>Parameters:</p> Name Type Description Default <code>isovalue</code> <code>float</code> <p>level set value for the isosurface (default=0.002) in au.</p> <code>0.002</code> <code>separation</code> <code>float</code> <p>separation between density grid     used in the surface calculation (default 0.2) in Angstroms.</p> required <code>props</code> <code>bool</code> <p>calculate surface properties</p> <code>True</code> <code>extra_props</code> <code>dict</code> <p>dictionary of property names and functions of vertex positions for the calculation of additional properties on the isosurface</p> <code>None</code> <p>Returns:     IsosurfaceMesh: a namedtuple of vertices, faces,         face normals and vertex properties</p> Source code in <code>chmpy/surface.py</code> <pre><code>def promolecule_density_isosurface(\n    promol, isovalue=0.002, sep=0.2, props=True, extra_props=None, smoothing=\"laplacian\"\n):\n    \"\"\"Calculate the promolecule density isosurface.\n\n    Args:\n        isovalue (float, optional): level set value for the isosurface\n            (default=0.002) in au.\n        separation (float, optional):  separation between density grid\n                used in the surface calculation (default 0.2) in Angstroms.\n        props (bool, optional): calculate surface properties\n        extra_props(dict, optional): dictionary of property names and functions\n            of vertex positions for the calculation of additional properties\n            on the isosurface\n    Returns:\n        IsosurfaceMesh: a namedtuple of vertices, faces,\n            face normals and vertex properties\n    \"\"\"\n    t1 = time.time()\n    l, u = promol.bb()\n    x_grid = np.arange(l[0], u[0], sep, dtype=np.float32)\n    y_grid = np.arange(l[1], u[1], sep, dtype=np.float32)\n    z_grid = np.arange(l[2], u[2], sep, dtype=np.float32)\n    x, y, z = np.meshgrid(x_grid, y_grid, z_grid)\n    separations = np.array((sep, sep, sep))\n    shape = x.shape\n    pts = np.c_[x.ravel(), y.ravel(), z.ravel()]\n    d = promol.rho(pts).reshape(shape)\n    verts, faces, normals, _ = marching_cubes(\n        d, isovalue, spacing=(sep, sep, sep), gradient_direction=\"descent\"\n    )\n    LOG.debug(\"Separation (x,y,z): %s\", separations)\n    verts = np.c_[verts[:, 1], verts[:, 0], verts[:, 2]] + l\n    LOG.debug(\"Surface centroid: %s\", np.mean(verts, axis=0))\n    LOG.debug(\"Mol centroid: %s\", np.mean(promol.positions, axis=0))\n    LOG.debug(\"Max (x,y,z): %s\", np.max(verts, axis=0))\n    LOG.debug(\"Min (x,y,z): %s\", np.min(verts, axis=0))\n    vertex_props = {}\n\n    if smoothing == \"laplacian\":\n        verts, faces = smooth_laplacian(verts, faces)\n\n    if props:\n        if extra_props is not None:\n            for k, func in extra_props.items():\n                LOG.debug(\"Calculating additional surface property: %s\", k)\n                vertex_props[k] = func(verts)\n        d_i, d_norm_i, vecs = promol.d_norm(verts)\n        vertex_props[\"d_i\"] = d_i\n        vertex_props[\"d_norm_i\"] = d_norm_i\n        LOG.debug(\"d_i (min, max): (%.2f, %.2f)\", np.min(d_i), np.max(d_i))\n    t2 = time.time()\n    LOG.info(\"promolecule surface took %.3fs, %d pts\", t2 - t1, len(pts))\n    return IsosurfaceMesh(verts, faces, normals, vertex_props)\n</code></pre>"},{"location":"reference/chmpy/surface/#chmpy.surface.smooth_laplacian","title":"<code>smooth_laplacian(vertices, faces, **kwargs)</code>","text":"<p>Smooth vertices and faces using a Laplacian filter</p> Source code in <code>chmpy/surface.py</code> <pre><code>def smooth_laplacian(vertices, faces, **kwargs):\n    \"\"\"Smooth vertices and faces using a Laplacian filter\"\"\"\n    from trimesh import Trimesh\n    from trimesh.smoothing import filter_humphrey\n\n    kwargs.setdefault(\"iterations\", 2)\n    mesh = Trimesh(vertices, faces)\n    filter_humphrey(mesh, **kwargs)\n    return mesh.vertices, mesh.faces\n</code></pre>"},{"location":"reference/chmpy/surface/#chmpy.surface.stockholder_weight_isosurface","title":"<code>stockholder_weight_isosurface(s, isovalue=0.5, sep=0.2, props=True, extra_props=None, smoothing='laplacian')</code>","text":"<p>Calculate stockholder weight (Hirshfeld) surface.</p> <p>Parameters:</p> Name Type Description Default <code>isovalue</code> <code>float</code> <p>level set value for the isosurface (default=0.5), dimensionless.</p> <code>0.5</code> <code>separation</code> <code>float</code> <p>separation between density grid     used in the surface calculation (default 0.2) in Angstroms.</p> required <code>props</code> <code>bool</code> <p>calculate surface properties</p> <code>True</code> <code>extra_props</code> <code>dict</code> <p>dictionary of property names and functions of vertex positions for the calculation of additional properties on the isosurface</p> <code>None</code> <p>Returns:     IsosurfaceMesh: a namedtuple of vertices, faces,         face normals and vertex properties</p> Source code in <code>chmpy/surface.py</code> <pre><code>def stockholder_weight_isosurface(\n    s, isovalue=0.5, sep=0.2, props=True, extra_props=None, smoothing=\"laplacian\"\n):\n    \"\"\"Calculate stockholder weight (Hirshfeld) surface.\n\n    Args:\n        isovalue (float, optional): level set value for the isosurface\n            (default=0.5), dimensionless.\n        separation (float, optional):  separation between density grid\n                used in the surface calculation (default 0.2) in Angstroms.\n        props (bool, optional): calculate surface properties\n        extra_props(dict, optional): dictionary of property names and functions\n            of vertex positions for the calculation of additional properties\n            on the isosurface\n    Returns:\n        IsosurfaceMesh: a namedtuple of vertices, faces,\n            face normals and vertex properties\n    \"\"\"\n    t1 = time.time()\n    l, u = s.bb()\n    x_grid = np.arange(l[0], u[0], sep, dtype=np.float32)\n    y_grid = np.arange(l[1], u[1], sep, dtype=np.float32)\n    z_grid = np.arange(l[2], u[2], sep, dtype=np.float32)\n    x, y, z = np.meshgrid(x_grid, y_grid, z_grid)\n    separations = np.array((sep, sep, sep))\n    shape = x.shape\n    pts = np.c_[x.ravel(), y.ravel(), z.ravel()]\n    pts = np.array(pts, dtype=np.float32)\n    weights = s.weights(pts).reshape(shape)\n    verts, faces, normals, _ = marching_cubes(\n        weights, isovalue, spacing=separations, gradient_direction=\"descent\"\n    )\n\n    if smoothing == \"laplacian\":\n        verts, faces = smooth_laplacian(verts, faces)\n\n    LOG.debug(\"Separation (x,y,z): %s\", separations)\n    verts = np.c_[verts[:, 1], verts[:, 0], verts[:, 2]] + l\n    LOG.debug(\"Surface centroid: %s\", np.mean(verts, axis=0))\n    LOG.debug(\"Mol centroid: %s\", np.mean(s.dens_a.positions, axis=0))\n    LOG.debug(\"Max (x,y,z): %s\", np.max(verts, axis=0))\n    LOG.debug(\"Min (x,y,z): %s\", np.min(verts, axis=0))\n    vertex_props = {}\n    if props:\n        if extra_props is not None:\n            for k, func in extra_props.items():\n                LOG.debug(\"Calculating additional surface property: %s\", k)\n                vertex_props[k] = func(verts)\n        d_i, d_e, d_norm_i, d_norm_e, dp, angles = s.d_norm(verts)\n        vertex_props[\"d_i\"] = d_i\n        vertex_props[\"d_e\"] = d_e\n        vertex_props[\"d_norm_i\"] = d_norm_i\n        vertex_props[\"d_norm_e\"] = d_norm_e\n        d_norm = d_norm_i + d_norm_e\n        vertex_props[\"d_norm\"] = d_norm\n        vertex_props[\"dp\"] = dp\n        vertex_props[\"angle\"] = np.abs(angles)\n        LOG.debug(\"d_norm (min, max): (%.2f, %.2f)\", np.min(d_norm), np.max(d_norm))\n    t2 = time.time()\n    LOG.info(\"stockholder weight surface took %.3fs, %d pts\", t2 - t1, len(pts))\n    return IsosurfaceMesh(verts, faces, normals, vertex_props)\n</code></pre>"},{"location":"reference/chmpy/cmd/convert/","title":"convert","text":""},{"location":"reference/chmpy/core/dimer/","title":"dimer","text":"<p>Module for pairs of molecules, handling symmetry relations and more.</p>"},{"location":"reference/chmpy/core/dimer/#chmpy.core.dimer.Dimer","title":"<code>Dimer</code>","text":"<p>Storage class for symmetry information about a dimers.</p> <p>Dimers are two molecules that may or may not be symmetry related.</p> <p>Parameters:</p> Name Type Description Default <code>mol_a</code> <code>Molecule</code> <p>one of the molecules in the pair (symmetry unique)</p> required <code>mol_b</code> <code>Molecule</code> <p>the neighbouring molecule (may be symmetry related to mol_a)</p> required <code>separation</code> <code>float</code> <p>set the separation of the molecules (otherwise it will be calculated)</p> <code>None</code> <code>transform_ab</code> <code>ndarray</code> <p>specify the transform from mol_a to mol_b (otherwise it will be calculated)</p> <code>None</code> <code>frac_shift</code> <code>ndarray</code> <p>specify the offset in fractions of a unit cell, which combined with transform_ab will yield mol_b</p> <code>None</code> Source code in <code>chmpy/core/dimer.py</code> <pre><code>class Dimer:\n    \"\"\"Storage class for symmetry information about a dimers.\n\n    Dimers are two molecules that may or may not be symmetry related.\n\n    Args:\n            mol_a (Molecule):\n                one of the molecules in the pair (symmetry unique)\n            mol_b (Molecule): the neighbouring molecule (may be symmetry\n                related to mol_a)\n            separation (float, optional): set the separation of the molecules\n                (otherwise it will be calculated)\n            transform_ab (np.ndarray, optional): specify the transform from mol_a\n                to mol_b (otherwise it will be calculated)\n            frac_shift (np.ndarray, optional): specify the offset in fractions\n                of a unit cell, which combined with transform_ab will yield mol_b\n    \"\"\"\n\n    seitz_b = None\n    symm_str = None\n    crystal_transform = False\n\n    def __init__(\n        self, mol_a, mol_b, separation=None, transform_ab=None, frac_shift=None\n    ):\n        \"\"\"Initialize a Dimer.\"\"\"\n        self.a = mol_a\n        self.b = mol_b\n        self.a_idx = self.a.properties.get(\"asym_mol_idx\", 0)\n        self.b_idx = self.b.properties.get(\"asym_mol_idx\", 0)\n        self.frac_shift = frac_shift\n        if \"generator_symop\" in self.a.properties:\n            self.symop_a = self.a.properties[\"generator_symop\"]\n\n        if \"generator_symop\" in self.b.properties:\n            self.symop_b = self.b.properties[\"generator_symop\"]\n\n        if separation is not None:\n            self.separation = separation\n        else:\n            self.separation = mol_a.distance_to(mol_b)\n        if transform_ab == \"calculate\":\n            self.calculate_transform()\n        else:\n            self.transform_ab = transform_ab\n        self.closest_separation = self.a.distance_to(self.b, method=\"nearest_atom\")\n        self.centroid_separation = self.a.distance_to(self.b, method=\"centroid\")\n        self.com_separation = self.a.distance_to(self.b, method=\"center_of_mass\")\n\n    def calculate_transform(self):\n        \"\"\"Calculate the transform (if any) from mol_a to mol_b.\"\"\"\n        from chmpy.util.num import kabsch_rotation_matrix\n\n        if len(self.a) != len(self.b):\n            self.transform_ab = None\n            return\n\n        if not np.all(self.a.atomic_numbers == self.b.atomic_numbers):\n            self.transform_ab = None\n            return\n\n        v_a = self.a.centroid\n        v_b = self.b.centroid\n        v_ab = v_b - v_a\n        pos_a = self.a.positions - v_a\n        pos_b = self.b.positions - v_b\n        R = kabsch_rotation_matrix(pos_b, pos_a)\n        self.transform_ab = (R, v_ab)\n\n        if (\n            self.frac_shift is not None\n            and self.symop_a is not None\n            and self.symop_b is not None\n        ):\n            self.crystal_transform = True\n            from chmpy.crystal.symmetry_operation import (\n                SymmetryOperation,\n                encode_symm_str,\n            )\n\n            s_b = SymmetryOperation.from_integer_code(self.symop_b[0])\n            t_ab = np.zeros((4, 4))\n            t_ab[:3, 3] = self.frac_shift\n            self.seitz_b = s_b.seitz_matrix.copy()\n            self.seitz_b[:3, 3] += self.frac_shift\n            self.symm_str = encode_symm_str(self.seitz_b[:3, :3], self.seitz_b[:3, 3])\n        return self.transform_ab\n\n    def supermolecule(self):\n        return Molecule.from_arrays(\n            np.hstack((self.a.atomic_numbers, self.b.atomic_numbers)),\n            np.vstack((self.a.positions, self.b.positions)),\n        )\n\n    def scale_separation(self, scale_factor):\n        v_a = self.a.centroid\n        v_b = self.b.centroid\n        v_ab = v_b - v_a\n        self.b.positions -= v_ab\n        v_ab *= scale_factor\n        self.b.positions += v_ab\n\n    @property\n    def separations(self):\n        \"The closest atom, centroid-centroid, and center of mass -\"\n        \"center of mass separations of mol_a and mol_b.\"\n        return np.array(\n            (self.closest_separation, self.centroid_separation, self.com_separation)\n        )\n\n    def __eq__(self, other):\n        \"\"\"Return true if all separations are identical.\"\"\"\n        return np.allclose(self.separations, other.separations)\n\n    def transform_string(self):\n        \"\"\"The transform from mol_a to mol_b as a string (e.g. x,-y,z).\"\"\"\n        if self.transform_ab is None:\n            return \"none\"\n        if self.crystal_transform:\n            return self.symm_str\n        return str(self.transform_ab)\n\n    def __repr__(self):\n        \"\"\"Represent the Dimer for a REPL or similar.\"\"\"\n        return f\"&lt;Dimer: d={self.separation:.2f} symm={self.transform_string()}&gt;\"\n</code></pre>"},{"location":"reference/chmpy/core/dimer/#chmpy.core.dimer.Dimer.separations","title":"<code>separations</code>  <code>property</code>","text":"<p>The closest atom, centroid-centroid, and center of mass -</p>"},{"location":"reference/chmpy/core/dimer/#chmpy.core.dimer.Dimer.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Return true if all separations are identical.</p> Source code in <code>chmpy/core/dimer.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Return true if all separations are identical.\"\"\"\n    return np.allclose(self.separations, other.separations)\n</code></pre>"},{"location":"reference/chmpy/core/dimer/#chmpy.core.dimer.Dimer.__init__","title":"<code>__init__(mol_a, mol_b, separation=None, transform_ab=None, frac_shift=None)</code>","text":"<p>Initialize a Dimer.</p> Source code in <code>chmpy/core/dimer.py</code> <pre><code>def __init__(\n    self, mol_a, mol_b, separation=None, transform_ab=None, frac_shift=None\n):\n    \"\"\"Initialize a Dimer.\"\"\"\n    self.a = mol_a\n    self.b = mol_b\n    self.a_idx = self.a.properties.get(\"asym_mol_idx\", 0)\n    self.b_idx = self.b.properties.get(\"asym_mol_idx\", 0)\n    self.frac_shift = frac_shift\n    if \"generator_symop\" in self.a.properties:\n        self.symop_a = self.a.properties[\"generator_symop\"]\n\n    if \"generator_symop\" in self.b.properties:\n        self.symop_b = self.b.properties[\"generator_symop\"]\n\n    if separation is not None:\n        self.separation = separation\n    else:\n        self.separation = mol_a.distance_to(mol_b)\n    if transform_ab == \"calculate\":\n        self.calculate_transform()\n    else:\n        self.transform_ab = transform_ab\n    self.closest_separation = self.a.distance_to(self.b, method=\"nearest_atom\")\n    self.centroid_separation = self.a.distance_to(self.b, method=\"centroid\")\n    self.com_separation = self.a.distance_to(self.b, method=\"center_of_mass\")\n</code></pre>"},{"location":"reference/chmpy/core/dimer/#chmpy.core.dimer.Dimer.__repr__","title":"<code>__repr__()</code>","text":"<p>Represent the Dimer for a REPL or similar.</p> Source code in <code>chmpy/core/dimer.py</code> <pre><code>def __repr__(self):\n    \"\"\"Represent the Dimer for a REPL or similar.\"\"\"\n    return f\"&lt;Dimer: d={self.separation:.2f} symm={self.transform_string()}&gt;\"\n</code></pre>"},{"location":"reference/chmpy/core/dimer/#chmpy.core.dimer.Dimer.calculate_transform","title":"<code>calculate_transform()</code>","text":"<p>Calculate the transform (if any) from mol_a to mol_b.</p> Source code in <code>chmpy/core/dimer.py</code> <pre><code>def calculate_transform(self):\n    \"\"\"Calculate the transform (if any) from mol_a to mol_b.\"\"\"\n    from chmpy.util.num import kabsch_rotation_matrix\n\n    if len(self.a) != len(self.b):\n        self.transform_ab = None\n        return\n\n    if not np.all(self.a.atomic_numbers == self.b.atomic_numbers):\n        self.transform_ab = None\n        return\n\n    v_a = self.a.centroid\n    v_b = self.b.centroid\n    v_ab = v_b - v_a\n    pos_a = self.a.positions - v_a\n    pos_b = self.b.positions - v_b\n    R = kabsch_rotation_matrix(pos_b, pos_a)\n    self.transform_ab = (R, v_ab)\n\n    if (\n        self.frac_shift is not None\n        and self.symop_a is not None\n        and self.symop_b is not None\n    ):\n        self.crystal_transform = True\n        from chmpy.crystal.symmetry_operation import (\n            SymmetryOperation,\n            encode_symm_str,\n        )\n\n        s_b = SymmetryOperation.from_integer_code(self.symop_b[0])\n        t_ab = np.zeros((4, 4))\n        t_ab[:3, 3] = self.frac_shift\n        self.seitz_b = s_b.seitz_matrix.copy()\n        self.seitz_b[:3, 3] += self.frac_shift\n        self.symm_str = encode_symm_str(self.seitz_b[:3, :3], self.seitz_b[:3, 3])\n    return self.transform_ab\n</code></pre>"},{"location":"reference/chmpy/core/dimer/#chmpy.core.dimer.Dimer.transform_string","title":"<code>transform_string()</code>","text":"<p>The transform from mol_a to mol_b as a string (e.g. x,-y,z).</p> Source code in <code>chmpy/core/dimer.py</code> <pre><code>def transform_string(self):\n    \"\"\"The transform from mol_a to mol_b as a string (e.g. x,-y,z).\"\"\"\n    if self.transform_ab is None:\n        return \"none\"\n    if self.crystal_transform:\n        return self.symm_str\n    return str(self.transform_ab)\n</code></pre>"},{"location":"reference/chmpy/core/eeq/","title":"eeq","text":""},{"location":"reference/chmpy/core/eeq/#chmpy.core.eeq.build_a_matrix","title":"<code>build_a_matrix(atomic_numbers, positions)</code>","text":"<p>Build the A matrix for EEQ charge calculation.</p> <p>Parameters:</p> Name Type Description Default <code>atomic_numbers</code> <code>ndarray</code> <p>Array of atomic numbers for each atom</p> required <code>positions</code> <code>ndarray</code> <p>Array of atomic positions (shape: N x 3)</p> required <p>Returns:</p> Type Description <p>np.ndarray: A matrix for the EEQ calculation</p> Source code in <code>chmpy/core/eeq.py</code> <pre><code>def build_a_matrix(atomic_numbers, positions):\n    \"\"\"\n    Build the A matrix for EEQ charge calculation.\n\n    Args:\n        atomic_numbers (np.ndarray): Array of atomic numbers for each atom\n        positions (np.ndarray): Array of atomic positions (shape: N x 3)\n\n    Returns:\n        np.ndarray: A matrix for the EEQ calculation\n    \"\"\"\n    N = len(atomic_numbers)\n    sqrt_pi_fac = np.sqrt(2.0 / np.pi)\n    A = np.zeros((N + 1, N + 1))\n\n    positions_bohr = positions * ANGSTROM_TO_BOHR\n\n    r = pdist(positions_bohr)\n    r2 = r**2\n\n    widths = WIDTH[atomic_numbers]\n\n    i, j = np.triu_indices(N, k=1)\n\n    ri_squared = widths[i] ** 2\n    rj_squared = widths[j] ** 2\n    gamma = 1.0 / (ri_squared + rj_squared)\n\n    values = erf(np.sqrt(r2 * gamma)) / np.sqrt(r2)\n\n    A_temp = np.zeros((N, N))\n    A_temp[i, j] = values\n    A_temp[j, i] = values  # Mirror values (symmetric matrix)\n\n    A[:N, :N] = A_temp\n\n    diagonal_values = ETA[atomic_numbers] + sqrt_pi_fac / WIDTH[atomic_numbers]\n    np.fill_diagonal(A[:N, :N], diagonal_values)\n\n    A[N, :N] = 1.0\n    A[:N, N] = 1.0\n    A[N, N] = 0.0\n\n    return A\n</code></pre>"},{"location":"reference/chmpy/core/eeq/#chmpy.core.eeq.build_x_vector","title":"<code>build_x_vector(atomic_numbers, cn, charge=0.0)</code>","text":"<p>Build the X vector for EEQ charge calculation.</p> <p>Parameters:</p> Name Type Description Default <code>atomic_numbers</code> <code>ndarray</code> <p>Array of atomic numbers for each atom</p> required <code>cn</code> <code>ndarray</code> <p>Array of coordination numbers for each atom</p> required <code>charge</code> <code>float</code> <p>Total charge of the system</p> <code>0.0</code> <p>Returns:</p> Type Description <p>np.ndarray: X vector for the EEQ calculation</p> Source code in <code>chmpy/core/eeq.py</code> <pre><code>def build_x_vector(atomic_numbers, cn, charge=0.0):\n    \"\"\"\n    Build the X vector for EEQ charge calculation.\n\n    Args:\n        atomic_numbers (np.ndarray): Array of atomic numbers for each atom\n        cn (np.ndarray): Array of coordination numbers for each atom\n        charge (float): Total charge of the system\n\n    Returns:\n        np.ndarray: X vector for the EEQ calculation\n    \"\"\"\n    N = atomic_numbers.shape[0]\n    eps = 1e-14  # Avoid singularity with 0\n    X = np.empty(N + 1)\n    X[:N] = -CHI[atomic_numbers] + cn * KCN_PARAM[atomic_numbers] / np.sqrt(cn + eps)\n    X[N] = charge\n    return X\n</code></pre>"},{"location":"reference/chmpy/core/eeq/#chmpy.core.eeq.calculate_coordination_numbers","title":"<code>calculate_coordination_numbers(atomic_numbers, positions)</code>","text":"<p>Calculate coordination numbers for all atoms in a molecule or crystal.</p> <p>Parameters:</p> Name Type Description Default <code>atomic_numbers</code> <code>ndarray</code> <p>Array of atomic numbers for each atom</p> required <code>positions</code> <code>ndarray</code> <p>Array of atomic positions (shape: N x 3)</p> required <p>Returns:</p> Type Description <p>np.ndarray: Array of coordination numbers for each atom</p> Source code in <code>chmpy/core/eeq.py</code> <pre><code>def calculate_coordination_numbers(atomic_numbers, positions):\n    \"\"\"\n    Calculate coordination numbers for all atoms in a molecule or crystal.\n\n    Args:\n        atomic_numbers (np.ndarray): Array of atomic numbers for each atom\n        positions (np.ndarray): Array of atomic positions (shape: N x 3)\n\n    Returns:\n        np.ndarray: Array of coordination numbers for each atom\n    \"\"\"\n    N = len(atomic_numbers)\n    kcn_value = 7.5  # Constant from the C++ implementation\n\n    cn = np.zeros(N)\n    cutoff = 25.0  # Cutoff distance in Angstroms squared\n\n    dists = pdist(positions) * ANGSTROM_TO_BOHR\n\n    i, j = np.triu_indices(N, k=1)\n\n    mask = dists &lt;= cutoff\n    dists = dists[mask]\n    i_filt, j_filt = i[mask], j[mask]\n\n    rc = (\n        COVALENT_D3[atomic_numbers[i_filt]] + COVALENT_D3[atomic_numbers[j_filt]]\n    ) * ANGSTROM_TO_BOHR\n\n    counts = 0.5 * (1.0 + erf(-kcn_value * (dists / rc - 1.0)))\n\n    np.add.at(cn, i_filt, counts)\n    np.add.at(cn, j_filt, counts)\n\n    return cn\n</code></pre>"},{"location":"reference/chmpy/core/eeq/#chmpy.core.eeq.calculate_eeq_charges","title":"<code>calculate_eeq_charges(atomic_numbers, positions, charge=0.0)</code>","text":"<p>Calculate EEQ partial charges for a set of atoms.</p> <p>Parameters:</p> Name Type Description Default <code>atomic_numbers</code> <code>ndarray</code> <p>Array of atomic numbers for each atom</p> required <code>positions</code> <code>ndarray</code> <p>Array of atomic positions (shape: N x 3)</p> required <code>charge</code> <code>float</code> <p>Total charge of the system</p> <code>0.0</code> <p>Returns:</p> Type Description <p>np.ndarray: Array of partial charges for each atom</p> Source code in <code>chmpy/core/eeq.py</code> <pre><code>def calculate_eeq_charges(atomic_numbers, positions, charge=0.0):\n    \"\"\"\n    Calculate EEQ partial charges for a set of atoms.\n\n    Args:\n        atomic_numbers (np.ndarray): Array of atomic numbers for each atom\n        positions (np.ndarray): Array of atomic positions (shape: N x 3)\n        charge (float): Total charge of the system\n\n    Returns:\n        np.ndarray: Array of partial charges for each atom\n    \"\"\"\n    # Calculate coordination numbers\n    cn = calculate_coordination_numbers(atomic_numbers, positions)\n    A = build_a_matrix(atomic_numbers, positions)\n    X = build_x_vector(atomic_numbers, cn, charge)\n\n    Q = np.linalg.solve(A, X)\n    return Q[:-1]\n</code></pre>"},{"location":"reference/chmpy/core/element/","title":"element","text":"<p>Module for static information about chemical elements.</p>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.Element","title":"<code>Element</code>","text":"<p>Storage class for information about a chemical element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; h = Element.from_string(\"H\")\n&gt;&gt;&gt; c = Element.from_string(\"C\")\n&gt;&gt;&gt; n = Element.from_atomic_number(7)\n&gt;&gt;&gt; f = Element.from_string(\"F\")\n</code></pre> <p>Element implements an ordering for sorting in e.g. molecular formulae where carbon and hydrogen come first, otherwise elements are sorted in order of atomic number.</p> <pre><code>&gt;&gt;&gt; sorted([h, f, f, c, n])\n[C, H, N, F, F]\n</code></pre> Source code in <code>chmpy/core/element.py</code> <pre><code>@functools.total_ordering\nclass Element(metaclass=_ElementMeta):\n    \"\"\"Storage class for information about a chemical element.\n\n    Examples:\n        &gt;&gt;&gt; h = Element.from_string(\"H\")\n        &gt;&gt;&gt; c = Element.from_string(\"C\")\n        &gt;&gt;&gt; n = Element.from_atomic_number(7)\n        &gt;&gt;&gt; f = Element.from_string(\"F\")\n\n        Element implements an ordering for sorting in e.g.\n        molecular formulae where carbon and hydrogen come first,\n        otherwise elements are sorted in order of atomic number.\n\n        &gt;&gt;&gt; sorted([h, f, f, c, n])\n        [C, H, N, F, F]\n    \"\"\"\n\n    def __init__(self, atomic_number, name, symbol, cov, vdw, mass):\n        \"\"\"Initialize an Element from its chemical data.\"\"\"\n        self.atomic_number = atomic_number\n        self.name = name\n        self.symbol = symbol\n        self.cov = cov\n        self.vdw = vdw\n        self.mass = mass\n\n    @staticmethod\n    def from_string(s: str) -&gt; \"Element\":\n        \"\"\"Create an element from a given element symbol.\n\n        Args:\n            s (str): a string representation of an element in the periodic table\n\n        Returns:\n            Element: an Element object if the conversion was successful,\n                otherwise an exception is raised\n\n        Examples:\n            &gt;&gt;&gt; Element.from_string(\"h\")\n            H\n            &gt;&gt;&gt; Element[\"rn\"].name\n            'radon'\n            &gt;&gt;&gt; Element[\"AC\"].cov\n            2.15\n        \"\"\"\n        symbol = s.strip().capitalize()\n        if symbol == \"D\":\n            symbol = \"H\"\n        if symbol.isdigit():\n            return Element.from_atomic_number(int(symbol))\n        if symbol not in _EL_FROM_SYM:\n            name = symbol.lower()\n            if name not in _EL_FROM_NAME:\n                return Element.from_label(s)\n            else:\n                return Element(*_EL_FROM_NAME[name])\n        return Element(*_EL_FROM_SYM[symbol])\n\n    @staticmethod\n    def from_label(label: str) -&gt; \"Element\":\n        \"\"\"Create an element from a label e.g. 'C1', 'H2_F2___i' etc.\n\n        Args:\n            l (str): a string representation of an element in the periodic table\n\n        Returns:\n            Element: an Element object if the conversion was successful,\n                otherwise an exception is raised\n\n        Examples:\n            &gt;&gt;&gt; Element.from_label(\"C1\")\n            C\n            &gt;&gt;&gt; Element.from_label(\"H\")\n            H\n            &gt;&gt;&gt; Element[\"LI2_F2____1____i\"]\n            Li\n\n            An ambiguous case, will make this Calcium not Carbon\n            &gt;&gt;&gt; Element.from_label(\"Ca2_F2____1____i\")\n            Ca\n        \"\"\"\n        m = re.match(_SYMBOL_REGEX, label)\n        if m is None:\n            raise ValueError(f\"Could not determine symbol from {label}\")\n        sym = m.group(1).strip().capitalize()\n        if sym not in _EL_FROM_SYM:\n            raise ValueError(f\"Could not determine symbol from {label}\")\n        return Element(*_EL_FROM_SYM[sym])\n\n    @staticmethod\n    def from_atomic_number(n: int) -&gt; \"Element\":\n        \"\"\"Create an element from a given atomic number.\n\n        Args:\n            n (int): the atomic number of the element\n\n        Returns:\n            Element: an Element object if atomic number was valid,\n                otherwise an exception is raised\n\n        Examples:\n            &gt;&gt;&gt; Element.from_atomic_number(2)\n            He\n            &gt;&gt;&gt; Element[79].name\n            'gold'\n        \"\"\"\n        return Element(n, *_ELEMENT_DATA[n - 1])\n\n    @property\n    def vdw_radius(self) -&gt; float:\n        \"\"\"The van der Waals radius in angstroms.\"\"\"\n        return self.vdw\n\n    @property\n    def color(self):\n        \"\"\"The color RGBA color of this element.\"\"\"\n        return _EL_COLORS[self.atomic_number - 1]\n\n    @property\n    def ball_stick_radius(self) -&gt; float:\n        \"\"\"The radius of this element in a ball and stick representation.\"\"\"\n        if self.symbol == \"H\":\n            return self.covalent_radius\n        return self.cov * 0.5\n\n    @property\n    def covalent_radius(self) -&gt; float:\n        \"\"\"The covalent radius in angstroms.\"\"\"\n        return self.cov\n\n    def __repr__(self):\n        \"\"\"Represent this element as a string for REPL.\"\"\"\n        return self.symbol\n\n    def __hash__(self):\n        \"\"\"Hash of this element (its atomic number).\"\"\"\n        return int(self.atomic_number)\n\n    def _is_valid_operand(self, other):\n        return hasattr(other, \"atomic_number\")\n\n    def __eq__(self, other):\n        \"\"\"Check if two Elements have the same atomic number.\"\"\"\n        if not self._is_valid_operand(other):\n            raise NotImplementedError\n        return self.atomic_number == other.atomic_number\n\n    def __lt__(self, other):\n        \"Check which element comes before the other in chemical formulae\"\n        \"(C first, then order of atomic number).\"\n        if not self._is_valid_operand(other):\n            raise NotImplementedError\n        n1, n2 = self.atomic_number, other.atomic_number\n        if n1 == n2:\n            return False\n        if n1 == 6:\n            return True\n        elif n2 == 6:\n            return False\n        else:\n            return n1 &lt; n2\n</code></pre>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.Element.ball_stick_radius","title":"<code>ball_stick_radius</code>  <code>property</code>","text":"<p>The radius of this element in a ball and stick representation.</p>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.Element.color","title":"<code>color</code>  <code>property</code>","text":"<p>The color RGBA color of this element.</p>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.Element.covalent_radius","title":"<code>covalent_radius</code>  <code>property</code>","text":"<p>The covalent radius in angstroms.</p>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.Element.vdw_radius","title":"<code>vdw_radius</code>  <code>property</code>","text":"<p>The van der Waals radius in angstroms.</p>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.Element.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if two Elements have the same atomic number.</p> Source code in <code>chmpy/core/element.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Check if two Elements have the same atomic number.\"\"\"\n    if not self._is_valid_operand(other):\n        raise NotImplementedError\n    return self.atomic_number == other.atomic_number\n</code></pre>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.Element.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash of this element (its atomic number).</p> Source code in <code>chmpy/core/element.py</code> <pre><code>def __hash__(self):\n    \"\"\"Hash of this element (its atomic number).\"\"\"\n    return int(self.atomic_number)\n</code></pre>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.Element.__init__","title":"<code>__init__(atomic_number, name, symbol, cov, vdw, mass)</code>","text":"<p>Initialize an Element from its chemical data.</p> Source code in <code>chmpy/core/element.py</code> <pre><code>def __init__(self, atomic_number, name, symbol, cov, vdw, mass):\n    \"\"\"Initialize an Element from its chemical data.\"\"\"\n    self.atomic_number = atomic_number\n    self.name = name\n    self.symbol = symbol\n    self.cov = cov\n    self.vdw = vdw\n    self.mass = mass\n</code></pre>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.Element.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Check which element comes before the other in chemical formulae</p> Source code in <code>chmpy/core/element.py</code> <pre><code>def __lt__(self, other):\n    \"Check which element comes before the other in chemical formulae\"\n    \"(C first, then order of atomic number).\"\n    if not self._is_valid_operand(other):\n        raise NotImplementedError\n    n1, n2 = self.atomic_number, other.atomic_number\n    if n1 == n2:\n        return False\n    if n1 == 6:\n        return True\n    elif n2 == 6:\n        return False\n    else:\n        return n1 &lt; n2\n</code></pre>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.Element.__repr__","title":"<code>__repr__()</code>","text":"<p>Represent this element as a string for REPL.</p> Source code in <code>chmpy/core/element.py</code> <pre><code>def __repr__(self):\n    \"\"\"Represent this element as a string for REPL.\"\"\"\n    return self.symbol\n</code></pre>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.Element.from_atomic_number","title":"<code>from_atomic_number(n)</code>  <code>staticmethod</code>","text":"<p>Create an element from a given atomic number.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>the atomic number of the element</p> required <p>Returns:</p> Name Type Description <code>Element</code> <code>Element</code> <p>an Element object if atomic number was valid, otherwise an exception is raised</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Element.from_atomic_number(2)\nHe\n&gt;&gt;&gt; Element[79].name\n'gold'\n</code></pre> Source code in <code>chmpy/core/element.py</code> <pre><code>@staticmethod\ndef from_atomic_number(n: int) -&gt; \"Element\":\n    \"\"\"Create an element from a given atomic number.\n\n    Args:\n        n (int): the atomic number of the element\n\n    Returns:\n        Element: an Element object if atomic number was valid,\n            otherwise an exception is raised\n\n    Examples:\n        &gt;&gt;&gt; Element.from_atomic_number(2)\n        He\n        &gt;&gt;&gt; Element[79].name\n        'gold'\n    \"\"\"\n    return Element(n, *_ELEMENT_DATA[n - 1])\n</code></pre>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.Element.from_label","title":"<code>from_label(label)</code>  <code>staticmethod</code>","text":"<p>Create an element from a label e.g. 'C1', 'H2_F2___i' etc.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>str</code> <p>a string representation of an element in the periodic table</p> required <p>Returns:</p> Name Type Description <code>Element</code> <code>Element</code> <p>an Element object if the conversion was successful, otherwise an exception is raised</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Element.from_label(\"C1\")\nC\n&gt;&gt;&gt; Element.from_label(\"H\")\nH\n&gt;&gt;&gt; Element[\"LI2_F2____1____i\"]\nLi\n</code></pre> <p>An ambiguous case, will make this Calcium not Carbon</p> <pre><code>&gt;&gt;&gt; Element.from_label(\"Ca2_F2____1____i\")\nCa\n</code></pre> Source code in <code>chmpy/core/element.py</code> <pre><code>@staticmethod\ndef from_label(label: str) -&gt; \"Element\":\n    \"\"\"Create an element from a label e.g. 'C1', 'H2_F2___i' etc.\n\n    Args:\n        l (str): a string representation of an element in the periodic table\n\n    Returns:\n        Element: an Element object if the conversion was successful,\n            otherwise an exception is raised\n\n    Examples:\n        &gt;&gt;&gt; Element.from_label(\"C1\")\n        C\n        &gt;&gt;&gt; Element.from_label(\"H\")\n        H\n        &gt;&gt;&gt; Element[\"LI2_F2____1____i\"]\n        Li\n\n        An ambiguous case, will make this Calcium not Carbon\n        &gt;&gt;&gt; Element.from_label(\"Ca2_F2____1____i\")\n        Ca\n    \"\"\"\n    m = re.match(_SYMBOL_REGEX, label)\n    if m is None:\n        raise ValueError(f\"Could not determine symbol from {label}\")\n    sym = m.group(1).strip().capitalize()\n    if sym not in _EL_FROM_SYM:\n        raise ValueError(f\"Could not determine symbol from {label}\")\n    return Element(*_EL_FROM_SYM[sym])\n</code></pre>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.Element.from_string","title":"<code>from_string(s)</code>  <code>staticmethod</code>","text":"<p>Create an element from a given element symbol.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>a string representation of an element in the periodic table</p> required <p>Returns:</p> Name Type Description <code>Element</code> <code>Element</code> <p>an Element object if the conversion was successful, otherwise an exception is raised</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Element.from_string(\"h\")\nH\n&gt;&gt;&gt; Element[\"rn\"].name\n'radon'\n&gt;&gt;&gt; Element[\"AC\"].cov\n2.15\n</code></pre> Source code in <code>chmpy/core/element.py</code> <pre><code>@staticmethod\ndef from_string(s: str) -&gt; \"Element\":\n    \"\"\"Create an element from a given element symbol.\n\n    Args:\n        s (str): a string representation of an element in the periodic table\n\n    Returns:\n        Element: an Element object if the conversion was successful,\n            otherwise an exception is raised\n\n    Examples:\n        &gt;&gt;&gt; Element.from_string(\"h\")\n        H\n        &gt;&gt;&gt; Element[\"rn\"].name\n        'radon'\n        &gt;&gt;&gt; Element[\"AC\"].cov\n        2.15\n    \"\"\"\n    symbol = s.strip().capitalize()\n    if symbol == \"D\":\n        symbol = \"H\"\n    if symbol.isdigit():\n        return Element.from_atomic_number(int(symbol))\n    if symbol not in _EL_FROM_SYM:\n        name = symbol.lower()\n        if name not in _EL_FROM_NAME:\n            return Element.from_label(s)\n        else:\n            return Element(*_EL_FROM_NAME[name])\n    return Element(*_EL_FROM_SYM[symbol])\n</code></pre>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.chemical_formula","title":"<code>chemical_formula(elements, subscript=False)</code>","text":"<p>Calculate the chemical formula for the given list of elements.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; chemical_formula([\"O\", \"C\", \"O\"])\n'CO2'\n&gt;&gt;&gt; chemical_formula([\"C\", \"H\", \"O\", \"B\"])\n'BCHO'\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>List[Element or str]</code> <p>a list of elements or element symbols. Note that if a list of strings are provided the order of chemical symbols may not match convention.</p> required <code>subscript</code> <code>bool</code> <p>toggle to use unicode subscripts for the chemical formula string</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <p>the chemical formula</p> Source code in <code>chmpy/core/element.py</code> <pre><code>def chemical_formula(elements, subscript=False):\n    \"\"\"Calculate the chemical formula for the given list of elements.\n\n    Examples:\n        &gt;&gt;&gt; chemical_formula([\"O\", \"C\", \"O\"])\n        'CO2'\n        &gt;&gt;&gt; chemical_formula([\"C\", \"H\", \"O\", \"B\"])\n        'BCHO'\n\n    Args:\n        elements (List[Element or str]): a list of elements or element symbols.\n            Note that if a list of strings are provided the order of chemical\n            symbols may not match convention.\n        subscript (bool, optional): toggle to use unicode subscripts for the\n            chemical formula string\n\n    Returns:\n        str: the chemical formula\n    \"\"\"\n    count = Counter(sorted(elements))\n    if subscript:\n        blocks = []\n        for el, c in count.items():\n            c = \"\".join(chr(0x2080 + int(i)) for i in str(c)) if c &gt; 1 else \"\"\n            blocks.append(f\"{el}{c}\")\n    else:\n        blocks = []\n        for el, c in count.items():\n            c = c if c &gt; 1 else \"\"\n            blocks.append(f\"{el}{c}\")\n    return \"\".join(blocks)\n</code></pre>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.cov_radii","title":"<code>cov_radii(atomic_numbers)</code>","text":"<p>Return the covalent radii for the given atomic numbers.</p> <p>Parameters:</p> Name Type Description Default <code>atomic_numbers</code> <code>array_like</code> <p>the (N,) length integer array of atomic numbers</p> required <p>Returns:</p> Type Description <p>np.ndarray: (N,) array of floats representing covalent radii</p> Source code in <code>chmpy/core/element.py</code> <pre><code>def cov_radii(atomic_numbers):\n    \"\"\"Return the covalent radii for the given atomic numbers.\n\n    Args:\n        atomic_numbers (array_like): the (N,) length integer array of atomic numbers\n\n    Returns:\n        np.ndarray: (N,) array of floats representing covalent radii\n    \"\"\"\n    if np.any(atomic_numbers &lt; 1) or np.any(atomic_numbers &gt; 103):\n        raise ValueError(\"All elements must be atomic numbers between [1,103]\")\n    return np.array([_ELEMENT_DATA[i - 1][2] for i in atomic_numbers], dtype=np.float32)\n</code></pre>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.element_names","title":"<code>element_names(atomic_numbers)</code>","text":"<p>Return the element names for the given atomic numbers.</p> <p>Parameters:</p> Name Type Description Default <code>atomic_numbers</code> <code>array_like</code> <p>the (N,) length integer array of atomic numbers</p> required <p>Returns:</p> Type Description <p>List[str]: (N,) list of strings representing element names</p> Source code in <code>chmpy/core/element.py</code> <pre><code>def element_names(atomic_numbers):\n    \"\"\"Return the element names for the given atomic numbers.\n\n    Args:\n        atomic_numbers (array_like): the (N,) length integer array of atomic numbers\n\n    Returns:\n        List[str]: (N,) list of strings representing element names\n    \"\"\"\n    if np.any(atomic_numbers &lt; 1) or np.any(atomic_numbers &gt; 103):\n        raise ValueError(\"All elements must be atomic numbers between [1,103]\")\n    return [_ELEMENT_DATA[i - 1][0] for i in atomic_numbers]\n</code></pre>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.element_symbols","title":"<code>element_symbols(atomic_numbers)</code>","text":"<p>Return the element symbols for the given atomic numbers.</p> <p>Parameters:</p> Name Type Description Default <code>atomic_numbers</code> <code>array_like</code> <p>the (N,) length integer array of atomic numbers</p> required <p>Returns:</p> Type Description <p>List[str]: (N,) list of strings representing element symbols</p> Source code in <code>chmpy/core/element.py</code> <pre><code>def element_symbols(atomic_numbers):\n    \"\"\"Return the element symbols for the given atomic numbers.\n\n    Args:\n        atomic_numbers (array_like): the (N,) length integer array of atomic numbers\n\n    Returns:\n        List[str]: (N,) list of strings representing element symbols\n    \"\"\"\n    if np.any(atomic_numbers &lt; 1) or np.any(atomic_numbers &gt; 103):\n        raise ValueError(\"All elements must be atomic numbers between [1,103]\")\n    return [_ELEMENT_DATA[i - 1][1] for i in atomic_numbers]\n</code></pre>"},{"location":"reference/chmpy/core/element/#chmpy.core.element.vdw_radii","title":"<code>vdw_radii(atomic_numbers)</code>","text":"<p>Return the van der Waals radii for the given atomic numbers.</p> <p>Parameters:</p> Name Type Description Default <code>atomic_numbers</code> <code>array_like</code> <p>the (N,) length integer array of atomic numbers</p> required <p>Returns:</p> Type Description <p>np.ndarray: (N,) array of floats representing van der Waals radii</p> Source code in <code>chmpy/core/element.py</code> <pre><code>def vdw_radii(atomic_numbers):\n    \"\"\"Return the van der Waals radii for the given atomic numbers.\n\n    Args:\n        atomic_numbers (array_like): the (N,) length integer array of atomic numbers\n\n    Returns:\n        np.ndarray: (N,) array of floats representing van der Waals radii\n    \"\"\"\n    if np.any(atomic_numbers &lt; 1) or np.any(atomic_numbers &gt; 103):\n        raise ValueError(\"All elements must be atomic numbers between [1,103]\")\n    return np.array([_ELEMENT_DATA[i - 1][3] for i in atomic_numbers], dtype=np.float32)\n</code></pre>"},{"location":"reference/chmpy/core/molecule/","title":"molecule","text":""},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule","title":"<code>Molecule</code>","text":"<p>Class to represent information about a molecule i.e. a set of atoms with 3D coordinates joined by covalent bonds</p> <p>e.g. int, float, str etc. Will handle uncertainty values contained in parentheses.</p> <p>Attributes:</p> Name Type Description <code>elements</code> <code>ndarray</code> <p>list of element information for each atom in this molecule</p> <code>positions</code> <code>ndarray</code> <p>(N, 3) array of Cartesian coordinates for each atom in this molecule (Angstroms)</p> <code>bonds</code> <code>dok_matrix</code> <p>(N, N) adjacency matrix of bond lengths for connected atoms, 0 otherwise. If not provided this will be calculated.</p> <code>labels</code> <code>ndarray</code> <p>(N,) vector of string labels for each atom in this molecule If not provided this will assigned default labels i.e. numbered in order.</p> <code>proerties</code> <code>ndarray</code> <p>Additional keyword arguments will be stored in the <code>properties</code> member, and some may be utilized in methods, raising an exception if they are not set.</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>class Molecule:\n    \"\"\"\n    Class to represent information about a\n    molecule i.e. a set of atoms with 3D coordinates\n    joined by covalent bonds\n\n    e.g. int, float, str etc. Will handle uncertainty values\n    contained in parentheses.\n\n    Attributes:\n        elements: list of element information for each atom in this molecule\n        positions: (N, 3) array of Cartesian coordinates for each atom in this\n            molecule (Angstroms)\n        bonds: (N, N) adjacency matrix of bond lengths for connected atoms, 0 otherwise.\n            If not provided this will be calculated.\n        labels: (N,) vector of string labels for each atom in this molecule\n            If not provided this will assigned default labels i.e. numbered in order.\n        proerties: Additional keyword arguments will be stored in the `properties`\n            member, and some may be utilized in methods, raising an exception if they\n            are not set.\n    \"\"\"\n\n    positions: np.ndarray\n    elements: np.ndarray\n    labels: np.ndarray\n    properties: dict\n    bonds: dok_matrix\n\n    def __init__(self, elements, positions, bonds=None, labels=None, **kwargs):\n        \"\"\"\n        Initialize a new molecule.\n\n        Arguments:\n            elements (List[Element]): N length list of elements associated with\n                the sites\n            positions (array_like): (N, 3) array of site positions in Cartesian\n                coordinates\n            bonds (dok_matrix, optional): if bonds are already calculated provide\n                them here\n            labels (array_like, optional): labels (array_like): N length array of\n                string labels for each site\n            **kwargs: Additional properties (will populate the properties member)\n                to store in this molecule\n        \"\"\"\n        self.positions = positions\n        self.elements = elements\n        self.properties = {}\n        self.properties.update(kwargs)\n        self.bonds = None\n\n        self.charge = kwargs.get(\"charge\", 0)\n        self.multiplicity = kwargs.get(\"multiplicity\", 1)\n\n        if bonds is None:\n            if kwargs.get(\"guess_bonds\", False):\n                self.guess_bonds()\n        else:\n            self.bonds = dok_matrix(bonds)\n\n        if labels is None:\n            self.assign_default_labels()\n        else:\n            self.labels = labels\n\n    def __iter__(self):\n        yield from zip(self.elements, self.positions, strict=False)\n\n    def __len__(self):\n        return len(self.elements)\n\n    @property\n    def distance_matrix(self) -&gt; np.ndarray:\n        \"The (dense) pairwise distance matrix for this molecule\"\n        return cdist(self.positions, self.positions)\n\n    @property\n    def unique_bonds(self) -&gt; list:\n        \"\"\"The unique bonds for this molecule. If bonds are not assigned,\n        this will `None`\"\"\"\n        if self.bonds is None:\n            return None\n        return tuple(\n            (a, b, self.bonds[a, b])\n            for a, b in {tuple(sorted(x)) for x in self.bonds.keys()}\n        )\n\n    def guess_bonds(self, tolerance=0.40):\n        \"\"\"\n        Use geometric distances and covalent radii\n        to determine bonding information for this molecule.\n\n        Bonding is determined by the distance between\n        sites being closer than the sum of covalent radii + `tolerance`\n\n        Will set the `bonds` member.\n\n        If the `graph_tool` library is available, this will call the\n        `bond_graph` method to populate the connectivity graph.\n\n\n        Args:\n            tolerance (float, optional): Additional tolerance for attributing\n                two sites as 'bonded'.\n                The default is 0.4 angstroms, which is recommended by the CCDC\n        \"\"\"\n        tree = KDTree(self.positions)\n        covalent_radii = np.array([x.cov for x in self.elements])\n        max_cov = np.max(covalent_radii)\n        thresholds = (\n            covalent_radii[:, np.newaxis] + covalent_radii[np.newaxis, :] + tolerance\n        )\n        max_distance = max_cov * 2 + tolerance\n        dist = tree.sparse_distance_matrix(tree, max_distance=max_distance).toarray()\n        mask = (dist &gt; 0) &amp; (dist &lt; thresholds)\n        self.bonds = np.zeros(dist.shape)\n        self.bonds[mask] = dist[mask]\n        self.bonds = dok_matrix(self.bonds)\n        try:\n            self.bond_graph()\n        except Exception:\n            pass\n\n    def connected_fragments(self) -&gt; list:\n        \"\"\"\n        Separate this molecule into fragments/molecules based\n        on covalent bonding criteria.\n\n        Returns:\n            a list of connected `Molecule` objects\n        \"\"\"\n        from scipy.sparse.csgraph import connected_components\n\n        from chmpy.util.num import cartesian_product\n\n        if self.bonds is None:\n            self.guess_bonds()\n\n        nfrag, labels = connected_components(self.bonds)\n        molecules = []\n        for frag in range(nfrag):\n            atoms = np.where(labels == frag)[0]\n            na = len(atoms)\n            sqidx = cartesian_product(atoms, atoms)\n            molecules.append(\n                Molecule(\n                    [self.elements[i] for i in atoms],\n                    self.positions[atoms],\n                    labels=self.labels[atoms],\n                    bonds=self.bonds[sqidx[:, 0], sqidx[:, 1]].reshape(na, na),\n                )\n            )\n        return molecules\n\n    def assign_default_labels(self):\n        \"Assign the default labels to atom sites in this molecule\"\n        \"(number them by element)\"\n        counts = defaultdict(int)\n        labels = []\n        for el, _ in self:\n            counts[el] += 1\n            labels.append(f\"{el.symbol}{counts[el]}\")\n        self.labels = np.asarray(labels)\n\n    def distance_to(self, other, method=\"centroid\"):\n        \"\"\"\n        Calculate the euclidean distance between this\n        molecule and another. May use the distance between\n        centres-of-mass, centroids, or nearest atoms.\n\n        Parameters\n            other (Molecule): the molecule to calculate distance to\n            method (str, optional): one of 'centroid', 'center_of_mass', 'nearest_atom'\n        \"\"\"\n        method = method.lower()\n        if method == \"centroid\":\n            return np.linalg.norm(self.centroid - other.centroid)\n        elif method == \"center_of_mass\":\n            return np.linalg.norm(self.center_of_mass - other.center_of_mass)\n        elif method == \"nearest_atom\":\n            return np.min(cdist(self.positions, other.positions))\n        else:\n            raise ValueError(f\"Unknown method={method}\")\n\n    @property\n    def atomic_numbers(self) -&gt; np.ndarray:\n        \"Atomic numbers for each atom in this molecule\"\n        return np.array([e.atomic_number for e in self.elements])\n\n    @property\n    def centroid(self) -&gt; np.ndarray:\n        \"Mean cartesian position of atoms in this molecule\"\n        return np.mean(self.positions, axis=0)\n\n    @property\n    def center_of_mass(self) -&gt; np.ndarray:\n        \"Mean cartesian position of atoms in this molecule, weighted by atomic mass\"\n        if len(self) &gt; 0:\n            masses = np.asarray([x.mass for x in self.elements])\n            return np.sum(\n                self.positions * masses[:, np.newaxis] / np.sum(masses), axis=0\n            )\n        return np.zeros(3)\n\n    @property\n    def coordination_numbers(self) -&gt; np.ndarray:\n        \"\"\"The coordination numbers associated with atoms in this molecule.\n        If `self._coordination_numbers` is not set, the coordination numbers will be\n        calculated based on the EEQ method.\"\"\"\n        assert len(self) &gt; 0, (\n            \"Must have at least one atom to calculate coordination numbers\"\n        )\n        if not hasattr(self, \"_coordination_numbers\"):\n            from chmpy.core.eeq import calculate_coordination_numbers\n\n            atomic_numbers = self.atomic_numbers\n            coords = self.positions\n            cn = calculate_coordination_numbers(atomic_numbers, coords)\n            self._coordination_numbers = cn.astype(np.float32)\n        return self._coordination_numbers\n\n    @coordination_numbers.setter\n    def coordination_numbers(self, cn):\n        self._coordination_numbers = cn\n\n    @coordination_numbers.deleter\n    def coordination_numbers(self):\n        del self._coordination_numbers\n\n    @property\n    def partial_charges(self) -&gt; np.ndarray:\n        \"\"\"The partial charges associated with atoms in this molecule.\n        If `self._partial_charges` is not set, the charges will be\n        calculated based on the requested method (default: EEM).\n\n        The available methods are:\n        - 'eem': Electronegativity Equalization Method (default)\n        - 'eeq': Electronegativity Equilibration Charge model\n\n        To specify a method, set the 'charge_method' property on the molecule:\n        molecule.properties['charge_method'] = 'eeq'\n        \"\"\"\n        assert len(self) &gt; 0, \"Must have at least one atom to calculate partial charges\"\n        if not hasattr(self, \"_partial_charges\"):\n            # Check which method to use\n            method = self.properties.get(\"charge_method\", \"eem\").lower()\n\n            if method == \"eeq\":\n                from chmpy.core.eeq import calculate_eeq_charges\n\n                atomic_numbers = self.atomic_numbers\n                coords = self.positions\n                charge = self.charge\n                charges = calculate_eeq_charges(atomic_numbers, coords, charge)\n            else:  # default to EEM\n                from chmpy.ext.charges import EEM\n\n                charges = EEM.calculate_charges(self)\n\n            self._partial_charges = charges.astype(np.float32)\n        return self._partial_charges\n\n    @partial_charges.setter\n    def partial_charges(self, charges):\n        self._partial_charges = charges\n\n    @partial_charges.deleter\n    def partial_charges(self):\n        del self._partial_charges\n\n    def electrostatic_potential_from_cube(self, cube, positions):\n        LOG.info(\"Interpolating ESP using assigned cube data\")\n        interpolator = cube.interpolator()\n        return interpolator.predict(positions)\n\n    def electrostatic_potential(self, positions) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the electrostatic potential based on the partial\n        charges associated with this molecule. The potential will be\n        in atomic units.\n\n        Args:\n            positions (np.ndarray): (N, 3) array of locations where the\n                molecular ESP should be calculated. Assumed to be in Angstroms.\n\n        Returns:\n            np.ndarray: (N,) array of electrostatic potential values (atomic units)\n            at the given positions.\n        \"\"\"\n        if \"esp_cube\" in self.properties:\n            return self.electrostatic_potential_from_cube(\n                self.properties[\"esp_cube\"], positions\n            )\n\n        from chmpy.util.unit import BOHR_TO_ANGSTROM\n\n        v_pot = np.zeros(positions.shape[0])\n        for charge, position in zip(self.partial_charges, self.positions, strict=False):\n            if charge == 0.0:\n                continue\n            r = np.linalg.norm(positions - position[np.newaxis, :], axis=1)\n            v_pot += BOHR_TO_ANGSTROM * charge / r\n        return v_pot\n\n    @property\n    def molecular_formula(self) -&gt; str:\n        \"string of the molecular formula for this molecule\"\n        from .element import chemical_formula\n\n        if len(self) &gt; 0:\n            return chemical_formula(self.elements, subscript=False)\n        return \"empty\"\n\n    def __repr__(self):\n        x, y, z = self.center_of_mass\n        return f\"&lt;{self.name} ({self.molecular_formula})[{x:.2f} {y:.2f} {z:.2f}]&gt;\"\n\n    @classmethod\n    def from_ase_atoms(cls, atoms, **kwargs):\n        from chmpy.ext.ase import ase_to_molecule\n\n        return ase_to_molecule(atoms, **kwargs)\n\n    @classmethod\n    def from_xyz_string(cls, contents, **kwargs):\n        \"\"\"\n        Construct a molecule from the provided xmol .xyz file. kwargs\n        will be passed through to the Molecule constructor.\n\n        Args:\n            contents (str): the contents of the .xyz file to read\n            kwargs: keyword arguments passed ot the `Molecule` constructor\n\n        Returns:\n            Molecule: A new `Molecule` object\n        \"\"\"\n        from chmpy.fmt.xyz_file import parse_xyz_string\n\n        elements, positions = parse_xyz_string(contents)\n        return cls(elements, np.asarray(positions), **kwargs)\n\n    @classmethod\n    def from_xyz_file(cls, filename, **kwargs):\n        \"\"\"\n        Construct a molecule from the provided xmol .xyz file. kwargs\n        will be passed through to the Molecule constructor.\n\n        Args:\n            filename (str): the path to the .xyz file\n            kwargs: keyword arguments passed ot the `Molecule` constructor\n\n        Returns:\n            Molecule: A new `Molecule` object\n        \"\"\"\n\n        return cls.from_xyz_string(Path(filename).read_text(), **kwargs)\n\n    @classmethod\n    def from_turbomole_string(cls, contents, **kwargs):\n        \"\"\"\n        Construct a molecule from the provided turbomole file contents. kwargs\n        will be passed through to the Molecule constructor.\n\n        Args:\n            contents (str): the contents of the .xyz file to read\n            kwargs: keyword arguments passed ot the `Molecule` constructor\n\n        Returns:\n            Molecule: A new `Molecule` object\n        \"\"\"\n        from chmpy.fmt.tmol import parse_tmol_string\n\n        elements, positions = parse_tmol_string(contents)\n        return cls(elements, np.asarray(positions), **kwargs)\n\n    @classmethod\n    def from_turbomole_file(cls, filename, **kwargs):\n        \"\"\"\n        Construct a molecule from the provided turbomole file. kwargs\n        will be passed through to the Molecule constructor.\n\n        Args:\n            filename (str): the path to the .xyz file\n            kwargs: keyword arguments passed ot the `Molecule` constructor\n\n        Returns:\n            Molecule: A new `Molecule` object\n        \"\"\"\n        return cls.from_turbomole_string(Path(filename).read_text(), **kwargs)\n\n    @classmethod\n    def from_fchk_string(cls, fchk_contents, **kwargs):\n        from chmpy.fmt.fchk import FchkFile\n        from chmpy.util.unit import units\n\n        fchk = FchkFile(fchk_contents, parse=True)\n        elements = np.array(fchk[\"Atomic numbers\"])\n        positions = np.array(fchk[\"Current cartesian coordinates\"]).reshape(\n            elements.shape[0], 3\n        )\n        positions = units.angstrom(positions, unit=\"bohr\")\n        return cls.from_arrays(elements=elements, positions=positions, **kwargs)\n\n    @classmethod\n    def from_fchk_file(cls, filename, **kwargs):\n        return cls.from_fchk_string(Path(filename).read_text(), **kwargs)\n\n    @classmethod\n    def from_mol2_string(cls, contents, **kwargs):\n        from chmpy.fmt.mol2 import parse_mol2_string\n\n        atoms, bonds = parse_mol2_string(contents)\n        elements = [Element[x] for x in atoms.pop(\"type\")]\n\n        N = len(elements)\n\n        positions = np.array(\n            [\n                tuple(p)\n                for p in zip(\n                    atoms.pop(\"x\"), atoms.pop(\"y\"), atoms.pop(\"z\"), strict=False\n                )\n            ]\n        )\n\n        labels = None\n        if \"name\" in atoms:\n            labels = atoms.pop(\"name\")\n\n        bondlist = None\n        if bonds != {}:\n            bondlist = dok_matrix((N, N))\n\n            for a, b, t in zip(\n                bonds[\"origin\"], bonds[\"target\"], bonds[\"type\"], strict=False\n            ):\n                bondlist[a - 1, b - 1] = int(t)\n\n        return cls(\n            elements, positions, bonds=bondlist, labels=labels, **atoms, **kwargs\n        )\n\n    @classmethod\n    def from_mol2_file(cls, filename, **kwargs):\n        return cls.from_mol2_string(Path(filename).read_text(), **kwargs)\n\n    @classmethod\n    def _ext_load_map(cls):\n        return {\n            \".xyz\": cls.from_xyz_file,\n            \".sdf\": cls.from_sdf_file,\n            \".fchk\": cls.from_fchk_file,\n            \".coord\": cls.from_turbomole_file,\n            \".mol2\": cls.from_mol2_file,\n        }\n\n    @classmethod\n    def _fname_load_map(cls):\n        return {}\n\n    def _ext_save_map(self):\n        return {\".xyz\": self.to_xyz_file, \".sdf\": self.to_sdf_file}\n\n    def _fname_save_map(self):\n        return {}\n\n    @classmethod\n    def load(cls, filename, **kwargs):\n        \"\"\"\n        Construct a molecule from the provided file.\n\n        Args:\n            filename (str): the path to the (xyz or SDF) file\n            kwargs: keyword arguments passed ot the `Molecule` constructor\n\n        Returns:\n            Molecule: A new `Molecule` object\n        \"\"\"\n        fpath = Path(filename)\n        n = fpath.name\n        fname_map = cls._fname_load_map()\n        if n in fname_map:\n            return fname_map[n](filename)\n        extension_map = cls._ext_load_map()\n        extension = kwargs.pop(\"fmt\", fpath.suffix.lower())\n        if not extension.startswith(\".\"):\n            extension = \".\" + extension\n        return extension_map[extension](filename, **kwargs)\n\n    def to_sdf_string(self) -&gt; str:\n        \"\"\"\n        Represent this molecule as a string in the format\n        of an MDL .sdf file.\n\n        Returns:\n            contents (str) the contents of the .sdf file\n        \"\"\"\n        from chmpy.fmt.sdf import to_sdf_string\n\n        bonds_left = []\n        bonds_right = []\n        if self.bonds is not None:\n            self.guess_bonds()\n            for x, y in self.bonds.keys():\n                bonds_left.append(x + 1)\n                bonds_right.append(y + 1)\n\n        sdf_dict = {\n            \"header\": [self.name, \"created by chmpy\", \"\"],\n            \"atoms\": {\n                \"x\": self.positions[:, 0],\n                \"y\": self.positions[:, 0],\n                \"z\": self.positions[:, 0],\n                \"symbol\": np.array([x.symbol for x in self.elements]),\n            },\n            \"bonds\": {\n                \"left\": np.array(bonds_left),\n                \"right\": np.array(bonds_right),\n            },\n        }\n        return to_sdf_string(sdf_dict)\n\n    def to_sdf_file(self, filename, **kwargs):\n        \"\"\"\n        Represent this molecule as an\n        of an MDL .sdf file. Keyword arguments are\n        passed to `self.to_sdf_string`.\n\n        Args:\n            filename (str): The path in which store this molecule\n            kwargs: Keyword arguments to be passed to `self.to_sdf_string`\n        \"\"\"\n        Path(filename).write_text(self.to_sdf_string(**kwargs))\n\n    def to_xyz_string(self, header=True) -&gt; str:\n        \"\"\"\n        Represent this molecule as a string in the format\n        of an xmol .xyz file.\n\n        Args:\n            header (bool, optional):toggle whether or not to return the 'header' of the\n                xyz file i.e. the number of atoms line and the comment line\n\n        Returns:\n            contents (str) the contents of the .xyz file\n        \"\"\"\n        if header:\n            lines = [\n                f\"{len(self)}\",\n                self.properties.get(\"comment\", self.molecular_formula),\n            ]\n        else:\n            lines = []\n        for el, (x, y, z) in zip(self.elements, self.positions, strict=False):\n            lines.append(f\"{el} {x: 20.12f} {y: 20.12f} {z: 20.12f}\")\n        return \"\\n\".join(lines)\n\n    def to_xyz_file(self, filename, **kwargs):\n        \"\"\"\n        Represent this molecule as an\n        of an xmol .xyz file. Keyword arguments are\n        passed to `self.to_xyz_string`.\n\n        Args:\n            filename (str): The path in which store this molecule\n            kwargs: Keyword arguments to be passed to `self.to_xyz_string`\n        \"\"\"\n\n        Path(filename).write_text(self.to_xyz_string(**kwargs))\n\n    def to_ase_atoms(self, **kwargs):\n        from chmpy.ext.ase import molecule_to_ase\n\n        return molecule_to_ase(self, **kwargs)\n\n    def save(self, filename, **kwargs):\n        \"\"\"\n        Save this molecule to the destination file in xyz format,\n        optionally discarding the typical header.\n\n        Args:\n            filename (str): path to the destination file\n            kwargs: keyword arguments passed to the relevant method\n        \"\"\"\n        fpath = Path(filename)\n        n = fpath.name\n        fname_map = self._fname_save_map()\n        if n in fname_map:\n            return fname_map[n](filename, **kwargs)\n        extension_map = self._ext_save_map()\n        extension = kwargs.pop(\"fmt\", fpath.suffix.lower())\n        if not extension.startswith(\".\"):\n            extension = \".\" + extension\n        return extension_map[extension](filename, **kwargs)\n\n    @property\n    def bbox_corners(self) -&gt; tuple:\n        \"the lower, upper corners of a axis-aligned bounding box for this molecule\"\n        b_min = np.min(self.positions, axis=0)\n        b_max = np.max(self.positions, axis=0)\n        return (b_min, b_max)\n\n    @property\n    def bbox_size(self) -&gt; np.ndarray:\n        \"the dimensions of the axis-aligned bounding box for this molecule\"\n        b_min, b_max = self.bbox_corners\n        return np.abs(b_max - b_min)\n\n    def bond_graph(self):\n        \"\"\"\n        Calculate the `graph_tool.Graph` object corresponding\n        to this molecule. Requires the graph_tool library to be\n        installed\n\n        Returns:\n            graph_tool.Graph: the (undirected) graph of this molecule\n        \"\"\"\n\n        if hasattr(self, \"_bond_graph\"):\n            return self._bond_graph\n        try:\n            import graph_tool as gt\n        except ImportError as e:\n            raise RuntimeError(\n                \"Please install the graph_tool library for graph operations\"\n            ) from e\n        if self.bonds is None:\n            self.guess_bonds()\n        g = gt.Graph(directed=False)\n        v_el = g.new_vertex_property(\"int\")\n        g.add_edge_list(self.bonds.keys())\n        e_w = g.new_edge_property(\"float\")\n        v_el.a[:] = self.atomic_numbers\n        g.vertex_properties[\"element\"] = v_el\n        e_w.a[:] = list(self.bonds.values())\n        g.edge_properties[\"bond_distance\"] = e_w\n        self._bond_graph = g\n        return g\n\n    def functional_groups(self, kind=None) -&gt; dict | list:\n        \"\"\"\n        Find all indices of atom groups which constitute\n        subgraph isomorphisms with stored functional group data\n\n        Args:\n            kind (str, optional):Find only matches of the given kind\n\n        Returns:\n            Either a dict with keys as functional group type and values as list of\n            lists of indices, or a list of lists of indices if kind is specified.\n        \"\"\"\n        global _FUNCTIONAL_GROUP_SUBGRAPHS\n        try:\n            import graph_tool.topology as top  # noqa: F401\n        except ImportError as e:\n            raise RuntimeError(\n                \"Please install the graph_tool library for graph operations\"\n            ) from e\n\n        if not _FUNCTIONAL_GROUP_SUBGRAPHS:\n            from chmpy.subgraphs import load_data\n\n            _FUNCTIONAL_GROUP_SUBGRAPHS = load_data()\n\n        if kind is not None:\n            sub = _FUNCTIONAL_GROUP_SUBGRAPHS[kind]\n            matches = self.matching_subgraph(sub)\n            if kind == \"ring\":\n                matches = list({tuple(sorted(x)) for x in matches})\n            return matches\n\n        matches = {}\n        for n, sub in _FUNCTIONAL_GROUP_SUBGRAPHS.items():\n            m = self.matching_subgraph(sub)\n            if n == \"ring\":\n                m = list({tuple(sorted(x)) for x in m})\n            matches[n] = m\n        return matches\n\n    def matching_subgraph(self, sub):\n        \"\"\"Find all indices of atoms which match the given graph.\n\n        Args:\n            sub (graph_tool.Graph): the subgraph\n\n        Returns:\n            List: list of lists of atomic indices matching the atoms in sub\n                to those in this molecule\n        \"\"\"\n\n        try:\n            import graph_tool.topology as top\n        except ImportError as e:\n            raise RuntimeError(\n                \"Please install the graph_tool library for graph operations\"\n            ) from e\n\n        g = self.bond_graph()\n        matches = top.subgraph_isomorphism(\n            sub,\n            g,\n            vertex_label=(\n                sub.vertex_properties[\"element\"],\n                g.vertex_properties[\"element\"],\n            ),\n        )\n        return [tuple(x.a) for x in matches]\n\n    def matching_fragments(self, fragment, method=\"connectivity\"):\n        \"\"\"\n        Find the indices of a matching fragment to the given\n        molecular fragment\n\n        Args:\n            fragment (Molecule): Molecule object containing the desired fragment\n            method (str, optional): the method for matching\n\n        Returns:\n            List[dict]: List of maps between matching indices in this molecule and those\n                in the fragment\n        \"\"\"\n        try:\n            import graph_tool.topology as top\n        except ImportError as e:\n            raise RuntimeError(\n                \"Please install the graph_tool library for graph operations\"\n            ) from e\n\n        sub = fragment.bond_graph()\n        g = self.bond_graph()\n        matches = top.subgraph_isomorphism(\n            sub,\n            g,\n            vertex_label=(\n                sub.vertex_properties[\"element\"],\n                g.vertex_properties[\"element\"],\n            ),\n        )\n        return [list(x.a) for x in matches]\n\n    def calculate_wavefunction(self, method=\"HF\", basis_set=\"3-21G\", program=\"nwchem\"):\n        from chmpy.fmt.nwchem import to_nwchem_input\n\n        return to_nwchem_input(self, method=method, basis_set=basis_set)\n\n    def atomic_shape_descriptors(\n        self, l_max=5, radius=6.0, background=1e-5\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the shape descriptors`[1,2]` for all\n        atoms in this isolated molecule. If you wish to use\n        the crystal environment please see the corresponding method\n        in :obj:`chmpy.crystal.Crystal`.\n\n        Args:\n            l_max (int, optional): maximum level of angular momenta to include\n                in the spherical harmonic transform of the shape function. (default=5)\n            radius (float, optional): Maximum distance in Angstroms between\n                any atom in the molecule and the resulting neighbouring\n                atoms (default=6.0)\n            background (float, optional): 'background' density to ensure closed\n                surfaces for isolated atoms (default=1e-5)\n\n        Returns:\n            shape description vector\n\n        References:\n            [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n                https://dx.doi.org/10.1038/srep22204\n            [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n                https://dx.doi.org/10.1002/anie.201906602\n        \"\"\"\n        descriptors = []\n        from chmpy.shape import SHT, stockholder_weight_descriptor\n\n        sph = SHT(l_max)\n        elements = self.atomic_numbers\n        positions = self.positions\n        dists = self.distance_matrix\n\n        for n in range(elements.shape[0]):\n            els = elements[n : n + 1]\n            pos = positions[n : n + 1, :]\n            idxs = np.where((dists[n, :] &lt; radius) &amp; (dists[n, :] &gt; 1e-3))[0]\n            neighbour_els = elements[idxs]\n            neighbour_pos = positions[idxs]\n            ubound = Element[n].vdw_radius * 3\n            descriptors.append(\n                stockholder_weight_descriptor(\n                    sph,\n                    els,\n                    pos,\n                    neighbour_els,\n                    neighbour_pos,\n                    bounds=(0.2, ubound),\n                    background=background,\n                )\n            )\n        return np.asarray(descriptors)\n\n    def atomic_stockholder_weight_isosurfaces(self, **kwargs):\n        \"\"\"\n        Calculate the stockholder weight isosurfaces for the atoms\n        in this molecule, with the provided background density.\n\n        Keyword Args:\n            background: float, optional\n                'background' density to ensure closed surfaces for isolated atoms\n                (default=1e-5)\n            isovalue: float, optional\n                level set value for the isosurface (default=0.5). Must be between\n                0 and 1, but values other than 0.5 probably won't make sense anyway.\n            separation: float, optional\n                separation between density grid used in the surface calculation\n                (default 0.2) in Angstroms.\n            radius: float, optional\n                maximum distance for contributing neighbours for the stockholder\n                weight calculation\n            color: str, optional\n                surface property to use for vertex coloring, one of ('d_norm_i',\n                'd_i', 'd_norm_e', 'd_e', 'd_norm')\n            colormap: str, optional\n                matplotlib colormap to use for surface coloring (default 'viridis_r')\n            midpoint: float, optional, default 0.0 if using d_norm\n                use the midpoint norm (as is used in CrystalExplorer)\n\n        Returns:\n            List[trimesh.Trimesh]: A list of meshes representing the stockholder\n                weight isosurfaces\n        \"\"\"\n\n        import trimesh\n        from matplotlib.cm import get_cmap\n\n        from chmpy import StockholderWeight\n        from chmpy.surface import stockholder_weight_isosurface\n        from chmpy.util.color import DEFAULT_COLORMAPS\n\n        sep = kwargs.get(\"separation\", kwargs.get(\"resolution\", 0.2))\n        radius = kwargs.get(\"radius\", 12.0)\n        background = kwargs.get(\"background\", 1e-5)\n        vertex_color = kwargs.get(\"color\", \"d_norm_i\")\n        isovalue = kwargs.get(\"isovalue\", 0.5)\n        midpoint = kwargs.get(\"midpoint\", 0.0 if vertex_color == \"d_norm\" else None)\n        meshes = []\n        colormap = get_cmap(\n            kwargs.get(\"colormap\", DEFAULT_COLORMAPS.get(vertex_color, \"viridis_r\"))\n        )\n        isos = []\n        elements = self.atomic_numbers\n        positions = self.positions\n        dists = self.distance_matrix\n\n        for n in range(elements.shape[0]):\n            els = elements[n : n + 1]\n            pos = positions[n : n + 1, :]\n            idxs = np.where((dists[n, :] &lt; radius) &amp; (dists[n, :] &gt; 1e-3))[0]\n            neighbour_els = elements[idxs]\n            neighbour_pos = positions[idxs]\n\n            s = StockholderWeight.from_arrays(\n                els, pos, neighbour_els, neighbour_pos, background=background\n            )\n            iso = stockholder_weight_isosurface(s, isovalue=isovalue, sep=sep)\n            isos.append(iso)\n        for iso in isos:\n            prop = iso.vertex_prop[vertex_color]\n            norm = None\n            if midpoint is not None:\n                from matplotlib.colors import DivergingNorm\n\n                norm = DivergingNorm(vmin=prop.min(), vcenter=midpoint, vmax=prop.max())\n                prop = norm(prop)\n            color = colormap(prop)\n            mesh = trimesh.Trimesh(\n                vertices=iso.vertices,\n                faces=iso.faces,\n                normals=iso.normals,\n                vertex_colors=color,\n            )\n            meshes.append(mesh)\n        return meshes\n\n    def shape_descriptors(self, l_max=5, **kwargs) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the molecular shape descriptors`[1,2]` for\n        this molecule using the promolecule density.\n\n        Args:\n            l_max (int, optional): maximum level of angular momenta to include in\n                the spherical harmonic transform of the molecular shape function.\n\n        Keyword Args:\n            with_property (str, optional): describe the combination of the radial\n                shape function and a surface property in the real, imaginary channels\n                of a complex function\n            isovalue (float, optional): the isovalue for the promolecule density\n                surface (default 0.0002 au)\n\n        Returns:\n            shape description vector\n\n        References:\n            [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n                https://dx.doi.org/10.1038/srep22204\n            [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n                https://dx.doi.org/10.1002/anie.201906602\n        \"\"\"\n        from chmpy.shape import SHT, promolecule_density_descriptor\n\n        sph = SHT(l_max)\n        return promolecule_density_descriptor(\n            sph, self.atomic_numbers, self.positions, **kwargs\n        )\n\n    def promolecule_density_isosurface(self, **kwargs):\n        \"\"\"\n        Calculate promolecule electron density isosurface\n        for this molecule.\n\n        Keyword Args:\n            isovalue: float, optional\n                level set value for the isosurface (default=0.002) in au.\n            separation: float, optional\n                separation between density grid used in the surface calculation\n                (default 0.2) in Angstroms.\n            color: str, optional\n                surface property to use for vertex coloring, one of ('d_norm_i',\n                'd_i', 'd_norm_e', 'd_e')\n            colormap: str, optional\n                matplotlib colormap to use for surface coloring (default 'viridis_r')\n            midpoint: float, optional, default 0.0 if using d_norm\n                use the midpoint norm (as is used in CrystalExplorer)\n\n        Returns:\n            trimesh.Trimesh: A mesh representing the promolecule density isosurface\n        \"\"\"\n        import trimesh\n\n        from chmpy import PromoleculeDensity\n        from chmpy.surface import promolecule_density_isosurface\n        from chmpy.util.color import property_to_color\n\n        isovalue = kwargs.get(\"isovalue\", 0.002)\n        sep = kwargs.get(\"separation\", kwargs.get(\"resolution\", 0.2))\n        vertex_color = kwargs.get(\"color\", \"d_norm_i\")\n        extra_props = {}\n        pro = PromoleculeDensity((self.atomic_numbers, self.positions))\n        if vertex_color == \"esp\":\n            extra_props[\"esp\"] = self.electrostatic_potential\n        iso = promolecule_density_isosurface(\n            pro, sep=sep, isovalue=isovalue, extra_props=extra_props\n        )\n        prop = iso.vertex_prop[vertex_color]\n        color = property_to_color(prop, cmap=kwargs.get(\"cmap\", vertex_color))\n        mesh = trimesh.Trimesh(\n            vertices=iso.vertices,\n            faces=iso.faces,\n            normals=iso.normals,\n            vertex_colors=color,\n        )\n        return mesh\n\n    def to_mesh(self, **kwargs):\n        \"\"\"\n        Convert this molecule to a mesh of spheres and\n        cylinders, colored by element. The origins of the spheres\n        will be at the corresponding atomic position, and all units\n        will be Angstroms.\n\n        Returns:\n            dict: a dictionary of `trimesh.Trimesh` objects representing this molecule.\n        \"\"\"\n        from chmpy.util.mesh import molecule_to_meshes\n\n        return molecule_to_meshes(self, **kwargs)\n\n    @property\n    def name(self):\n        \"The name of this molecule, checks 'GENERIC_NAME' and 'name'\"\n        \"keys in `self.properties`\"\n        return self.properties.get(\n            \"GENERIC_NAME\", self.properties.get(\"name\", self.__class__.__name__)\n        )\n\n    @property\n    def molecular_dipole_moment(self):\n        if \"molecular_dipole\" in self.properties:\n            return self.properties[\"molecular_dipole\"]\n\n        if hasattr(self, \"_partial_charges\"):\n            from chmpy.util.unit import ANGSTROM_TO_BOHR\n\n            net_charge = np.sum(self.partial_charges)\n            if np.abs(net_charge) &gt; 1e-3:\n                LOG.warn(\n                    \"Molecular dipole will be origin dependent: molecule \"\n                    \"has a net charge (%f)\",\n                    net_charge,\n                )\n            r = ANGSTROM_TO_BOHR * (self.positions - self.center_of_mass)\n            return np.sum(r * self.partial_charges[:, np.newaxis], axis=0)\n        return np.zeros(3)\n\n    @property\n    def asym_symops(self):\n        \"the symmetry operations which generate this molecule\"\n        \"(default x,y,z if not set)\"\n        return self.properties.get(\"generator_symop\", [16484] * len(self))\n\n    @classmethod\n    def from_arrays(cls, elements, positions, **kwargs):\n        \"\"\"\n        Construct a molecule from the provided arrays. kwargs\n        will be passed through to the Molecule constructor.\n\n        Args:\n            elements (np.ndarray): (N,) array of atomic numbers for each\n                atom in this molecule\n            positions (np.ndarray): (N, 3) array of Cartesian coordinates\n                for each atom in this molecule (Angstroms)\n\n        Returns:\n            Molecule: a new molecule object\n        \"\"\"\n        return cls([Element[x] for x in elements], np.array(positions), **kwargs)\n\n    def mask(self, mask, **kwargs):\n        \"\"\"\n        Convenience method to construct a new molecule from this molecule\n        with the given mask array.\n\n        Args:\n            mask (np.ndarray): a numpy mask array used to filter which\n                atoms to keep in the new molecule.\n\n        Returns:\n            Molecule: a new `Molecule`, with atoms filtered by the mask.\n        \"\"\"\n        return Molecule.from_arrays(\n            self.atomic_numbers[mask], self.positions[mask], **kwargs\n        )\n\n    def rotate(self, rotation, origin=(0, 0, 0)):\n        \"\"\"\n        Convenience method to rotate this molecule by a given\n        rotation matrix\n\n        Args:\n            rotation (np.ndarray): A (3, 3) rotation matrix\n        \"\"\"\n\n        if np.allclose(origin, (0, 0, 0)):\n            np.dot(self.positions, rotation, out=self.positions)\n        else:\n            self.positions -= origin\n            np.dot(self.positions, rotation, out=self.positions)\n            self.positions += origin\n\n    def axes(self, homogeneous=False, method=\"pca\"):\n        if method == \"pca\":\n            axes, s, vh = np.linalg.svd((self.positions - self.center_of_mass).T)\n        else:\n            raise ValueError(f\"Unknown molecular axis method '{method}'\")\n        if homogeneous:\n            transform = np.eye(4)\n            transform[:3, :3] = axes\n            translation = -np.dot(axes, self.center_of_mass)\n            transform[:3, 3] = translation\n            transform[np.abs(transform) &lt; 1e-15] = 0\n            return transform\n        return axes\n\n    def inertia_tensor(self):\n        masses = np.asarray([x.mass for x in self.elements])\n        d = self.positions - self.center_of_mass\n        d2 = d**2\n        (d2).sum(axis=1)\n        tensor = np.empty((3, 3))\n        tensor[0, 0] = np.sum(masses * (d2[:, 1] + d2[:, 2]))\n        tensor[1, 1] = np.sum(masses * (d2[:, 0] + d2[:, 2]))\n        tensor[2, 2] = np.sum(masses * (d2[:, 0] + d2[:, 1]))\n        tensor[0, 1] = -np.sum(masses * d[:, 0] * d[:, 1])\n        tensor[1, 0] = tensor[0, 1]\n        tensor[0, 2] = -np.sum(masses * d[:, 0] * d[:, 2])\n        tensor[2, 0] = tensor[0, 2]\n        tensor[1, 2] = -np.sum(masses * d[:, 1] * d[:, 2])\n        tensor[2, 1] = tensor[1, 2]\n        return tensor\n\n    def principle_moments_of_inertia(self, units=\"amu angstrom^2\"):\n        t = self.inertia_tensor()\n        return np.sort(np.linalg.eig(t)[0])\n\n    def rotational_constants(self, unit=\"MHz\"):\n        from scipy.constants import Avogadro, Planck, speed_of_light\n\n        # convert amu angstrom^2 to g cm^2\n        moments = self.principle_moments_of_inertia() / Avogadro / 1e16\n\n        # convert g cm^2 to kg m^2\n        return 1e5 * Planck / (8 * np.pi * np.pi * speed_of_light * moments)\n\n    def positions_in_molecular_axis_frame(self, method=\"pca\"):\n        if method not in (\"pca\",):\n            raise NotImplementedError(\"Only pca implemented\")\n        if len(self) == 1:\n            return np.array([[0.0, 0.0, 0.0]])\n        axis = self.axes(method=method)\n        return np.dot(self.positions - self.center_of_mass, axis.T)\n\n    def oriented(self, method=\"pca\"):\n        from copy import deepcopy\n\n        result = deepcopy(self)\n        result.positions = self.positions_in_molecular_axis_frame(method=method)\n        return result\n\n    def rotated(self, rotation, origin=(0, 0, 0)):\n        \"\"\"\n        Convenience method to construct a new copy of thismolecule\n        rotated by a given rotation matrix\n\n        Args:\n            rotation (np.ndarray): A (3, 3) rotation matrix\n\n        Returns:\n            Molecule: a new copy of this `Molecule` rotated by the\n                given rotation matrix.\n        \"\"\"\n        from copy import deepcopy\n\n        result = deepcopy(self)\n        result.rotate(rotation, origin=origin)\n        return result\n\n    def translate(self, translation):\n        \"\"\"\n        Convenience method to translate this molecule by a given\n        translation vector\n\n        Args:\n            translation (np.ndarray): A (3,) vector of x, y, z coordinates\n            of the translation\n        \"\"\"\n        self.positions += translation\n\n    def translated(self, translation):\n        \"\"\"\n        Convenience method to construct a new copy of this molecule\n        translated by a given translation vector\n\n        Args:\n            translation (np.ndarray): A (3,) vector of x, y, z coordinates\n                of the translation\n\n        Returns:\n            Molecule: a new copy of this `Molecule` translated by the\n                given vector.\n        \"\"\"\n        import copy\n\n        result = copy.deepcopy(self)\n        result.positions += translation\n        return result\n\n    def transform(self, rotation=None, translation=None):\n        \"\"\"\n        Convenience method to transform this molecule\n        by rotation and translation.\n\n        Args:\n            rotation (np.ndarray): A (3,3) rotation matrix\n            translation (np.ndarray): A (3,) vector of x, y, z\n                coordinates of the translation\n        \"\"\"\n\n        if rotation is not None:\n            self.rotate(rotation, origin=(0, 0, 0))\n        if translation is not None:\n            self.translate(translation)\n\n    def transformed(self, rotation=None, translation=None):\n        \"\"\"\n        Convenience method to transform this molecule\n        by rotation and translation.\n\n        Args:\n            rotation (np.ndarray): A (3,3) rotation matrix\n            translation (np.ndarray): A (3,) vector of x, y, z\n                coordinates of the translation\n\n        Returns:\n            Molecule: a new copy of this `Molecule` transformed by the\n                provided matrix and vector.\n        \"\"\"\n\n        from copy import deepcopy\n\n        result = deepcopy(self)\n        result.transform(rotation=rotation, translation=translation)\n        return result\n\n    @classmethod\n    def from_sdf_dict(cls, sdf_dict, **kwargs) -&gt; \"Molecule\":\n        \"\"\"\n        Construct a molecule from the provided dictionary of\n        sdf terms. Not intended for typical use cases, but as a\n        helper method for `Molecule.from_sdf_file`\n\n        Args:\n            sdf_dict (dict): a dictionary containing the 'atoms', 'x', 'y', 'z',\n                'symbol', 'bonds' members.\n\n        Returns:\n            Molecule: a new `Molecule` from the provided data\n        \"\"\"\n        atoms = sdf_dict[\"atoms\"]\n        positions = np.c_[atoms[\"x\"], atoms[\"y\"], atoms[\"z\"]]\n        elements = [Element[x] for x in atoms[\"symbol\"]]\n        # TODO use bonds from SDF\n        # bonds = sdf_dict[\"bonds\"]\n        m = cls(elements, positions, **sdf_dict[\"data\"])\n        if \"sdf\" in sdf_dict:\n            m.properties[\"sdf\"] = sdf_dict[\"sdf\"]\n        return m\n\n    @classmethod\n    def from_sdf_file(cls, filename, **kwargs):\n        \"\"\"\n        Construct a molecule from the provided SDF file.\n        Because an SDF file can have multiple molecules,\n        an optional keyword argument 'progress' may be provided\n        to track the loading of many molecules.\n\n        Args:\n            filename (str): the path of the SDF file to read.\n\n        Returns:\n            Molecule: a new `Molecule` or list of :obj:`Molecule` objects\n            from the provided SDF file.\n        \"\"\"\n\n        from chmpy.fmt.sdf import parse_sdf_file\n\n        sdf_data = parse_sdf_file(filename, **kwargs)\n        progress = kwargs.get(\"progress\", False)\n\n        def update(x):\n            return None\n\n        if progress:\n            from tqdm import tqdm\n\n            pbar = tqdm(\n                desc=\"Creating molecule objects\", total=len(sdf_data), leave=False\n            )\n            update = pbar.update\n\n        molecules = []\n        for d in sdf_data:\n            molecules.append(cls.from_sdf_dict(d, **kwargs))\n            update(1)\n\n        if progress:\n            pbar.close()\n\n        if len(molecules) == 1:\n            return molecules[0]\n        return molecules\n\n    @classmethod\n    def from_pdb_file(cls, filename, **kwargs):\n        from chmpy.fmt.pdb import Pdb\n\n        p = Pdb.from_file(filename)\n        xyz = np.c_[p.data[\"x\"], p.data[\"y\"], p.data[\"z\"]]\n        elements = [Element[x] for x in p.data[\"element\"]]\n        return cls(elements, xyz)\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.asym_symops","title":"<code>asym_symops</code>  <code>property</code>","text":"<p>the symmetry operations which generate this molecule</p>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.atomic_numbers","title":"<code>atomic_numbers</code>  <code>property</code>","text":"<p>Atomic numbers for each atom in this molecule</p>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.bbox_corners","title":"<code>bbox_corners</code>  <code>property</code>","text":"<p>the lower, upper corners of a axis-aligned bounding box for this molecule</p>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.bbox_size","title":"<code>bbox_size</code>  <code>property</code>","text":"<p>the dimensions of the axis-aligned bounding box for this molecule</p>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.center_of_mass","title":"<code>center_of_mass</code>  <code>property</code>","text":"<p>Mean cartesian position of atoms in this molecule, weighted by atomic mass</p>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.centroid","title":"<code>centroid</code>  <code>property</code>","text":"<p>Mean cartesian position of atoms in this molecule</p>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.coordination_numbers","title":"<code>coordination_numbers</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>The coordination numbers associated with atoms in this molecule. If <code>self._coordination_numbers</code> is not set, the coordination numbers will be calculated based on the EEQ method.</p>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.distance_matrix","title":"<code>distance_matrix</code>  <code>property</code>","text":"<p>The (dense) pairwise distance matrix for this molecule</p>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.molecular_formula","title":"<code>molecular_formula</code>  <code>property</code>","text":"<p>string of the molecular formula for this molecule</p>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.name","title":"<code>name</code>  <code>property</code>","text":"<p>The name of this molecule, checks 'GENERIC_NAME' and 'name'</p>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.partial_charges","title":"<code>partial_charges</code>  <code>deletable</code> <code>property</code> <code>writable</code>","text":"<p>The partial charges associated with atoms in this molecule. If <code>self._partial_charges</code> is not set, the charges will be calculated based on the requested method (default: EEM).</p> <p>The available methods are: - 'eem': Electronegativity Equalization Method (default) - 'eeq': Electronegativity Equilibration Charge model</p> <p>To specify a method, set the 'charge_method' property on the molecule: molecule.properties['charge_method'] = 'eeq'</p>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.unique_bonds","title":"<code>unique_bonds</code>  <code>property</code>","text":"<p>The unique bonds for this molecule. If bonds are not assigned, this will <code>None</code></p>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.__init__","title":"<code>__init__(elements, positions, bonds=None, labels=None, **kwargs)</code>","text":"<p>Initialize a new molecule.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>List[Element]</code> <p>N length list of elements associated with the sites</p> required <code>positions</code> <code>array_like</code> <p>(N, 3) array of site positions in Cartesian coordinates</p> required <code>bonds</code> <code>dok_matrix</code> <p>if bonds are already calculated provide them here</p> <code>None</code> <code>labels</code> <code>array_like</code> <p>labels (array_like): N length array of string labels for each site</p> <code>None</code> <code>**kwargs</code> <p>Additional properties (will populate the properties member) to store in this molecule</p> <code>{}</code> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def __init__(self, elements, positions, bonds=None, labels=None, **kwargs):\n    \"\"\"\n    Initialize a new molecule.\n\n    Arguments:\n        elements (List[Element]): N length list of elements associated with\n            the sites\n        positions (array_like): (N, 3) array of site positions in Cartesian\n            coordinates\n        bonds (dok_matrix, optional): if bonds are already calculated provide\n            them here\n        labels (array_like, optional): labels (array_like): N length array of\n            string labels for each site\n        **kwargs: Additional properties (will populate the properties member)\n            to store in this molecule\n    \"\"\"\n    self.positions = positions\n    self.elements = elements\n    self.properties = {}\n    self.properties.update(kwargs)\n    self.bonds = None\n\n    self.charge = kwargs.get(\"charge\", 0)\n    self.multiplicity = kwargs.get(\"multiplicity\", 1)\n\n    if bonds is None:\n        if kwargs.get(\"guess_bonds\", False):\n            self.guess_bonds()\n    else:\n        self.bonds = dok_matrix(bonds)\n\n    if labels is None:\n        self.assign_default_labels()\n    else:\n        self.labels = labels\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.assign_default_labels","title":"<code>assign_default_labels()</code>","text":"<p>Assign the default labels to atom sites in this molecule</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def assign_default_labels(self):\n    \"Assign the default labels to atom sites in this molecule\"\n    \"(number them by element)\"\n    counts = defaultdict(int)\n    labels = []\n    for el, _ in self:\n        counts[el] += 1\n        labels.append(f\"{el.symbol}{counts[el]}\")\n    self.labels = np.asarray(labels)\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.atomic_shape_descriptors","title":"<code>atomic_shape_descriptors(l_max=5, radius=6.0, background=1e-05)</code>","text":"<p>Calculate the shape descriptors<code>[1,2]</code> for all atoms in this isolated molecule. If you wish to use the crystal environment please see the corresponding method in :obj:<code>chmpy.crystal.Crystal</code>.</p> <p>Parameters:</p> Name Type Description Default <code>l_max</code> <code>int</code> <p>maximum level of angular momenta to include in the spherical harmonic transform of the shape function. (default=5)</p> <code>5</code> <code>radius</code> <code>float</code> <p>Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms (default=6.0)</p> <code>6.0</code> <code>background</code> <code>float</code> <p>'background' density to ensure closed surfaces for isolated atoms (default=1e-5)</p> <code>1e-05</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>shape description vector</p> References <p>[1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)     https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)     https://dx.doi.org/10.1002/anie.201906602</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def atomic_shape_descriptors(\n    self, l_max=5, radius=6.0, background=1e-5\n) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the shape descriptors`[1,2]` for all\n    atoms in this isolated molecule. If you wish to use\n    the crystal environment please see the corresponding method\n    in :obj:`chmpy.crystal.Crystal`.\n\n    Args:\n        l_max (int, optional): maximum level of angular momenta to include\n            in the spherical harmonic transform of the shape function. (default=5)\n        radius (float, optional): Maximum distance in Angstroms between\n            any atom in the molecule and the resulting neighbouring\n            atoms (default=6.0)\n        background (float, optional): 'background' density to ensure closed\n            surfaces for isolated atoms (default=1e-5)\n\n    Returns:\n        shape description vector\n\n    References:\n        [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n            https://dx.doi.org/10.1038/srep22204\n        [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n            https://dx.doi.org/10.1002/anie.201906602\n    \"\"\"\n    descriptors = []\n    from chmpy.shape import SHT, stockholder_weight_descriptor\n\n    sph = SHT(l_max)\n    elements = self.atomic_numbers\n    positions = self.positions\n    dists = self.distance_matrix\n\n    for n in range(elements.shape[0]):\n        els = elements[n : n + 1]\n        pos = positions[n : n + 1, :]\n        idxs = np.where((dists[n, :] &lt; radius) &amp; (dists[n, :] &gt; 1e-3))[0]\n        neighbour_els = elements[idxs]\n        neighbour_pos = positions[idxs]\n        ubound = Element[n].vdw_radius * 3\n        descriptors.append(\n            stockholder_weight_descriptor(\n                sph,\n                els,\n                pos,\n                neighbour_els,\n                neighbour_pos,\n                bounds=(0.2, ubound),\n                background=background,\n            )\n        )\n    return np.asarray(descriptors)\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.atomic_stockholder_weight_isosurfaces","title":"<code>atomic_stockholder_weight_isosurfaces(**kwargs)</code>","text":"<p>Calculate the stockholder weight isosurfaces for the atoms in this molecule, with the provided background density.</p> <p>Other Parameters:</p> Name Type Description <code>background</code> <p>float, optional 'background' density to ensure closed surfaces for isolated atoms (default=1e-5)</p> <code>isovalue</code> <p>float, optional level set value for the isosurface (default=0.5). Must be between 0 and 1, but values other than 0.5 probably won't make sense anyway.</p> <code>separation</code> <p>float, optional separation between density grid used in the surface calculation (default 0.2) in Angstroms.</p> <code>radius</code> <p>float, optional maximum distance for contributing neighbours for the stockholder weight calculation</p> <code>color</code> <p>str, optional surface property to use for vertex coloring, one of ('d_norm_i', 'd_i', 'd_norm_e', 'd_e', 'd_norm')</p> <code>colormap</code> <p>str, optional matplotlib colormap to use for surface coloring (default 'viridis_r')</p> <code>midpoint</code> <p>float, optional, default 0.0 if using d_norm use the midpoint norm (as is used in CrystalExplorer)</p> <p>Returns:</p> Type Description <p>List[trimesh.Trimesh]: A list of meshes representing the stockholder weight isosurfaces</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def atomic_stockholder_weight_isosurfaces(self, **kwargs):\n    \"\"\"\n    Calculate the stockholder weight isosurfaces for the atoms\n    in this molecule, with the provided background density.\n\n    Keyword Args:\n        background: float, optional\n            'background' density to ensure closed surfaces for isolated atoms\n            (default=1e-5)\n        isovalue: float, optional\n            level set value for the isosurface (default=0.5). Must be between\n            0 and 1, but values other than 0.5 probably won't make sense anyway.\n        separation: float, optional\n            separation between density grid used in the surface calculation\n            (default 0.2) in Angstroms.\n        radius: float, optional\n            maximum distance for contributing neighbours for the stockholder\n            weight calculation\n        color: str, optional\n            surface property to use for vertex coloring, one of ('d_norm_i',\n            'd_i', 'd_norm_e', 'd_e', 'd_norm')\n        colormap: str, optional\n            matplotlib colormap to use for surface coloring (default 'viridis_r')\n        midpoint: float, optional, default 0.0 if using d_norm\n            use the midpoint norm (as is used in CrystalExplorer)\n\n    Returns:\n        List[trimesh.Trimesh]: A list of meshes representing the stockholder\n            weight isosurfaces\n    \"\"\"\n\n    import trimesh\n    from matplotlib.cm import get_cmap\n\n    from chmpy import StockholderWeight\n    from chmpy.surface import stockholder_weight_isosurface\n    from chmpy.util.color import DEFAULT_COLORMAPS\n\n    sep = kwargs.get(\"separation\", kwargs.get(\"resolution\", 0.2))\n    radius = kwargs.get(\"radius\", 12.0)\n    background = kwargs.get(\"background\", 1e-5)\n    vertex_color = kwargs.get(\"color\", \"d_norm_i\")\n    isovalue = kwargs.get(\"isovalue\", 0.5)\n    midpoint = kwargs.get(\"midpoint\", 0.0 if vertex_color == \"d_norm\" else None)\n    meshes = []\n    colormap = get_cmap(\n        kwargs.get(\"colormap\", DEFAULT_COLORMAPS.get(vertex_color, \"viridis_r\"))\n    )\n    isos = []\n    elements = self.atomic_numbers\n    positions = self.positions\n    dists = self.distance_matrix\n\n    for n in range(elements.shape[0]):\n        els = elements[n : n + 1]\n        pos = positions[n : n + 1, :]\n        idxs = np.where((dists[n, :] &lt; radius) &amp; (dists[n, :] &gt; 1e-3))[0]\n        neighbour_els = elements[idxs]\n        neighbour_pos = positions[idxs]\n\n        s = StockholderWeight.from_arrays(\n            els, pos, neighbour_els, neighbour_pos, background=background\n        )\n        iso = stockholder_weight_isosurface(s, isovalue=isovalue, sep=sep)\n        isos.append(iso)\n    for iso in isos:\n        prop = iso.vertex_prop[vertex_color]\n        norm = None\n        if midpoint is not None:\n            from matplotlib.colors import DivergingNorm\n\n            norm = DivergingNorm(vmin=prop.min(), vcenter=midpoint, vmax=prop.max())\n            prop = norm(prop)\n        color = colormap(prop)\n        mesh = trimesh.Trimesh(\n            vertices=iso.vertices,\n            faces=iso.faces,\n            normals=iso.normals,\n            vertex_colors=color,\n        )\n        meshes.append(mesh)\n    return meshes\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.bond_graph","title":"<code>bond_graph()</code>","text":"<p>Calculate the <code>graph_tool.Graph</code> object corresponding to this molecule. Requires the graph_tool library to be installed</p> <p>Returns:</p> Type Description <p>graph_tool.Graph: the (undirected) graph of this molecule</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def bond_graph(self):\n    \"\"\"\n    Calculate the `graph_tool.Graph` object corresponding\n    to this molecule. Requires the graph_tool library to be\n    installed\n\n    Returns:\n        graph_tool.Graph: the (undirected) graph of this molecule\n    \"\"\"\n\n    if hasattr(self, \"_bond_graph\"):\n        return self._bond_graph\n    try:\n        import graph_tool as gt\n    except ImportError as e:\n        raise RuntimeError(\n            \"Please install the graph_tool library for graph operations\"\n        ) from e\n    if self.bonds is None:\n        self.guess_bonds()\n    g = gt.Graph(directed=False)\n    v_el = g.new_vertex_property(\"int\")\n    g.add_edge_list(self.bonds.keys())\n    e_w = g.new_edge_property(\"float\")\n    v_el.a[:] = self.atomic_numbers\n    g.vertex_properties[\"element\"] = v_el\n    e_w.a[:] = list(self.bonds.values())\n    g.edge_properties[\"bond_distance\"] = e_w\n    self._bond_graph = g\n    return g\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.connected_fragments","title":"<code>connected_fragments()</code>","text":"<p>Separate this molecule into fragments/molecules based on covalent bonding criteria.</p> <p>Returns:</p> Type Description <code>list</code> <p>a list of connected <code>Molecule</code> objects</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def connected_fragments(self) -&gt; list:\n    \"\"\"\n    Separate this molecule into fragments/molecules based\n    on covalent bonding criteria.\n\n    Returns:\n        a list of connected `Molecule` objects\n    \"\"\"\n    from scipy.sparse.csgraph import connected_components\n\n    from chmpy.util.num import cartesian_product\n\n    if self.bonds is None:\n        self.guess_bonds()\n\n    nfrag, labels = connected_components(self.bonds)\n    molecules = []\n    for frag in range(nfrag):\n        atoms = np.where(labels == frag)[0]\n        na = len(atoms)\n        sqidx = cartesian_product(atoms, atoms)\n        molecules.append(\n            Molecule(\n                [self.elements[i] for i in atoms],\n                self.positions[atoms],\n                labels=self.labels[atoms],\n                bonds=self.bonds[sqidx[:, 0], sqidx[:, 1]].reshape(na, na),\n            )\n        )\n    return molecules\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.distance_to","title":"<code>distance_to(other, method='centroid')</code>","text":"<p>Calculate the euclidean distance between this molecule and another. May use the distance between centres-of-mass, centroids, or nearest atoms.</p> <p>Parameters     other (Molecule): the molecule to calculate distance to     method (str, optional): one of 'centroid', 'center_of_mass', 'nearest_atom'</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def distance_to(self, other, method=\"centroid\"):\n    \"\"\"\n    Calculate the euclidean distance between this\n    molecule and another. May use the distance between\n    centres-of-mass, centroids, or nearest atoms.\n\n    Parameters\n        other (Molecule): the molecule to calculate distance to\n        method (str, optional): one of 'centroid', 'center_of_mass', 'nearest_atom'\n    \"\"\"\n    method = method.lower()\n    if method == \"centroid\":\n        return np.linalg.norm(self.centroid - other.centroid)\n    elif method == \"center_of_mass\":\n        return np.linalg.norm(self.center_of_mass - other.center_of_mass)\n    elif method == \"nearest_atom\":\n        return np.min(cdist(self.positions, other.positions))\n    else:\n        raise ValueError(f\"Unknown method={method}\")\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.electrostatic_potential","title":"<code>electrostatic_potential(positions)</code>","text":"<p>Calculate the electrostatic potential based on the partial charges associated with this molecule. The potential will be in atomic units.</p> <p>Parameters:</p> Name Type Description Default <code>positions</code> <code>ndarray</code> <p>(N, 3) array of locations where the molecular ESP should be calculated. Assumed to be in Angstroms.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: (N,) array of electrostatic potential values (atomic units)</p> <code>ndarray</code> <p>at the given positions.</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def electrostatic_potential(self, positions) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the electrostatic potential based on the partial\n    charges associated with this molecule. The potential will be\n    in atomic units.\n\n    Args:\n        positions (np.ndarray): (N, 3) array of locations where the\n            molecular ESP should be calculated. Assumed to be in Angstroms.\n\n    Returns:\n        np.ndarray: (N,) array of electrostatic potential values (atomic units)\n        at the given positions.\n    \"\"\"\n    if \"esp_cube\" in self.properties:\n        return self.electrostatic_potential_from_cube(\n            self.properties[\"esp_cube\"], positions\n        )\n\n    from chmpy.util.unit import BOHR_TO_ANGSTROM\n\n    v_pot = np.zeros(positions.shape[0])\n    for charge, position in zip(self.partial_charges, self.positions, strict=False):\n        if charge == 0.0:\n            continue\n        r = np.linalg.norm(positions - position[np.newaxis, :], axis=1)\n        v_pot += BOHR_TO_ANGSTROM * charge / r\n    return v_pot\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.from_arrays","title":"<code>from_arrays(elements, positions, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a molecule from the provided arrays. kwargs will be passed through to the Molecule constructor.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>ndarray</code> <p>(N,) array of atomic numbers for each atom in this molecule</p> required <code>positions</code> <code>ndarray</code> <p>(N, 3) array of Cartesian coordinates for each atom in this molecule (Angstroms)</p> required <p>Returns:</p> Name Type Description <code>Molecule</code> <p>a new molecule object</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>@classmethod\ndef from_arrays(cls, elements, positions, **kwargs):\n    \"\"\"\n    Construct a molecule from the provided arrays. kwargs\n    will be passed through to the Molecule constructor.\n\n    Args:\n        elements (np.ndarray): (N,) array of atomic numbers for each\n            atom in this molecule\n        positions (np.ndarray): (N, 3) array of Cartesian coordinates\n            for each atom in this molecule (Angstroms)\n\n    Returns:\n        Molecule: a new molecule object\n    \"\"\"\n    return cls([Element[x] for x in elements], np.array(positions), **kwargs)\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.from_sdf_dict","title":"<code>from_sdf_dict(sdf_dict, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a molecule from the provided dictionary of sdf terms. Not intended for typical use cases, but as a helper method for <code>Molecule.from_sdf_file</code></p> <p>Parameters:</p> Name Type Description Default <code>sdf_dict</code> <code>dict</code> <p>a dictionary containing the 'atoms', 'x', 'y', 'z', 'symbol', 'bonds' members.</p> required <p>Returns:</p> Name Type Description <code>Molecule</code> <code>Molecule</code> <p>a new <code>Molecule</code> from the provided data</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>@classmethod\ndef from_sdf_dict(cls, sdf_dict, **kwargs) -&gt; \"Molecule\":\n    \"\"\"\n    Construct a molecule from the provided dictionary of\n    sdf terms. Not intended for typical use cases, but as a\n    helper method for `Molecule.from_sdf_file`\n\n    Args:\n        sdf_dict (dict): a dictionary containing the 'atoms', 'x', 'y', 'z',\n            'symbol', 'bonds' members.\n\n    Returns:\n        Molecule: a new `Molecule` from the provided data\n    \"\"\"\n    atoms = sdf_dict[\"atoms\"]\n    positions = np.c_[atoms[\"x\"], atoms[\"y\"], atoms[\"z\"]]\n    elements = [Element[x] for x in atoms[\"symbol\"]]\n    # TODO use bonds from SDF\n    # bonds = sdf_dict[\"bonds\"]\n    m = cls(elements, positions, **sdf_dict[\"data\"])\n    if \"sdf\" in sdf_dict:\n        m.properties[\"sdf\"] = sdf_dict[\"sdf\"]\n    return m\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.from_sdf_file","title":"<code>from_sdf_file(filename, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a molecule from the provided SDF file. Because an SDF file can have multiple molecules, an optional keyword argument 'progress' may be provided to track the loading of many molecules.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the path of the SDF file to read.</p> required <p>Returns:</p> Name Type Description <code>Molecule</code> <p>a new <code>Molecule</code> or list of :obj:<code>Molecule</code> objects</p> <p>from the provided SDF file.</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>@classmethod\ndef from_sdf_file(cls, filename, **kwargs):\n    \"\"\"\n    Construct a molecule from the provided SDF file.\n    Because an SDF file can have multiple molecules,\n    an optional keyword argument 'progress' may be provided\n    to track the loading of many molecules.\n\n    Args:\n        filename (str): the path of the SDF file to read.\n\n    Returns:\n        Molecule: a new `Molecule` or list of :obj:`Molecule` objects\n        from the provided SDF file.\n    \"\"\"\n\n    from chmpy.fmt.sdf import parse_sdf_file\n\n    sdf_data = parse_sdf_file(filename, **kwargs)\n    progress = kwargs.get(\"progress\", False)\n\n    def update(x):\n        return None\n\n    if progress:\n        from tqdm import tqdm\n\n        pbar = tqdm(\n            desc=\"Creating molecule objects\", total=len(sdf_data), leave=False\n        )\n        update = pbar.update\n\n    molecules = []\n    for d in sdf_data:\n        molecules.append(cls.from_sdf_dict(d, **kwargs))\n        update(1)\n\n    if progress:\n        pbar.close()\n\n    if len(molecules) == 1:\n        return molecules[0]\n    return molecules\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.from_turbomole_file","title":"<code>from_turbomole_file(filename, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a molecule from the provided turbomole file. kwargs will be passed through to the Molecule constructor.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the path to the .xyz file</p> required <code>kwargs</code> <p>keyword arguments passed ot the <code>Molecule</code> constructor</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Molecule</code> <p>A new <code>Molecule</code> object</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>@classmethod\ndef from_turbomole_file(cls, filename, **kwargs):\n    \"\"\"\n    Construct a molecule from the provided turbomole file. kwargs\n    will be passed through to the Molecule constructor.\n\n    Args:\n        filename (str): the path to the .xyz file\n        kwargs: keyword arguments passed ot the `Molecule` constructor\n\n    Returns:\n        Molecule: A new `Molecule` object\n    \"\"\"\n    return cls.from_turbomole_string(Path(filename).read_text(), **kwargs)\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.from_turbomole_string","title":"<code>from_turbomole_string(contents, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a molecule from the provided turbomole file contents. kwargs will be passed through to the Molecule constructor.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>str</code> <p>the contents of the .xyz file to read</p> required <code>kwargs</code> <p>keyword arguments passed ot the <code>Molecule</code> constructor</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Molecule</code> <p>A new <code>Molecule</code> object</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>@classmethod\ndef from_turbomole_string(cls, contents, **kwargs):\n    \"\"\"\n    Construct a molecule from the provided turbomole file contents. kwargs\n    will be passed through to the Molecule constructor.\n\n    Args:\n        contents (str): the contents of the .xyz file to read\n        kwargs: keyword arguments passed ot the `Molecule` constructor\n\n    Returns:\n        Molecule: A new `Molecule` object\n    \"\"\"\n    from chmpy.fmt.tmol import parse_tmol_string\n\n    elements, positions = parse_tmol_string(contents)\n    return cls(elements, np.asarray(positions), **kwargs)\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.from_xyz_file","title":"<code>from_xyz_file(filename, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a molecule from the provided xmol .xyz file. kwargs will be passed through to the Molecule constructor.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the path to the .xyz file</p> required <code>kwargs</code> <p>keyword arguments passed ot the <code>Molecule</code> constructor</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Molecule</code> <p>A new <code>Molecule</code> object</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>@classmethod\ndef from_xyz_file(cls, filename, **kwargs):\n    \"\"\"\n    Construct a molecule from the provided xmol .xyz file. kwargs\n    will be passed through to the Molecule constructor.\n\n    Args:\n        filename (str): the path to the .xyz file\n        kwargs: keyword arguments passed ot the `Molecule` constructor\n\n    Returns:\n        Molecule: A new `Molecule` object\n    \"\"\"\n\n    return cls.from_xyz_string(Path(filename).read_text(), **kwargs)\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.from_xyz_string","title":"<code>from_xyz_string(contents, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a molecule from the provided xmol .xyz file. kwargs will be passed through to the Molecule constructor.</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>str</code> <p>the contents of the .xyz file to read</p> required <code>kwargs</code> <p>keyword arguments passed ot the <code>Molecule</code> constructor</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Molecule</code> <p>A new <code>Molecule</code> object</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>@classmethod\ndef from_xyz_string(cls, contents, **kwargs):\n    \"\"\"\n    Construct a molecule from the provided xmol .xyz file. kwargs\n    will be passed through to the Molecule constructor.\n\n    Args:\n        contents (str): the contents of the .xyz file to read\n        kwargs: keyword arguments passed ot the `Molecule` constructor\n\n    Returns:\n        Molecule: A new `Molecule` object\n    \"\"\"\n    from chmpy.fmt.xyz_file import parse_xyz_string\n\n    elements, positions = parse_xyz_string(contents)\n    return cls(elements, np.asarray(positions), **kwargs)\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.functional_groups","title":"<code>functional_groups(kind=None)</code>","text":"<p>Find all indices of atom groups which constitute subgraph isomorphisms with stored functional group data</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>str</code> <p>Find only matches of the given kind</p> <code>None</code> <p>Returns:</p> Type Description <code>dict | list</code> <p>Either a dict with keys as functional group type and values as list of</p> <code>dict | list</code> <p>lists of indices, or a list of lists of indices if kind is specified.</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def functional_groups(self, kind=None) -&gt; dict | list:\n    \"\"\"\n    Find all indices of atom groups which constitute\n    subgraph isomorphisms with stored functional group data\n\n    Args:\n        kind (str, optional):Find only matches of the given kind\n\n    Returns:\n        Either a dict with keys as functional group type and values as list of\n        lists of indices, or a list of lists of indices if kind is specified.\n    \"\"\"\n    global _FUNCTIONAL_GROUP_SUBGRAPHS\n    try:\n        import graph_tool.topology as top  # noqa: F401\n    except ImportError as e:\n        raise RuntimeError(\n            \"Please install the graph_tool library for graph operations\"\n        ) from e\n\n    if not _FUNCTIONAL_GROUP_SUBGRAPHS:\n        from chmpy.subgraphs import load_data\n\n        _FUNCTIONAL_GROUP_SUBGRAPHS = load_data()\n\n    if kind is not None:\n        sub = _FUNCTIONAL_GROUP_SUBGRAPHS[kind]\n        matches = self.matching_subgraph(sub)\n        if kind == \"ring\":\n            matches = list({tuple(sorted(x)) for x in matches})\n        return matches\n\n    matches = {}\n    for n, sub in _FUNCTIONAL_GROUP_SUBGRAPHS.items():\n        m = self.matching_subgraph(sub)\n        if n == \"ring\":\n            m = list({tuple(sorted(x)) for x in m})\n        matches[n] = m\n    return matches\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.guess_bonds","title":"<code>guess_bonds(tolerance=0.4)</code>","text":"<p>Use geometric distances and covalent radii to determine bonding information for this molecule.</p> <p>Bonding is determined by the distance between sites being closer than the sum of covalent radii + <code>tolerance</code></p> <p>Will set the <code>bonds</code> member.</p> <p>If the <code>graph_tool</code> library is available, this will call the <code>bond_graph</code> method to populate the connectivity graph.</p> <p>Parameters:</p> Name Type Description Default <code>tolerance</code> <code>float</code> <p>Additional tolerance for attributing two sites as 'bonded'. The default is 0.4 angstroms, which is recommended by the CCDC</p> <code>0.4</code> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def guess_bonds(self, tolerance=0.40):\n    \"\"\"\n    Use geometric distances and covalent radii\n    to determine bonding information for this molecule.\n\n    Bonding is determined by the distance between\n    sites being closer than the sum of covalent radii + `tolerance`\n\n    Will set the `bonds` member.\n\n    If the `graph_tool` library is available, this will call the\n    `bond_graph` method to populate the connectivity graph.\n\n\n    Args:\n        tolerance (float, optional): Additional tolerance for attributing\n            two sites as 'bonded'.\n            The default is 0.4 angstroms, which is recommended by the CCDC\n    \"\"\"\n    tree = KDTree(self.positions)\n    covalent_radii = np.array([x.cov for x in self.elements])\n    max_cov = np.max(covalent_radii)\n    thresholds = (\n        covalent_radii[:, np.newaxis] + covalent_radii[np.newaxis, :] + tolerance\n    )\n    max_distance = max_cov * 2 + tolerance\n    dist = tree.sparse_distance_matrix(tree, max_distance=max_distance).toarray()\n    mask = (dist &gt; 0) &amp; (dist &lt; thresholds)\n    self.bonds = np.zeros(dist.shape)\n    self.bonds[mask] = dist[mask]\n    self.bonds = dok_matrix(self.bonds)\n    try:\n        self.bond_graph()\n    except Exception:\n        pass\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.load","title":"<code>load(filename, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a molecule from the provided file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the path to the (xyz or SDF) file</p> required <code>kwargs</code> <p>keyword arguments passed ot the <code>Molecule</code> constructor</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Molecule</code> <p>A new <code>Molecule</code> object</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>@classmethod\ndef load(cls, filename, **kwargs):\n    \"\"\"\n    Construct a molecule from the provided file.\n\n    Args:\n        filename (str): the path to the (xyz or SDF) file\n        kwargs: keyword arguments passed ot the `Molecule` constructor\n\n    Returns:\n        Molecule: A new `Molecule` object\n    \"\"\"\n    fpath = Path(filename)\n    n = fpath.name\n    fname_map = cls._fname_load_map()\n    if n in fname_map:\n        return fname_map[n](filename)\n    extension_map = cls._ext_load_map()\n    extension = kwargs.pop(\"fmt\", fpath.suffix.lower())\n    if not extension.startswith(\".\"):\n        extension = \".\" + extension\n    return extension_map[extension](filename, **kwargs)\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.mask","title":"<code>mask(mask, **kwargs)</code>","text":"<p>Convenience method to construct a new molecule from this molecule with the given mask array.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>a numpy mask array used to filter which atoms to keep in the new molecule.</p> required <p>Returns:</p> Name Type Description <code>Molecule</code> <p>a new <code>Molecule</code>, with atoms filtered by the mask.</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def mask(self, mask, **kwargs):\n    \"\"\"\n    Convenience method to construct a new molecule from this molecule\n    with the given mask array.\n\n    Args:\n        mask (np.ndarray): a numpy mask array used to filter which\n            atoms to keep in the new molecule.\n\n    Returns:\n        Molecule: a new `Molecule`, with atoms filtered by the mask.\n    \"\"\"\n    return Molecule.from_arrays(\n        self.atomic_numbers[mask], self.positions[mask], **kwargs\n    )\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.matching_fragments","title":"<code>matching_fragments(fragment, method='connectivity')</code>","text":"<p>Find the indices of a matching fragment to the given molecular fragment</p> <p>Parameters:</p> Name Type Description Default <code>fragment</code> <code>Molecule</code> <p>Molecule object containing the desired fragment</p> required <code>method</code> <code>str</code> <p>the method for matching</p> <code>'connectivity'</code> <p>Returns:</p> Type Description <p>List[dict]: List of maps between matching indices in this molecule and those in the fragment</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def matching_fragments(self, fragment, method=\"connectivity\"):\n    \"\"\"\n    Find the indices of a matching fragment to the given\n    molecular fragment\n\n    Args:\n        fragment (Molecule): Molecule object containing the desired fragment\n        method (str, optional): the method for matching\n\n    Returns:\n        List[dict]: List of maps between matching indices in this molecule and those\n            in the fragment\n    \"\"\"\n    try:\n        import graph_tool.topology as top\n    except ImportError as e:\n        raise RuntimeError(\n            \"Please install the graph_tool library for graph operations\"\n        ) from e\n\n    sub = fragment.bond_graph()\n    g = self.bond_graph()\n    matches = top.subgraph_isomorphism(\n        sub,\n        g,\n        vertex_label=(\n            sub.vertex_properties[\"element\"],\n            g.vertex_properties[\"element\"],\n        ),\n    )\n    return [list(x.a) for x in matches]\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.matching_subgraph","title":"<code>matching_subgraph(sub)</code>","text":"<p>Find all indices of atoms which match the given graph.</p> <p>Parameters:</p> Name Type Description Default <code>sub</code> <code>Graph</code> <p>the subgraph</p> required <p>Returns:</p> Name Type Description <code>List</code> <p>list of lists of atomic indices matching the atoms in sub to those in this molecule</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def matching_subgraph(self, sub):\n    \"\"\"Find all indices of atoms which match the given graph.\n\n    Args:\n        sub (graph_tool.Graph): the subgraph\n\n    Returns:\n        List: list of lists of atomic indices matching the atoms in sub\n            to those in this molecule\n    \"\"\"\n\n    try:\n        import graph_tool.topology as top\n    except ImportError as e:\n        raise RuntimeError(\n            \"Please install the graph_tool library for graph operations\"\n        ) from e\n\n    g = self.bond_graph()\n    matches = top.subgraph_isomorphism(\n        sub,\n        g,\n        vertex_label=(\n            sub.vertex_properties[\"element\"],\n            g.vertex_properties[\"element\"],\n        ),\n    )\n    return [tuple(x.a) for x in matches]\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.promolecule_density_isosurface","title":"<code>promolecule_density_isosurface(**kwargs)</code>","text":"<p>Calculate promolecule electron density isosurface for this molecule.</p> <p>Other Parameters:</p> Name Type Description <code>isovalue</code> <p>float, optional level set value for the isosurface (default=0.002) in au.</p> <code>separation</code> <p>float, optional separation between density grid used in the surface calculation (default 0.2) in Angstroms.</p> <code>color</code> <p>str, optional surface property to use for vertex coloring, one of ('d_norm_i', 'd_i', 'd_norm_e', 'd_e')</p> <code>colormap</code> <p>str, optional matplotlib colormap to use for surface coloring (default 'viridis_r')</p> <code>midpoint</code> <p>float, optional, default 0.0 if using d_norm use the midpoint norm (as is used in CrystalExplorer)</p> <p>Returns:</p> Type Description <p>trimesh.Trimesh: A mesh representing the promolecule density isosurface</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def promolecule_density_isosurface(self, **kwargs):\n    \"\"\"\n    Calculate promolecule electron density isosurface\n    for this molecule.\n\n    Keyword Args:\n        isovalue: float, optional\n            level set value for the isosurface (default=0.002) in au.\n        separation: float, optional\n            separation between density grid used in the surface calculation\n            (default 0.2) in Angstroms.\n        color: str, optional\n            surface property to use for vertex coloring, one of ('d_norm_i',\n            'd_i', 'd_norm_e', 'd_e')\n        colormap: str, optional\n            matplotlib colormap to use for surface coloring (default 'viridis_r')\n        midpoint: float, optional, default 0.0 if using d_norm\n            use the midpoint norm (as is used in CrystalExplorer)\n\n    Returns:\n        trimesh.Trimesh: A mesh representing the promolecule density isosurface\n    \"\"\"\n    import trimesh\n\n    from chmpy import PromoleculeDensity\n    from chmpy.surface import promolecule_density_isosurface\n    from chmpy.util.color import property_to_color\n\n    isovalue = kwargs.get(\"isovalue\", 0.002)\n    sep = kwargs.get(\"separation\", kwargs.get(\"resolution\", 0.2))\n    vertex_color = kwargs.get(\"color\", \"d_norm_i\")\n    extra_props = {}\n    pro = PromoleculeDensity((self.atomic_numbers, self.positions))\n    if vertex_color == \"esp\":\n        extra_props[\"esp\"] = self.electrostatic_potential\n    iso = promolecule_density_isosurface(\n        pro, sep=sep, isovalue=isovalue, extra_props=extra_props\n    )\n    prop = iso.vertex_prop[vertex_color]\n    color = property_to_color(prop, cmap=kwargs.get(\"cmap\", vertex_color))\n    mesh = trimesh.Trimesh(\n        vertices=iso.vertices,\n        faces=iso.faces,\n        normals=iso.normals,\n        vertex_colors=color,\n    )\n    return mesh\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.rotate","title":"<code>rotate(rotation, origin=(0, 0, 0))</code>","text":"<p>Convenience method to rotate this molecule by a given rotation matrix</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray</code> <p>A (3, 3) rotation matrix</p> required Source code in <code>chmpy/core/molecule.py</code> <pre><code>def rotate(self, rotation, origin=(0, 0, 0)):\n    \"\"\"\n    Convenience method to rotate this molecule by a given\n    rotation matrix\n\n    Args:\n        rotation (np.ndarray): A (3, 3) rotation matrix\n    \"\"\"\n\n    if np.allclose(origin, (0, 0, 0)):\n        np.dot(self.positions, rotation, out=self.positions)\n    else:\n        self.positions -= origin\n        np.dot(self.positions, rotation, out=self.positions)\n        self.positions += origin\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.rotated","title":"<code>rotated(rotation, origin=(0, 0, 0))</code>","text":"<p>Convenience method to construct a new copy of thismolecule rotated by a given rotation matrix</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray</code> <p>A (3, 3) rotation matrix</p> required <p>Returns:</p> Name Type Description <code>Molecule</code> <p>a new copy of this <code>Molecule</code> rotated by the given rotation matrix.</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def rotated(self, rotation, origin=(0, 0, 0)):\n    \"\"\"\n    Convenience method to construct a new copy of thismolecule\n    rotated by a given rotation matrix\n\n    Args:\n        rotation (np.ndarray): A (3, 3) rotation matrix\n\n    Returns:\n        Molecule: a new copy of this `Molecule` rotated by the\n            given rotation matrix.\n    \"\"\"\n    from copy import deepcopy\n\n    result = deepcopy(self)\n    result.rotate(rotation, origin=origin)\n    return result\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.save","title":"<code>save(filename, **kwargs)</code>","text":"<p>Save this molecule to the destination file in xyz format, optionally discarding the typical header.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path to the destination file</p> required <code>kwargs</code> <p>keyword arguments passed to the relevant method</p> <code>{}</code> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def save(self, filename, **kwargs):\n    \"\"\"\n    Save this molecule to the destination file in xyz format,\n    optionally discarding the typical header.\n\n    Args:\n        filename (str): path to the destination file\n        kwargs: keyword arguments passed to the relevant method\n    \"\"\"\n    fpath = Path(filename)\n    n = fpath.name\n    fname_map = self._fname_save_map()\n    if n in fname_map:\n        return fname_map[n](filename, **kwargs)\n    extension_map = self._ext_save_map()\n    extension = kwargs.pop(\"fmt\", fpath.suffix.lower())\n    if not extension.startswith(\".\"):\n        extension = \".\" + extension\n    return extension_map[extension](filename, **kwargs)\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.shape_descriptors","title":"<code>shape_descriptors(l_max=5, **kwargs)</code>","text":"<p>Calculate the molecular shape descriptors<code>[1,2]</code> for this molecule using the promolecule density.</p> <p>Parameters:</p> Name Type Description Default <code>l_max</code> <code>int</code> <p>maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function.</p> <code>5</code> <p>Other Parameters:</p> Name Type Description <code>with_property</code> <code>str</code> <p>describe the combination of the radial shape function and a surface property in the real, imaginary channels of a complex function</p> <code>isovalue</code> <code>float</code> <p>the isovalue for the promolecule density surface (default 0.0002 au)</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>shape description vector</p> References <p>[1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)     https://dx.doi.org/10.1038/srep22204 [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)     https://dx.doi.org/10.1002/anie.201906602</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def shape_descriptors(self, l_max=5, **kwargs) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the molecular shape descriptors`[1,2]` for\n    this molecule using the promolecule density.\n\n    Args:\n        l_max (int, optional): maximum level of angular momenta to include in\n            the spherical harmonic transform of the molecular shape function.\n\n    Keyword Args:\n        with_property (str, optional): describe the combination of the radial\n            shape function and a surface property in the real, imaginary channels\n            of a complex function\n        isovalue (float, optional): the isovalue for the promolecule density\n            surface (default 0.0002 au)\n\n    Returns:\n        shape description vector\n\n    References:\n        [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n            https://dx.doi.org/10.1038/srep22204\n        [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n            https://dx.doi.org/10.1002/anie.201906602\n    \"\"\"\n    from chmpy.shape import SHT, promolecule_density_descriptor\n\n    sph = SHT(l_max)\n    return promolecule_density_descriptor(\n        sph, self.atomic_numbers, self.positions, **kwargs\n    )\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.to_mesh","title":"<code>to_mesh(**kwargs)</code>","text":"<p>Convert this molecule to a mesh of spheres and cylinders, colored by element. The origins of the spheres will be at the corresponding atomic position, and all units will be Angstroms.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>a dictionary of <code>trimesh.Trimesh</code> objects representing this molecule.</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def to_mesh(self, **kwargs):\n    \"\"\"\n    Convert this molecule to a mesh of spheres and\n    cylinders, colored by element. The origins of the spheres\n    will be at the corresponding atomic position, and all units\n    will be Angstroms.\n\n    Returns:\n        dict: a dictionary of `trimesh.Trimesh` objects representing this molecule.\n    \"\"\"\n    from chmpy.util.mesh import molecule_to_meshes\n\n    return molecule_to_meshes(self, **kwargs)\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.to_sdf_file","title":"<code>to_sdf_file(filename, **kwargs)</code>","text":"<p>Represent this molecule as an of an MDL .sdf file. Keyword arguments are passed to <code>self.to_sdf_string</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path in which store this molecule</p> required <code>kwargs</code> <p>Keyword arguments to be passed to <code>self.to_sdf_string</code></p> <code>{}</code> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def to_sdf_file(self, filename, **kwargs):\n    \"\"\"\n    Represent this molecule as an\n    of an MDL .sdf file. Keyword arguments are\n    passed to `self.to_sdf_string`.\n\n    Args:\n        filename (str): The path in which store this molecule\n        kwargs: Keyword arguments to be passed to `self.to_sdf_string`\n    \"\"\"\n    Path(filename).write_text(self.to_sdf_string(**kwargs))\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.to_sdf_string","title":"<code>to_sdf_string()</code>","text":"<p>Represent this molecule as a string in the format of an MDL .sdf file.</p> <p>Returns:</p> Type Description <code>str</code> <p>contents (str) the contents of the .sdf file</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def to_sdf_string(self) -&gt; str:\n    \"\"\"\n    Represent this molecule as a string in the format\n    of an MDL .sdf file.\n\n    Returns:\n        contents (str) the contents of the .sdf file\n    \"\"\"\n    from chmpy.fmt.sdf import to_sdf_string\n\n    bonds_left = []\n    bonds_right = []\n    if self.bonds is not None:\n        self.guess_bonds()\n        for x, y in self.bonds.keys():\n            bonds_left.append(x + 1)\n            bonds_right.append(y + 1)\n\n    sdf_dict = {\n        \"header\": [self.name, \"created by chmpy\", \"\"],\n        \"atoms\": {\n            \"x\": self.positions[:, 0],\n            \"y\": self.positions[:, 0],\n            \"z\": self.positions[:, 0],\n            \"symbol\": np.array([x.symbol for x in self.elements]),\n        },\n        \"bonds\": {\n            \"left\": np.array(bonds_left),\n            \"right\": np.array(bonds_right),\n        },\n    }\n    return to_sdf_string(sdf_dict)\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.to_xyz_file","title":"<code>to_xyz_file(filename, **kwargs)</code>","text":"<p>Represent this molecule as an of an xmol .xyz file. Keyword arguments are passed to <code>self.to_xyz_string</code>.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path in which store this molecule</p> required <code>kwargs</code> <p>Keyword arguments to be passed to <code>self.to_xyz_string</code></p> <code>{}</code> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def to_xyz_file(self, filename, **kwargs):\n    \"\"\"\n    Represent this molecule as an\n    of an xmol .xyz file. Keyword arguments are\n    passed to `self.to_xyz_string`.\n\n    Args:\n        filename (str): The path in which store this molecule\n        kwargs: Keyword arguments to be passed to `self.to_xyz_string`\n    \"\"\"\n\n    Path(filename).write_text(self.to_xyz_string(**kwargs))\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.to_xyz_string","title":"<code>to_xyz_string(header=True)</code>","text":"<p>Represent this molecule as a string in the format of an xmol .xyz file.</p> <p>Parameters:</p> Name Type Description Default <code>header</code> <code>bool</code> <p>toggle whether or not to return the 'header' of the xyz file i.e. the number of atoms line and the comment line</p> <code>True</code> <p>Returns:</p> Type Description <code>str</code> <p>contents (str) the contents of the .xyz file</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def to_xyz_string(self, header=True) -&gt; str:\n    \"\"\"\n    Represent this molecule as a string in the format\n    of an xmol .xyz file.\n\n    Args:\n        header (bool, optional):toggle whether or not to return the 'header' of the\n            xyz file i.e. the number of atoms line and the comment line\n\n    Returns:\n        contents (str) the contents of the .xyz file\n    \"\"\"\n    if header:\n        lines = [\n            f\"{len(self)}\",\n            self.properties.get(\"comment\", self.molecular_formula),\n        ]\n    else:\n        lines = []\n    for el, (x, y, z) in zip(self.elements, self.positions, strict=False):\n        lines.append(f\"{el} {x: 20.12f} {y: 20.12f} {z: 20.12f}\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.transform","title":"<code>transform(rotation=None, translation=None)</code>","text":"<p>Convenience method to transform this molecule by rotation and translation.</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray</code> <p>A (3,3) rotation matrix</p> <code>None</code> <code>translation</code> <code>ndarray</code> <p>A (3,) vector of x, y, z coordinates of the translation</p> <code>None</code> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def transform(self, rotation=None, translation=None):\n    \"\"\"\n    Convenience method to transform this molecule\n    by rotation and translation.\n\n    Args:\n        rotation (np.ndarray): A (3,3) rotation matrix\n        translation (np.ndarray): A (3,) vector of x, y, z\n            coordinates of the translation\n    \"\"\"\n\n    if rotation is not None:\n        self.rotate(rotation, origin=(0, 0, 0))\n    if translation is not None:\n        self.translate(translation)\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.transformed","title":"<code>transformed(rotation=None, translation=None)</code>","text":"<p>Convenience method to transform this molecule by rotation and translation.</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray</code> <p>A (3,3) rotation matrix</p> <code>None</code> <code>translation</code> <code>ndarray</code> <p>A (3,) vector of x, y, z coordinates of the translation</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Molecule</code> <p>a new copy of this <code>Molecule</code> transformed by the provided matrix and vector.</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def transformed(self, rotation=None, translation=None):\n    \"\"\"\n    Convenience method to transform this molecule\n    by rotation and translation.\n\n    Args:\n        rotation (np.ndarray): A (3,3) rotation matrix\n        translation (np.ndarray): A (3,) vector of x, y, z\n            coordinates of the translation\n\n    Returns:\n        Molecule: a new copy of this `Molecule` transformed by the\n            provided matrix and vector.\n    \"\"\"\n\n    from copy import deepcopy\n\n    result = deepcopy(self)\n    result.transform(rotation=rotation, translation=translation)\n    return result\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.translate","title":"<code>translate(translation)</code>","text":"<p>Convenience method to translate this molecule by a given translation vector</p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>ndarray</code> <p>A (3,) vector of x, y, z coordinates</p> required Source code in <code>chmpy/core/molecule.py</code> <pre><code>def translate(self, translation):\n    \"\"\"\n    Convenience method to translate this molecule by a given\n    translation vector\n\n    Args:\n        translation (np.ndarray): A (3,) vector of x, y, z coordinates\n        of the translation\n    \"\"\"\n    self.positions += translation\n</code></pre>"},{"location":"reference/chmpy/core/molecule/#chmpy.core.molecule.Molecule.translated","title":"<code>translated(translation)</code>","text":"<p>Convenience method to construct a new copy of this molecule translated by a given translation vector</p> <p>Parameters:</p> Name Type Description Default <code>translation</code> <code>ndarray</code> <p>A (3,) vector of x, y, z coordinates of the translation</p> required <p>Returns:</p> Name Type Description <code>Molecule</code> <p>a new copy of this <code>Molecule</code> translated by the given vector.</p> Source code in <code>chmpy/core/molecule.py</code> <pre><code>def translated(self, translation):\n    \"\"\"\n    Convenience method to construct a new copy of this molecule\n    translated by a given translation vector\n\n    Args:\n        translation (np.ndarray): A (3,) vector of x, y, z coordinates\n            of the translation\n\n    Returns:\n        Molecule: a new copy of this `Molecule` translated by the\n            given vector.\n    \"\"\"\n    import copy\n\n    result = copy.deepcopy(self)\n    result.positions += translation\n    return result\n</code></pre>"},{"location":"reference/chmpy/core/wolf/","title":"wolf","text":""},{"location":"reference/chmpy/core/wolf/#chmpy.core.wolf.wolf_sum","title":"<code>wolf_sum(crystal, cutoff=16.0, eta=0.2, charges=None)</code>","text":"<p>Compute the Coulomb interaction via Wolf sum and damped Coulomb potential using point charges.</p> <p>Parameters:</p> Name Type Description Default <code>crystal</code> <code>Crystal</code> <p>the crystal for which to compute the Wolf sum.</p> required <code>cutoff</code> <code>float</code> <p>the cutoff radius (in Angstroms) for which to compute the neighbouring charges (default=16)</p> <code>16.0</code> <code>eta</code> <code>float</code> <p>the eta parameter (1/Angstroms), if unsure just leave this at its default (default=0.2)</p> <code>0.2</code> <code>charges</code> <code>array_like</code> <p>charges of the atoms in the asymmetric unit, if not provided then they will be 'guessed' using the EEM method on the isolated molecules</p> <code>None</code> <code>Returns</code> <p>the total electrostatic energy of the asymmetric unit in the provided crystal (Hartrees)</p> required Source code in <code>chmpy/core/wolf.py</code> <pre><code>def wolf_sum(crystal, cutoff=16.0, eta=0.2, charges=None):\n    \"\"\"\n    Compute the Coulomb interaction via Wolf sum and damped Coulomb potential\n    using point charges.\n\n    Arguments:\n        crystal (Crystal): the crystal for which to compute the Wolf sum.\n        cutoff (float, optional): the cutoff radius (in Angstroms) for\n            which to compute the neighbouring charges (default=16)\n        eta (float, optional): the eta parameter (1/Angstroms), if unsure\n            just leave this at its default (default=0.2)\n        charges (array_like, optional): charges of the atoms in the asymmetric\n            unit, if not provided then they will be 'guessed' using the EEM\n            method on the isolated molecules\n\n        Returns:\n            the total electrostatic energy of the asymmetric unit in the\n            provided crystal (Hartrees)\n    \"\"\"\n    import numpy as np\n    from scipy.special import erfc\n\n    from chmpy.util.unit import ANGSTROM_TO_BOHR\n\n    if charges is None:\n        charges = np.empty(len(crystal.asym))\n        for mol in crystal.symmetry_unique_molecules():\n            pq = mol.partial_charges\n            charges[mol.properties[\"asymmetric_unit_atoms\"]] = pq\n    else:\n        charges = np.array(charges)\n\n    # convert to Bohr (i.e. perform the calculation in au)\n    eta /= ANGSTROM_TO_BOHR\n    rc = cutoff * ANGSTROM_TO_BOHR\n    trc = erfc(eta * rc) / rc\n    sqrt_pi = np.sqrt(np.pi)\n\n    self_term = 0\n    pair_term = 0\n\n    for surrounds in crystal.atomic_surroundings(radius=cutoff):  # angstroms here\n        i = surrounds[\"centre\"][\"asym_atom\"]\n        qi = charges[i]\n        self_term += qi * qi\n        qj = charges[surrounds[\"neighbours\"][\"asym_atom\"]]\n        rij = ANGSTROM_TO_BOHR * surrounds[\"neighbours\"][\"distance\"]\n        pair_term += np.sum(qi * qj * (erfc(eta * rij) / rij - trc))\n\n    self_term *= 0.5 * trc + eta / sqrt_pi\n\n    return 0.5 * pair_term - self_term\n</code></pre>"},{"location":"reference/chmpy/crystal/asymmetric_unit/","title":"asymmetric_unit","text":""},{"location":"reference/chmpy/crystal/asymmetric_unit/#chmpy.crystal.asymmetric_unit.AsymmetricUnit","title":"<code>AsymmetricUnit</code>","text":"<p>Storage class for the coordinates and labels in a crystal asymmetric unit</p> <p>Attributes:</p> Name Type Description <code>elements</code> <code>List[Element]</code> <p>N length list of elements associated with the sites in this asymmetric unit</p> <code>positions</code> <code>array_like</code> <p>(N, 3) array of site positions in fractional coordinates</p> <code>labels</code> <code>array_like</code> <p>N length array of string labels for each site</p> Source code in <code>chmpy/crystal/asymmetric_unit.py</code> <pre><code>class AsymmetricUnit:\n    \"\"\"\n    Storage class for the coordinates and labels in a crystal\n    asymmetric unit\n\n    Attributes:\n        elements (List[Element]): N length list of elements associated with\n            the sites in this asymmetric unit\n        positions (array_like): (N, 3) array of site positions in fractional\n            coordinates\n        labels (array_like): N length array of string labels for each site\n    \"\"\"\n\n    def __init__(self, elements, positions, labels=None, **kwargs):\n        \"\"\"\n        Create an asymmetric unit object from a list of Elements and\n        an array of fractional coordinates.\n\n\n        Arguments:\n            elements (List[Element]): N length list of elements associated\n                with the sites\n            positions (array_like): (N, 3) array of site positions in\n                fractional coordinates\n            labels (array_like, optional): labels (array_like): N length\n                array of string labels for each site\n            **kwargs: Additional properties (will populate the properties member)\n                to store in this asymmetric unit\n\n        \"\"\"\n        self.elements = elements\n        self.atomic_numbers = np.asarray([x.atomic_number for x in elements])\n        self.positions = np.asarray(positions)\n        self.properties = {}\n        self.properties.update(kwargs)\n        if labels is None:\n            self.labels = []\n            label_index = defaultdict(int)\n            for el in self.elements:\n                label_index[el] += 1\n                self.labels.append(f\"{el}{label_index[el]}\")\n        else:\n            self.labels = labels\n        self.labels = np.array(self.labels)\n\n    @property\n    def formula(self):\n        \"\"\"Molecular formula for this asymmetric unit\"\"\"\n        return chemical_formula(self.elements, subscript=False)\n\n    def __len__(self):\n        return len(self.elements)\n\n    def __repr__(self):\n        return f\"&lt;{self.formula}&gt;\"\n\n    @classmethod\n    def from_records(cls, records):\n        \"\"\"Initialize an AsymmetricUnit from a list of dictionary like objects\n\n        Arguments:\n            records (iterable): An iterable containing dict_like objects with `label`,\n                `element`, `position` and optionally `occupation` stored.\n        \"\"\"\n        labels = []\n        elements = []\n        positions = []\n        occupation = []\n        for r in records:\n            labels.append(r[\"label\"])\n            elements.append(Element[r[\"element\"]])\n            positions.append(r[\"position\"])\n            occupation.append(r.get(\"occupation\", 1.0))\n        positions = np.asarray(positions)\n        return AsymmetricUnit(elements, positions, labels=labels, occupation=occupation)\n</code></pre>"},{"location":"reference/chmpy/crystal/asymmetric_unit/#chmpy.crystal.asymmetric_unit.AsymmetricUnit.formula","title":"<code>formula</code>  <code>property</code>","text":"<p>Molecular formula for this asymmetric unit</p>"},{"location":"reference/chmpy/crystal/asymmetric_unit/#chmpy.crystal.asymmetric_unit.AsymmetricUnit.__init__","title":"<code>__init__(elements, positions, labels=None, **kwargs)</code>","text":"<p>Create an asymmetric unit object from a list of Elements and an array of fractional coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>elements</code> <code>List[Element]</code> <p>N length list of elements associated with the sites</p> required <code>positions</code> <code>array_like</code> <p>(N, 3) array of site positions in fractional coordinates</p> required <code>labels</code> <code>array_like</code> <p>labels (array_like): N length array of string labels for each site</p> <code>None</code> <code>**kwargs</code> <p>Additional properties (will populate the properties member) to store in this asymmetric unit</p> <code>{}</code> Source code in <code>chmpy/crystal/asymmetric_unit.py</code> <pre><code>def __init__(self, elements, positions, labels=None, **kwargs):\n    \"\"\"\n    Create an asymmetric unit object from a list of Elements and\n    an array of fractional coordinates.\n\n\n    Arguments:\n        elements (List[Element]): N length list of elements associated\n            with the sites\n        positions (array_like): (N, 3) array of site positions in\n            fractional coordinates\n        labels (array_like, optional): labels (array_like): N length\n            array of string labels for each site\n        **kwargs: Additional properties (will populate the properties member)\n            to store in this asymmetric unit\n\n    \"\"\"\n    self.elements = elements\n    self.atomic_numbers = np.asarray([x.atomic_number for x in elements])\n    self.positions = np.asarray(positions)\n    self.properties = {}\n    self.properties.update(kwargs)\n    if labels is None:\n        self.labels = []\n        label_index = defaultdict(int)\n        for el in self.elements:\n            label_index[el] += 1\n            self.labels.append(f\"{el}{label_index[el]}\")\n    else:\n        self.labels = labels\n    self.labels = np.array(self.labels)\n</code></pre>"},{"location":"reference/chmpy/crystal/asymmetric_unit/#chmpy.crystal.asymmetric_unit.AsymmetricUnit.from_records","title":"<code>from_records(records)</code>  <code>classmethod</code>","text":"<p>Initialize an AsymmetricUnit from a list of dictionary like objects</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>iterable</code> <p>An iterable containing dict_like objects with <code>label</code>, <code>element</code>, <code>position</code> and optionally <code>occupation</code> stored.</p> required Source code in <code>chmpy/crystal/asymmetric_unit.py</code> <pre><code>@classmethod\ndef from_records(cls, records):\n    \"\"\"Initialize an AsymmetricUnit from a list of dictionary like objects\n\n    Arguments:\n        records (iterable): An iterable containing dict_like objects with `label`,\n            `element`, `position` and optionally `occupation` stored.\n    \"\"\"\n    labels = []\n    elements = []\n    positions = []\n    occupation = []\n    for r in records:\n        labels.append(r[\"label\"])\n        elements.append(Element[r[\"element\"]])\n        positions.append(r[\"position\"])\n        occupation.append(r.get(\"occupation\", 1.0))\n    positions = np.asarray(positions)\n    return AsymmetricUnit(elements, positions, labels=labels, occupation=occupation)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/","title":"crystal","text":""},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal","title":"<code>Crystal</code>","text":"<p>Storage class for a molecular crystal structure.</p> <p>Attributes:</p> Name Type Description <code>unit_cell</code> <code>UnitCell</code> <p>the translational symmetry</p> <code>space_group</code> <code>SpaceGroup</code> <p>the symmetry within the unit cell</p> <code>asymmetric_unit</code> <code>AsymmetricUnit</code> <p>the symmetry unique set of sites in the crystal. Contains information on atomic positions, elements, labels etc.</p> <code>properties</code> <code>dict</code> <p>variable collection of named properties for this crystal</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>class Crystal:\n    \"\"\"\n    Storage class for a molecular crystal structure.\n\n    Attributes:\n        unit_cell: the translational symmetry\n        space_group: the symmetry within the unit cell\n        asymmetric_unit: the symmetry unique set of sites in\n            the crystal. Contains information on atomic positions,\n            elements, labels etc.\n        properties: variable collection of named properties for\n            this crystal\n    \"\"\"\n\n    space_group: SpaceGroup\n    unit_cell: UnitCell\n    asymmetric_unit: AsymmetricUnit\n    properties: dict\n\n    def __init__(\n        self,\n        unit_cell: UnitCell,\n        space_group: SpaceGroup,\n        asymmetric_unit: AsymmetricUnit,\n        **kwargs,\n    ):\n        \"\"\"\n        Construct a new crystal.\n\n\n        Arguments:\n            unit_cell: The unit cell for this crystal i.e. the\n                translational symmetry of the crystal structure.\n            space_group: The space group symmetry of this crystal\n                i.e. the generators for populating the unit cell given the\n                asymmetric unit.\n            asymmetric_unit: The asymmetric unit of this crystal.\n                 The sites of this combined with the space group will generate all\n                 translationally equivalent positions.\n            **kwargs: Optional properties to (will populate the properties member) store\n                about the the crystal structure.\n        \"\"\"\n\n        self.space_group = space_group\n        self.unit_cell = unit_cell\n        self.asymmetric_unit = asymmetric_unit\n        self.properties = {}\n        self.properties.update(kwargs)\n\n    @property\n    def sg(self) -&gt; SpaceGroup:\n        \"short accessor for `space_group`\"\n        return self.space_group\n\n    @property\n    def uc(self) -&gt; UnitCell:\n        \"short accessor for `unit_cell`\"\n        return self.unit_cell\n\n    @property\n    def asym(self) -&gt; AsymmetricUnit:\n        \"short accessor for `asymmetric_unit`\"\n        return self.asymmetric_unit\n\n    @property\n    def site_positions(self) -&gt; np.ndarray:\n        \"Row major array of asymmetric unit atomic positions\"\n        return self.asymmetric_unit.positions\n\n    @property\n    def site_atoms(self) -&gt; np.ndarray:\n        \"Array of asymmetric unit atomic numbers\"\n        return self.asymmetric_unit.atomic_numbers\n\n    @property\n    def nsites(self) -&gt; int:\n        \"\"\"The number of sites in the asymmetric unit.\"\"\"\n        return len(self.site_atoms)\n\n    @property\n    def symmetry_operations(self) -&gt; list[SymmetryOperation]:\n        \"Symmetry operations belonging to the space group symmetry of this crystal.\"\n        return self.space_group.symmetry_operations\n\n    def to_cartesian(self, coords) -&gt; np.ndarray:\n        \"\"\"\n        Convert coordinates (row major) from fractional to\n        Cartesian coordinates.\n\n        Arguments:\n            coords (np.ndarray): (N, 3) array of positions assumed to be in\n                fractional coordinates\n\n        Returns:\n            (N, 3) array of positions transformed to Cartesian (orthogonal)\n                coordinates by the unit cell of this crystal.\n        \"\"\"\n        return self.unit_cell.to_cartesian(coords)\n\n    def to_fractional(self, coords) -&gt; np.ndarray:\n        \"\"\"\n        Convert coordinates (row major) from Cartesian to\n        fractional coordinates.\n\n        Args:\n            coords (np.ndarray): (N, 3) array of positions assumed to be\n                in Cartesian (orthogonal) coordinates\n\n        Returns:\n            (N, 3) array of positions transformed to fractional coordinates\n            by the unit cell of this crystal.\n        \"\"\"\n\n        return self.unit_cell.to_fractional(coords)\n\n    def to_reciprocal(self, coords) -&gt; np.ndarray:\n        \"\"\"\n        Convert coordinates (row major) from fractional to\n        reciprocal space coordinates.\n\n        Arguments:\n            coords (np.ndarray): (N, 3) array of positions assumed to be in\n                fractional coordinates\n\n        Returns:\n            (N, 3) array of positions transformed to reciprocal (orthogonal)\n                coordinates by the unit cell of this crystal.\n        \"\"\"\n        return self.unit_cell.to_reciprocal(coords)\n\n    def unit_cell_atoms(self, tolerance=1e-2) -&gt; dict:\n        \"\"\"\n        Generate all atoms in the unit cell (i.e. with\n        fractional coordinates in [0, 1]) along with associated\n        information about symmetry operations, occupation, elements\n        related asymmetric_unit atom etc.\n\n        Will merge atom sites within tolerance of each other, and\n        sum their occupation numbers. A warning will be logged if\n        any atom site in the unit cell has &gt; 1.0 occupancy after\n        this.\n\n        Sets the `_unit_cell_atom_dict` member as this is an expensive\n        operation and is worth caching the result. Subsequent calls\n        to this function will be a no-op.\n\n        Arguments:\n            tolerance (float, optional): Minimum separation of sites in the unit\n                cell, below which atoms/sites will be merged and their (partial)\n                occupations added.\n\n        Returns:\n            A dictionary of arrays associated with all sites contained\n            in the unit cell of this crystal, members are:\n\n                asym_atom: corresponding asymmetric unit atom indices for all sites.\n                frac_pos: (N, 3) array of fractional positions for all sites.\n                cart_pos: (N, 3) array of cartesian positions for all sites.\n                element: (N) array of atomic numbers for all sites.\n                symop: (N) array of indices corresponding to the generator symmetry\n                operation for each site.\n                label: (N) array of string labels corresponding to each site\n                occupation: (N) array of occupation numbers for each site. Will\n                    warn if any of these are greater than 1.0\n        \"\"\"\n\n        if hasattr(self, \"_unit_cell_atom_dict\"):\n            return self._unit_cell_atom_dict\n        pos = self.site_positions\n        atoms = self.site_atoms\n        natom = self.nsites\n        nsymops = len(self.space_group.symmetry_operations)\n        occupation = np.tile(\n            self.asymmetric_unit.properties.get(\"occupation\", np.ones(natom)), nsymops\n        )\n        labels = np.tile(self.asymmetric_unit.labels, nsymops)\n        uc_nums = np.tile(atoms, nsymops)\n        asym = np.arange(len(uc_nums)) % natom\n        sym, uc_pos = self.space_group.apply_all_symops(pos)\n        translated = np.fmod(uc_pos + 7.0, 1)\n        tree = KDTree(translated)\n        dist = tree.sparse_distance_matrix(tree, max_distance=tolerance)\n        mask = np.ones(len(uc_pos), dtype=bool)\n        # because crystals may have partially occupied sites\n        # on special positions, we need to merge some sites\n        # expected_natoms = np.sum(occupation)\n        for (i, j), _ in dist.items():\n            if not (i &lt; j):\n                continue\n            occupation[i] += occupation[j]\n            mask[j] = False\n        occupation = occupation[mask]\n        if np.any(occupation &gt; 1.0):\n            LOG.debug(\"Some unit cell site occupations are &gt; 1.0\")\n        self._unit_cell_atom_dict = {\n            \"asym_atom\": asym[mask],\n            \"frac_pos\": translated[mask],\n            \"element\": uc_nums[mask],\n            \"symop\": sym[mask],\n            \"label\": labels[mask],\n            \"occupation\": occupation,\n            \"cart_pos\": self.to_cartesian(translated[mask]),\n        }\n        return self._unit_cell_atom_dict\n\n    def unit_cell_connectivity(\n        self, tolerance=0.4, neighbouring_cells=1, **kwargs\n    ) -&gt; tuple:\n        \"\"\"\n        Periodic connectiviy for the unit cell, populates _uc_graph\n        with a networkx.Graph object, where nodes are indices into the\n        _unit_cell_atom_dict arrays and the edges contain the translation\n        (cell) for the image of the corresponding unit cell atom with the\n        higher index to be bonded to the lower\n\n        Bonding is determined by interatomic distances being less than the\n        sum of covalent radii for the sites plus the tolerance (provided\n        as a parameter)\n\n        Arguments:\n            tolerance (float, optional):\n                Bonding tolerance (bonded if d &lt; cov_a + cov_b + tolerance)\n            neighbouring_cells (int, optional):\n                Number of neighbouring cells in which to look for bonded atoms.\n                We start at the (0, 0, 0) cell, so a value of 1 will look in the\n                (0, 0, 1), (0, 1, 1), (1, 1, 1) i.e. all 26 neighbouring cells.\n                1 is typically sufficient for organic systems.\n\n        Returns:\n            A tuple of (sparse_matrix in dict of keys format, dict)\n            the (i, j) value in this matrix is the bond length from i,j\n            the (i, j) value in the dict is the cell translation on j which\n            bonds these two sites\n        \"\"\"\n\n        if hasattr(self, \"_uc_graph\"):\n            return self._uc_graph\n        slab = self.slab(bounds=((-1, -1, -1), (1, 1, 1)))\n        n_uc = slab[\"n_uc\"]\n        uc_pos = slab[\"frac_pos\"][:n_uc]\n        uc_nums = slab[\"element\"][:n_uc]\n        neighbour_pos = slab[\"frac_pos\"][n_uc:]\n        cart_uc_pos = self.to_cartesian(uc_pos)\n        covalent_radii_dict = {\n            x: Element.from_atomic_number(x).cov for x in np.unique(uc_nums)\n        }\n        covalent_radii_dict.update(kwargs.get(\"covalent_radii\", {}))\n        # first establish all connections in the unit cell\n        covalent_radii = np.array([covalent_radii_dict[x] for x in uc_nums])\n        max_cov = np.max(covalent_radii)\n        # TODO this needs to be sped up for large cells, tends to slow for &gt; 1000 atoms\n        # and the space storage will become a problem\n        tree = KDTree(cart_uc_pos)\n        dist = tree.sparse_distance_matrix(tree, max_distance=2 * max_cov + tolerance)\n        uc_edges = []\n\n        for (i, j), d in dist.items():\n            if not (i &lt; j):\n                continue\n            if d &gt; 1e-3 and d &lt; (covalent_radii[i] + covalent_radii[j] + tolerance):\n                uc_edges.append((i, j, d, (0, 0, 0)))\n\n        cart_neighbour_pos = self.unit_cell.to_cartesian(neighbour_pos)\n        tree2 = KDTree(cart_neighbour_pos)\n        dist = tree.sparse_distance_matrix(tree2, max_distance=2 * max_cov + tolerance)\n        # could be sped up if done outside python\n        cells = slab[\"cell\"][n_uc:]\n        for (uc_atom, neighbour_atom), d in dist.items():\n            uc_idx = neighbour_atom % n_uc\n            if not (uc_atom &lt; uc_idx):\n                continue\n            if d &gt; 1e-3 and d &lt; (\n                covalent_radii[uc_atom] + covalent_radii[uc_idx] + tolerance\n            ):\n                cell = cells[neighbour_atom]\n                uc_edges.append((uc_atom, uc_idx, d, tuple(cell)))\n\n        properties = {}\n        uc_graph = dok_matrix((n_uc, n_uc))\n        for i, j, d, cell in uc_edges:\n            uc_graph[i, j] = d\n            properties[(i, j)] = cell\n\n        self._uc_graph = uc_graph, properties\n        return self._uc_graph\n\n    def unit_cell_molecules(self, bond_tolerance=0.4, **kwargs) -&gt; list[Molecule]:\n        \"\"\"\n        Calculate the molecules for all sites in the unit cell,\n        where the number of molecules will be equal to number of\n        symmetry unique molecules times number of symmetry operations.\n\n        Args:\n            bond_tolerance (float, optional): Bonding tolerance\n                (bonded if d &lt; cov_a + cov_b + bond_tolerance)\n\n        Returns:\n            A list of all connected molecules in this crystal, which\n            when translated by the unit cell would produce the full crystal.\n            If the asymmetric is molecular, the list will be of length\n            num_molecules_in_asymmetric_unit * num_symm_operations\n        \"\"\"\n\n        if hasattr(self, \"_unit_cell_molecules\"):\n            return self._unit_cell_molecules\n        uc_graph, edge_cells = self.unit_cell_connectivity(\n            tolerance=bond_tolerance, **kwargs\n        )\n        n_uc_mols, uc_mols = csgraph.connected_components(\n            csgraph=uc_graph, directed=False, return_labels=True\n        )\n        uc_dict = self._unit_cell_atom_dict\n        uc_frac = uc_dict[\"frac_pos\"]\n        uc_elements = uc_dict[\"element\"]\n        uc_asym = uc_dict[\"asym_atom\"]\n        uc_symop = uc_dict[\"symop\"]\n\n        molecules = []\n\n        n_uc = len(uc_frac)\n        LOG.debug(\"%d molecules in unit cell\", n_uc_mols)\n        for i in range(n_uc_mols):\n            nodes = np.where(uc_mols == i)[0]\n            root = nodes[0]\n            elements = uc_elements[nodes]\n            shifts = np.zeros((n_uc, 3))\n            ordered, pred = csgraph.breadth_first_order(\n                csgraph=uc_graph, i_start=root, directed=False\n            )\n            for j in ordered[1:]:\n                i = pred[j]\n                if j &lt; i:\n                    shifts[j, :] = shifts[i, :] - edge_cells[(j, i)]\n                else:\n                    shifts[j, :] = shifts[i, :] + edge_cells[(i, j)]\n            positions = self.to_cartesian((uc_frac + shifts)[nodes])\n            asym_atoms = uc_asym[nodes]\n            reorder = np.argsort(asym_atoms)\n            asym_atoms = asym_atoms[reorder]\n            mol = Molecule.from_arrays(\n                elements=elements[reorder],\n                positions=positions[reorder],\n                guess_bonds=True,\n                unit_cell_atoms=np.array(nodes)[reorder],\n                asymmetric_unit_atoms=asym_atoms,\n                asymmetric_unit_labels=self.asymmetric_unit.labels[asym_atoms],\n                generator_symop=uc_symop[np.asarray(nodes)[reorder]],\n            )\n            centroid = mol.center_of_mass\n            frac_centroid = self.to_fractional(centroid)\n            new_centroid = np.fmod(frac_centroid + 7.0, 1.0)\n            translation = self.to_cartesian(new_centroid - frac_centroid)\n            mol.translate(translation)\n            molecules.append(mol)\n        self._unit_cell_molecules = molecules\n        return molecules\n\n    def molecular_shell(\n        self, mol_idx=0, radius=3.8, method=\"nearest_atom\"\n    ) -&gt; list[Molecule]:\n        \"\"\"\n        Calculate the neighbouring molecules around the molecule with index\n        `mol_idx`, within the given `radius` using the specified `method`.\n\n        Arguments:\n            mol_idx (int, optional): The index (into `symmetry_unique_molecules`)\n                of the central molecule for the shell\n            radius (float, optional): The maximum distance (Angstroms) between\n                the central molecule and the neighbours.\n            method (str, optional): the method to use when determining inclusion\n                of neighbours.\n\n        Returns:\n            A list of neighbouring molecules using the given method.\n        \"\"\"\n        mol = self.symmetry_unique_molecules()[mol_idx]\n        frac_origin = self.to_fractional(mol.center_of_mass)\n        frac_radius = radius / np.array(self.unit_cell.lengths)\n        hmax, kmax, lmax = np.ceil(frac_radius + frac_origin).astype(int) + 1\n        hmin, kmin, lmin = np.floor(frac_origin - frac_radius).astype(int) - 1\n        uc_mols = self.unit_cell_molecules()\n        shifts = self.to_cartesian(\n            cartesian_product(\n                np.arange(hmin, hmax), np.arange(kmin, kmax), np.arange(lmin, lmax)\n            )\n        )\n        neighbours = []\n        for uc_mol in uc_mols:\n            for shift in shifts:\n                uc_mol_t = uc_mol.translated(shift)\n                dist = mol.distance_to(uc_mol_t, method=method)\n                if (dist &lt; radius) and (dist &gt; 1e-2):\n                    neighbours.append(uc_mol_t)\n        return neighbours\n\n    def molecule_dict(self, **kwargs) -&gt; dict:\n        \"\"\"\n        A dictionary of `symmetry_unique_molecules`, grouped by\n        their chemical formulae.\n\n        Returns:\n            the dictionary of molecules with chemical formula keys\n            and list of molecule values.\n        \"\"\"\n        result = {}\n        mols = self.symmetry_unique_molecules()\n        for m in mols:\n            f = m.molecular_formula\n            if f not in result:\n                result[f] = []\n            result[f].append(m)\n        return result\n\n    def symmetry_unique_molecules(self, bond_tolerance=0.4, **kwargs) -&gt; list[Molecule]:\n        \"\"\"\n        Calculate a list of connected molecules which contain\n        every site in the asymmetric_unit\n\n        Populates the _symmetry_unique_molecules member, subsequent\n        calls to this function will be a no-op.\n\n        Args:\n            bond_tolerance (float, optional): Bonding tolerance\n                (bonded if d &lt; cov_a + cov_b + bond_tolerance)\n\n        Returns:\n            List of all connected molecules in the asymmetric_unit of this\n            crystal, i.e. the minimum list of connected molecules which contain\n            all sites in the asymmetric unit.\n\n            If the asymmetric is molecular, the list will be of length\n            num_molecules_in_asymmetric_unit and the total number of atoms\n            will be equal to the number of atoms in the asymmetric_unit\n        \"\"\"\n\n        if hasattr(self, \"_symmetry_unique_molecules\"):\n            return self._symmetry_unique_molecules\n        uc_molecules = self.unit_cell_molecules(bond_tolerance=bond_tolerance, **kwargs)\n        asym_atoms = np.zeros(len(self.asymmetric_unit), dtype=bool)\n        molecules = []\n\n        # sort by % of identity symop\n        def order(x):\n            return len(np.where(x.asym_symops == 16484)[0]) / len(x)\n\n        for mol in sorted(uc_molecules, key=order, reverse=True):\n            asym_atoms_in_g = np.unique(mol.properties[\"asymmetric_unit_atoms\"])\n            if np.all(asym_atoms[asym_atoms_in_g]):\n                continue\n            asym_atoms[asym_atoms_in_g] = True\n            molecules.append(mol)\n            if np.all(asym_atoms):\n                break\n        LOG.debug(\"%d symmetry unique molecules\", len(molecules))\n        self._symmetry_unique_molecules = molecules\n        for i, mol in enumerate(molecules):\n            mol.properties[\"asym_mol_idx\"] = i\n\n        ak = \"asymmetric_unit_atoms\"\n        for mol in self.unit_cell_molecules():\n            if \"asym_mol_idx\" in mol.properties:\n                continue\n            else:\n                for asym_mol in molecules:\n                    if len(mol) != len(asym_mol):\n                        continue\n                    if np.all(mol.properties[ak] == asym_mol.properties[ak]):\n                        mol.properties[\"asym_mol_idx\"] = asym_mol.properties[\n                            \"asym_mol_idx\"\n                        ]\n                        break\n                else:\n                    LOG.warn(\n                        \"No equivalent asymmetric unit molecule found!?\"\n                        \"-- this should not happen!\"\n                    )\n        return molecules\n\n    def slab(self, bounds=((-1, -1, -1), (1, 1, 1))) -&gt; dict:\n        \"\"\"\n        Calculate the atoms and associated information\n        for a slab consisting of multiple unit cells.\n\n        If unit cell atoms have not been calculated, this calculates\n        their information and caches it.\n\n        Args:\n            bounds (Tuple, optional): Tuple of upper and lower corners (hkl)\n                describing the bounds of the slab.\n\n        Returns:\n            A dictionary of arrays associated with all sites contained\n            in the unit cell of this crystal, members are:\n                asym_atom: corresponding asymmetric unit atom indices for all sites.\n                frac_pos: (N, 3) array of fractional positions for all sites.\n                cart_pos: (N, 3) array of cartesian positions for all sites.\n                element: (N) array of atomic numbers for all sites.\n                symop: (N) array of indices corresponding to the generator symmetry\n                    operation for each site.\n                label: (N) array of string labels corresponding to each site\n                occupation: (N) array of occupation numbers for each site. Will\n                    warn if any of these are greater than 1.0\n                cell: (N,3) array of cell indices for each site\n\n            n_uc: number of atoms in the unit cell\n\n            n_cells: number of cells in this slab\n\n            occupation: (N) array of occupation numbers for each site. Will\n            warn if any of these are greater than 1.0\n\n        \"\"\"\n        uc_atoms = self.unit_cell_atoms()\n        (hmin, kmin, lmin), (hmax, kmax, lmax) = bounds\n        h = np.arange(hmin, hmax + 1)\n        k = np.arange(kmin, kmax + 1)\n        l = np.arange(lmin, lmax + 1)  # noqa: E741\n        cells = cartesian_product(\n            h[np.argsort(np.abs(h))], k[np.argsort(np.abs(k))], l[np.argsort(np.abs(l))]\n        )\n        ncells = len(cells)\n        uc_pos = uc_atoms[\"frac_pos\"]\n        n_uc = len(uc_pos)\n        pos = np.empty((ncells * n_uc, 3), dtype=np.float64)\n        slab_cells = np.empty((ncells * n_uc, 3), dtype=np.float64)\n        for i, cell in enumerate(cells):\n            pos[i * n_uc : (i + 1) * n_uc, :] = uc_pos + cell\n            slab_cells[i * n_uc : (i + 1) * n_uc] = cell\n        slab_dict = {\n            k: np.tile(v, ncells) for k, v in uc_atoms.items() if not k.endswith(\"pos\")\n        }\n        slab_dict[\"frac_pos\"] = pos\n        slab_dict[\"cell\"] = slab_cells\n        slab_dict[\"n_uc\"] = n_uc\n        slab_dict[\"n_cells\"] = ncells\n        slab_dict[\"cart_pos\"] = self.to_cartesian(pos)\n        return slab_dict\n\n    def atoms_in_radius(self, radius, origin=(0, 0, 0)) -&gt; dict:\n        \"\"\"\n        Calculate all (periodic) atoms within the given `radius` of the specified\n        `origin`.\n\n        Arguments:\n            radius (float): the maximum distance (Angstroms) from the origin\n                for inclusion\n            origin (Tuple, optional): the origin in fractional coordinates\n\n        Returns:\n            A dictionary mapping (see the the `slab` method),\n            of those atoms within `radius` of the `origin`.\n        \"\"\"\n        frac_origin = self.to_fractional(origin)\n        frac_radius = radius / np.array(self.unit_cell.lengths)\n        hmax, kmax, lmax = np.ceil(frac_radius + frac_origin).astype(int)\n        hmin, kmin, lmin = np.floor(frac_origin - frac_radius).astype(int)\n        slab = self.slab(bounds=((hmin, kmin, lmin), (hmax, kmax, lmax)))\n        tree = KDTree(slab[\"cart_pos\"])\n        idxs = sorted(tree.query_ball_point(origin, radius))\n        result = {k: v[idxs] for k, v in slab.items() if isinstance(v, np.ndarray)}\n        result[\"uc_atom\"] = np.tile(np.arange(slab[\"n_uc\"]), slab[\"n_cells\"])[idxs]\n        return result\n\n    def atomic_surroundings(self, radius=6.0) -&gt; list[dict]:\n        \"\"\"\n        Calculate all atoms within the given `radius` of\n        each atomic site in the asymmetric unit.\n\n        Arguments:\n            radius (float): the maximum distance (Angstroms) from the origin\n                for inclusion\n\n        Returns:\n            A list of atomic number, Cartesian position for both the\n            atomic site in question and the surroundings (as an array)\n        \"\"\"\n        cart_asym = self.to_cartesian(self.asymmetric_unit.positions)\n        hklmax = np.array([-np.inf, -np.inf, -np.inf])\n        hklmin = np.array([np.inf, np.inf, np.inf])\n        frac_radius = radius / np.array(self.unit_cell.lengths)\n        for pos in self.asymmetric_unit.positions:\n            hklmax = np.maximum(hklmax, np.ceil(frac_radius + pos))\n            hklmin = np.minimum(hklmin, np.floor(pos - frac_radius))\n        hmax, kmax, lmax = hklmax.astype(int)\n        hmin, kmin, lmin = hklmin.astype(int)\n        slab = self.slab(bounds=((hmin, kmin, lmin), (hmax, kmax, lmax)))\n        tree = KDTree(slab[\"cart_pos\"])\n        results = []\n        for i, (n, pos) in enumerate(\n            zip(self.asymmetric_unit.elements, cart_asym, strict=False)\n        ):\n            idxs = tree.query_ball_point(pos, radius)\n            positions = slab[\"cart_pos\"][idxs]\n            elements = slab[\"element\"][idxs]\n            asym = slab[\"asym_atom\"][idxs]\n            d = np.linalg.norm(positions - pos, axis=1)\n            keep = np.where(d &gt; 1e-3)[0]\n            results.append(\n                {\n                    \"centre\": {\n                        \"element\": n.atomic_number,\n                        \"cart_pos\": pos,\n                        \"asym_atom\": i,\n                    },\n                    \"neighbours\": {\n                        \"element\": elements[keep],\n                        \"cart_pos\": positions[keep],\n                        \"distance\": d[keep],\n                        \"asym_atom\": asym[keep],\n                    },\n                }\n            )\n        return results\n\n    def atom_group_surroundings(self, atoms, radius=6.0) -&gt; tuple:\n        \"\"\"\n        Calculate all atoms within the given `radius` of the specified\n        group of atoms in the asymetric unit.\n\n        Arguments:\n            radius (float): the maximum distance (Angstroms) from the origin\n                for inclusion\n\n        Returns:\n            A list of atomic number, Cartesian position for both the\n            atomic sites in question and their surroundings (as an array)\n        \"\"\"\n        hklmax = np.array([-np.inf, -np.inf, -np.inf])\n        hklmin = np.array([np.inf, np.inf, np.inf])\n        frac_radius = radius / np.array(self.unit_cell.lengths)\n        mol = self.symmetry_unique_molecules()[0]\n        central_positions = self.to_fractional(mol.positions[atoms])\n        central_elements = mol.atomic_numbers[atoms]\n        central_cart_positions = mol.positions[atoms]\n\n        for pos in central_positions:\n            hklmax = np.maximum(hklmax, np.ceil(frac_radius + pos))\n            hklmin = np.minimum(hklmin, np.floor(pos - frac_radius))\n        hmax, kmax, lmax = hklmax.astype(int)\n        hmin, kmin, lmin = hklmin.astype(int)\n        slab = self.slab(bounds=((hmin, kmin, lmin), (hmax, kmax, lmax)))\n        elements = slab[\"element\"]\n        positions = slab[\"cart_pos\"]\n        tree = KDTree(positions)\n        keep = np.zeros(positions.shape[0], dtype=bool)\n\n        this_mol = []\n        for pos in central_cart_positions:\n            idxs = tree.query_ball_point(pos, radius)\n            d, nn = tree.query(pos)\n            keep[idxs] = True\n            if d &lt; 1e-3:\n                this_mol.append(nn)\n                keep[this_mol] = False\n        return (\n            (central_elements, central_cart_positions),\n            (elements[keep], positions[keep]),\n        )\n\n    def molecule_environment(self, mol, radius=6.0, threshold=1e-3) -&gt; tuple:\n        \"\"\"\n        Calculate the atomic information for all\n        atoms surrounding the given molecule in this crystal\n        within the given radius. Atoms closer than `threshold`\n        to any atom in the provided molecule will be excluded and\n        considered part of the molecule.\n\n        Args:\n            mol (Molecule): the molecule whose environment to calculate\n            radius (float, optional): Maximum distance in Angstroms between\n                any atom in the molecule and the resulting neighbouring atoms\n            threshold (float, optional): tolerance for detecting the neighbouring\n                sites as part of the given molecule.\n\n        Returns:\n            A list of tuples of (Molecule, elements, positions)\n                where `elements` is an `np.ndarray` of atomic numbers,\n                and `positions` is an `np.ndarray` of Cartesian atomic positions\n        \"\"\"\n\n        hklmax = np.array([-np.inf, -np.inf, -np.inf])\n        hklmin = np.array([np.inf, np.inf, np.inf])\n        frac_radius = radius / np.array(self.unit_cell.lengths)\n        for pos in self.to_fractional(mol.positions):\n            hklmax = np.maximum(hklmax, np.ceil(frac_radius + pos))\n            hklmin = np.minimum(hklmin, np.floor(pos - frac_radius))\n        hmax, kmax, lmax = hklmax.astype(int)\n        hmin, kmin, lmin = hklmin.astype(int)\n        slab = self.slab(bounds=((hmin, kmin, lmin), (hmax, kmax, lmax)))\n        elements = slab[\"element\"]\n        positions = slab[\"cart_pos\"]\n        tree = KDTree(positions)\n        keep = np.zeros(positions.shape[0], dtype=bool)\n        this_mol = []\n        for pos in mol.positions:\n            idxs = tree.query_ball_point(pos, radius)\n            d, nn = tree.query(pos)\n            keep[idxs] = True\n            if d &lt; threshold:\n                this_mol.append(nn)\n                keep[this_mol] = False\n        return (mol, elements[keep], positions[keep])\n\n    def molecule_environments(self, radius=6.0, threshold=1e-3) -&gt; list[tuple]:\n        \"\"\"\n        Calculate the atomic information for all\n        atoms surrounding each symmetry unique molecule\n        in this crystal within the given radius.\n\n        Args:\n            radius (float, optional): Maximum distance in Angstroms between\n                any atom in the molecule and the resulting neighbouring atoms\n            threshold (float, optional): tolerance for detecting the neighbouring\n                sites as part of the given molecule.\n\n        Returns:\n            A list of tuples of (Molecule, elements, positions)\n            where `elements` is an `np.ndarray` of atomic numbers,\n            and `positions` is an `np.ndarray` of Cartesian atomic positions\n        \"\"\"\n        return [\n            self.molecule_environment(x, radius=radius, threshold=threshold)\n            for x in self.symmetry_unique_molecules()\n        ]\n\n    def functional_group_surroundings(self, radius=6.0, kind=\"carboxylic_acid\") -&gt; list:\n        \"\"\"\n        Calculate the atomic information for all\n        atoms surrounding each functional group in each symmetry unique molecule\n        in this crystal within the given radius.\n\n        Args:\n            radius (float, optional): Maximum distance in Angstroms between\n                any atom in the molecule and the resulting neighbouring atoms\n            kind (str, optional): the functional group type\n\n        Returns:\n            A list of tuples of (func_el, func_pos, neigh_el, neigh_pos)\n            where `func_el` and `neigh_el` are `np.ndarray` of atomic numbers,\n            and `func_pos` and `neigh_pos` are `np.ndarray` of\n            Cartesian atomic positions\n        \"\"\"\n        results = []\n        for mol in self.symmetry_unique_molecules():\n            hklmax = np.array([-np.inf, -np.inf, -np.inf])\n            hklmin = np.array([np.inf, np.inf, np.inf])\n            frac_radius = radius / np.array(self.unit_cell.lengths)\n            for pos in self.to_fractional(mol.positions):\n                hklmax = np.maximum(hklmax, np.ceil(frac_radius + pos))\n                hklmin = np.minimum(hklmin, np.floor(pos - frac_radius))\n            hmax, kmax, lmax = hklmax.astype(int)\n            hmin, kmin, lmin = hklmin.astype(int)\n            slab = self.slab(bounds=((hmin, kmin, lmin), (hmax, kmax, lmax)))\n            elements = slab[\"element\"]\n            positions = slab[\"cart_pos\"]\n            tree = KDTree(positions)\n            groups = mol.functional_groups(kind=kind)\n            for fg in groups:\n                fg = list(fg)\n                keep = np.zeros(positions.shape[0], dtype=bool)\n                inside = []\n                for pos in mol.positions[fg]:\n                    idxs = tree.query_ball_point(pos, radius)\n                    d, nn = tree.query(pos)\n                    keep[idxs] = True\n                    if d &lt; 1e-3:\n                        inside.append(nn)\n                        keep[inside] = False\n                results.append(\n                    (\n                        mol.atomic_numbers[fg],\n                        mol.positions[fg],\n                        elements[keep],\n                        positions[keep],\n                    )\n                )\n        return results\n\n    def promolecule_density_isosurfaces(self, **kwargs) -&gt; list[Trimesh]:\n        \"\"\"\n        Calculate promolecule electron density isosurfaces\n        for each symmetry unique molecule in this crystal.\n\n        Args:\n            kwargs: Keyword arguments used by `Molecule.promolecule_density_isosurface`.\n\n                Options are:\n                ```\n                isovalue (float, optional): level set value for the isosurface\n                    (default=0.002) in au.\n                separation (float, optional): separation between density grid\n                    used in the surface calculation (default 0.2) in Angstroms.\n                color (str, optional): surface property to use for vertex coloring,\n                    one of ('d_norm_i', 'd_i', 'd_norm_e', 'd_e')\n                colormap (str, optional): matplotlib colormap to use for surface\n                    coloring (default 'viridis_r')\n                midpoint (float, optional): midpoint of the segmented\n                    colormap (if applicable)\n                ```\n\n        Returns:\n            A list of meshes representing the promolecule density isosurfaces\n        \"\"\"\n        if kwargs.get(\"color\", None) == \"fragment_patch\":\n            color = kwargs.pop(\"color\")\n            surfaces = [\n                mol.promolecule_density_isosurface(**kwargs)\n                for mol in self.symmetry_unique_molecules()\n            ]\n            radius = kwargs.get(\"fragment_patch_radius\", 6.0)\n            from chmpy.util.color import property_to_color\n            from chmpy.util.mesh import face_centroids\n\n            for i, (_mol, n_e, n_p) in enumerate(\n                self.molecule_environments(radius=radius)\n            ):\n                surf = surfaces[i]\n                prop = _nearest_molecule_idx(surf.vertices, n_e, n_p)\n                color = property_to_color(prop, cmap=kwargs.get(\"colormap\", color))\n                face_points = face_centroids(surf)\n                surf.visual.vertex_colors = color\n                surf.vertex_attributes[\"fragment_patch\"] = prop\n                surf.face_attributes[\"fragment_patch\"] = _nearest_molecule_idx(\n                    face_points, n_e, n_p\n                )\n        else:\n            surfaces = [\n                mol.promolecule_density_isosurface(**kwargs)\n                for mol in self.symmetry_unique_molecules()\n            ]\n        return surfaces\n\n    def unit_cell_coordination_numbers(self) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the coordination numbers for the unit cell atoms of this\n        crystal using the EEQ method with periodic boundary conditions.\n\n        Returns:\n            an `ndarray` of coordination numbers for the unit cell atoms.\n        \"\"\"\n        if hasattr(self, \"_unit_cell_coordination_numbers\"):\n            return self._unit_cell_coordination_numbers\n\n        from chmpy.crystal.eeq_pbc import calculate_coordination_numbers_crystal\n\n        # Calculate coordination numbers with PBC\n        cn = calculate_coordination_numbers_crystal(self)\n        self._unit_cell_coordination_numbers = cn.astype(np.float32)\n\n        return self._unit_cell_coordination_numbers\n\n    def asymmetric_unit_coordination_numbers(self) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the coordination numbers for the asymmetric unit of this\n        crystal using the EEQ method with periodic boundary conditions.\n\n        Returns:\n            an `ndarray` of coordination numbers for the asymmetric unit atoms.\n        \"\"\"\n        if hasattr(self, \"_asymmetric_unit_coordination_numbers\"):\n            return self._asymmetric_unit_coordination_numbers\n\n        # Get unit cell coordination numbers\n        uc_cn = self.unit_cell_coordination_numbers()\n        uc_atoms = self.unit_cell_atoms()\n\n        # Map back to asymmetric unit\n        asym_cn = np.empty(len(self.asymmetric_unit), dtype=np.float32)\n        for i, cn in enumerate(uc_cn):\n            asym_idx = uc_atoms[\"asym_atom\"][i]\n            asym_cn[asym_idx] = cn\n\n        self._asymmetric_unit_coordination_numbers = asym_cn\n        return asym_cn\n\n    def unit_cell_partial_charges(self, method=\"eeq\") -&gt; np.ndarray:\n        \"\"\"\n        Calculate the partial charges for the unit cell atoms of this\n        crystal using the specified method with periodic boundary conditions.\n\n        Args:\n            method (str): Charge method to use ('eeq' or 'eem')\n\n        Returns:\n            an `ndarray` of partial charges for the unit cell atoms.\n        \"\"\"\n        if hasattr(self, \"_unit_cell_partial_charges\"):\n            return self._unit_cell_partial_charges\n\n        method = method.lower()\n\n        if method == \"eeq\":\n            from chmpy.crystal.eeq_pbc import calculate_eeq_charges_pbc\n\n            # Get unit cell atoms\n            uc_atoms = self.unit_cell_atoms()\n            positions = uc_atoms[\"cart_pos\"]\n            atomic_numbers = uc_atoms[\"element\"]\n\n            # Get cell vectors\n            cell_vectors = self.unit_cell.lattice\n\n            # Calculate net charge (usually 0 for crystals)\n            charge = 0.0\n\n            # Calculate charges with PBC\n            charges = calculate_eeq_charges_pbc(\n                atomic_numbers, positions, cell_vectors, charge\n            )\n        else:\n            # Use molecular approach for EEM (less accurate for crystals)\n            mols = self.unit_cell_molecules()\n            charges = np.empty(len(self.unit_cell_atoms()[\"element\"]), dtype=np.float32)\n\n            # Set charge method for molecules\n            for mol in mols:\n                mol.properties[\"charge_method\"] = method\n\n            # Get charges from molecules\n            for mol in mols:\n                uc_indices = mol.properties.get(\"unit_cell_atoms\", [])\n                for i, charge in enumerate(mol.partial_charges):\n                    if i &lt; len(uc_indices):\n                        charges[uc_indices[i]] = charge\n\n        self._unit_cell_partial_charges = charges.astype(np.float32)\n        return charges\n\n    def asymmetric_unit_partial_charges(self, method=\"eeq\") -&gt; np.ndarray:\n        \"\"\"\n        Calculate the partial charges for the asymmetric unit of this\n        crystal using the specified method.\n\n        Args:\n            method (str): Charge method to use ('eeq' or 'eem')\n\n        Returns:\n            an `ndarray` of atomic partial charges.\n        \"\"\"\n        if method.lower() == \"eeq\":\n            # Get unit cell charges using EEQ with PBC\n            uc_charges = self.unit_cell_partial_charges(method=\"eeq\")\n            uc_atoms = self.unit_cell_atoms()\n\n            # Map back to asymmetric unit\n            charges = np.empty(len(self.asymmetric_unit), dtype=np.float32)\n            for i, charge in enumerate(uc_charges):\n                asym_idx = uc_atoms[\"asym_atom\"][i]\n                charges[asym_idx] = charge\n\n            return charges\n        else:\n            # Use the molecular approach for other methods\n            mols = self.symmetry_unique_molecules()\n            charges = np.empty(len(self.asymmetric_unit), dtype=np.float32)\n\n            # Set charge method for molecules\n            for mol in mols:\n                mol.properties[\"charge_method\"] = method\n\n            for mol in mols:\n                for idx, charge in zip(\n                    mol.properties[\"asymmetric_unit_atoms\"],\n                    mol.partial_charges,\n                    strict=False,\n                ):\n                    charges[idx] = charge\n\n            return charges\n\n    def void_surface(self, *args, **kwargs) -&gt; Trimesh:\n        \"\"\"\n        Calculate void surface based on promolecule electron density\n        for the unit cell of this crystal\n\n        Args:\n            kwargs: Keyword arguments used in the evaluation of the surface.\n\n                Options are:\n                ```\n                isovalue (float, optional): level set value for the\n                    isosurface (default=0.002) in au.\n                separation (float, optional): separation between density grid\n                    used in the surface calculation (default 0.2) in Angstroms.\n                ```\n\n        Returns:\n            the mesh representing the promolecule density void isosurface\n        \"\"\"\n\n        import trimesh\n\n        from chmpy import PromoleculeDensity\n        from chmpy.mc import marching_cubes\n\n        vertex_color = kwargs.get(\"color\", None)\n\n        atoms = self.slab(bounds=((-1, -1, -1), (1, 1, 1)))\n        density = PromoleculeDensity((atoms[\"element\"], atoms[\"cart_pos\"]))\n        sep = kwargs.get(\"separation\", kwargs.get(\"resolution\", 0.5))\n        isovalue = kwargs.get(\"isovalue\", 3e-4)\n        grid_type = kwargs.get(\"grid_type\", \"uc\")\n        if grid_type == \"uc\":\n            seps = sep / np.array(self.unit_cell.lengths)\n            x_grid = np.arange(0, 1.0, seps[0], dtype=np.float32)\n            y_grid = np.arange(0, 1.0, seps[1], dtype=np.float32)\n            z_grid = np.arange(0, 1.0, seps[2], dtype=np.float32)\n            x, y, z = np.meshgrid(x_grid, y_grid, z_grid)\n            shape = x.shape\n            pts = np.c_[x.ravel(), y.ravel(), z.ravel()]\n            pts = pts.astype(np.float32)\n            pts = self.to_cartesian(pts)\n        elif grid_type == \"box\":\n            ((x0, y0, z0), (x1, y1, z1)) = kwargs.get(\n                \"box_corners\", ((0.0, 0.0, 0.0), (5.0, 5.0, 5.0))\n            )\n            x, y, z = np.mgrid[x0:x1:sep, y0:y1:sep, z0:z1:sep]\n            pts = np.c_[x.ravel(), y.ravel(), z.ravel()]\n            pts = pts.astype(np.float32)\n            shape = x.shape\n            seps = (sep, sep, sep)\n        else:\n            raise NotImplementedError(\"Only uc grid supported currently\")\n        tree = KDTree(atoms[\"cart_pos\"])\n        distances, _ = tree.query(pts)\n        values = np.ones(pts.shape[0], dtype=np.float32)\n        mask = distances &gt; 1.0  # minimum bigger than 1 angstrom\n        rho = density.rho(pts[mask])\n        values[mask] = rho\n        values = values.reshape(shape)\n        verts, faces, normals, _ = marching_cubes(\n            values, isovalue, spacing=seps, gradient_direction=\"ascent\"\n        )\n        if grid_type == \"uc\":\n            verts = self.to_cartesian(np.c_[verts[:, 1], verts[:, 0], verts[:, 2]])\n        mesh = trimesh.Trimesh(vertices=verts, faces=faces, normals=normals)\n\n        if kwargs.get(\"subdivide\", False):\n            for _ in range(int(kwargs.get(\"subdivide\", False))):\n                mesh = mesh.subdivide()\n\n        if vertex_color == \"esp\":\n            from chmpy.util.color import property_to_color\n\n            asym_charges = self.asymmetric_unit_partial_charges()\n            mol = Molecule.from_arrays(atoms[\"element\"], atoms[\"cart_pos\"])\n            partial_charges = np.empty(len(mol), dtype=np.float32)\n            partial_charges = asym_charges[atoms[\"asym_atom\"]]\n            mol._partial_charges = partial_charges\n            prop = mol.electrostatic_potential(mesh.vertices)\n            mesh.visual.vertex_colors = property_to_color(\n                prop, cmap=kwargs.get(\"cmap\", \"esp\")\n            )\n        return mesh\n\n    def mesh_scene(self, **kwargs):\n        \"\"\"\n        Calculate a scene of this meshes of unit cell molecules in this crystal,\n        along with optional void surface.\n\n        Args:\n            kwargs: optional arguments used in the generation of this scene.\n\n        Returns:\n            trimesh.scene.Scene: trimesh scene object.\n        \"\"\"\n        from trimesh import Scene\n\n        meshes = {}\n        for i, m in enumerate(self.unit_cell_molecules()):\n            mesh = m.to_mesh(representation=kwargs.get(\"representation\", \"ball_stick\"))\n            n = m.molecular_formula\n            for k, v in mesh.items():\n                meshes[f\"mol_{i}_{n}.{k}\"] = v\n\n        if kwargs.get(\"void\", False):\n            void_kwargs = kwargs.get(\"void_kwargs\", {})\n            meshes[\"void_surface\"] = self.void_surface(**void_kwargs)\n        if kwargs.get(\"axes\", False):\n            from trimesh.creation import axis\n\n            meshes[\"axes\"] = axis(\n                transform=self.unit_cell.direct_homogeneous.T, axis_length=1.0\n            )\n        return Scene(meshes)\n\n    def hirshfeld_surfaces(self, **kwargs):\n        \"Alias for `self.stockholder_weight_isosurfaces`\"\n        return self.stockholder_weight_isosurfaces(**kwargs)\n\n    def stockholder_weight_isosurfaces(self, kind=\"mol\", **kwargs) -&gt; list[Trimesh]:\n        \"\"\"\n        Calculate stockholder weight isosurfaces (i.e. Hirshfeld surfaces)\n        for each symmetry unique molecule or atom in this crystal.\n\n        Args:\n            kind (str, optional): dictates whether we calculate surfaces\n                for each unique molecule or for each unique atom\n            kwargs: keyword arguments passed to `stockholder_weight_isosurface`.\n\n                Options include:\n                ```\n                isovalue: float, optional\n                    level set value for the isosurface (default=0.5). Must be between\n                    0 and 1, but values other than 0.5 probably won't make sense anyway.\n                separation: float, optional\n                    separation between density grid used in the surface calculation\n                    (default 0.2) in Angstroms.\n                radius: float, optional\n                    maximum distance for contributing neighbours for the stockholder\n                    weight calculation\n                color: str, optional\n                    surface property to use for vertex coloring, one of ('d_norm_i',\n                    'd_i', 'd_norm_e', 'd_e', 'd_norm', 'fragment_patch')\n                colormap: str, optional\n                    matplotlib colormap to use for surface coloring\n                    (default 'viridis_r')\n                midpoint: float, optional, default 0.0 if using d_norm\n                    use the midpoint norm (as is used in CrystalExplorer)\n                ```\n\n        Returns:\n            A list of meshes representing the stockholder weight isosurfaces\n        \"\"\"\n        import trimesh\n\n        from chmpy import StockholderWeight\n        from chmpy.surface import stockholder_weight_isosurface\n        from chmpy.util.color import property_to_color\n\n        sep = kwargs.get(\"separation\", kwargs.get(\"resolution\", 0.2))\n        radius = kwargs.get(\"radius\", 12.0)\n        vertex_color = kwargs.get(\"color\", \"d_norm\")\n        isovalue = kwargs.get(\"isovalue\", 0.5)\n        meshes = []\n        extra_props = {}\n        isos = []\n\n        def nearest_atomic_number(pos, n_e, n_p):\n            return np.array(n_e[_nearest_atom_idx(pos, n_e, n_p)], dtype=np.uint8)\n\n        if kind == \"atom\":\n            for surrounds in self.atomic_surroundings(radius=radius):\n                n = surrounds[\"centre\"][\"element\"]\n                pos = surrounds[\"centre\"][\"cart_pos\"]\n                neighbour_els = surrounds[\"neighbours\"][\"element\"]\n                neighbour_pos = surrounds[\"neighbours\"][\"cart_pos\"]\n                s = StockholderWeight.from_arrays(\n                    [n], [pos], neighbour_els, neighbour_pos\n                )\n                iso = stockholder_weight_isosurface(s, isovalue=isovalue, sep=sep)\n                isos.append(iso)\n        elif kind == \"mol\":\n            for _i, (mol, n_e, n_p) in enumerate(\n                self.molecule_environments(radius=radius)\n            ):\n                extra_props = {}\n                if vertex_color == \"esp\":\n                    extra_props[\"esp\"] = mol.electrostatic_potential\n                elif vertex_color == \"fragment_patch\":\n                    extra_props[\"fragment_patch\"] = (\n                        lambda x, _n_e=n_e, _n_p=n_p: _nearest_molecule_idx(\n                            x, _n_e, _n_p\n                        )\n                    )\n                extra_props[\"nearest_atom_external\"] = (\n                    lambda x, _n_e=n_e, _n_p=n_p: nearest_atomic_number(x, _n_e, _n_p)\n                )\n                extra_props[\"nearest_atom_internal\"] = (\n                    lambda x,\n                    _atomic_nums=mol.atomic_numbers,\n                    _positions=mol.positions: nearest_atomic_number(\n                        x, _atomic_nums, _positions\n                    )\n                )\n                s = StockholderWeight.from_arrays(\n                    mol.atomic_numbers, mol.positions, n_e, n_p\n                )\n                iso = stockholder_weight_isosurface(\n                    s, isovalue=isovalue, sep=sep, extra_props=extra_props\n                )\n                isos.append(iso)\n        else:\n            for arr in self.functional_group_surroundings(radius=radius, kind=kind):\n                s = StockholderWeight.from_arrays(*arr)\n                iso = stockholder_weight_isosurface(s, isovalue=isovalue, sep=sep)\n                isos.append(iso)\n\n        for iso in isos:\n            prop = iso.vertex_prop[vertex_color]\n            color = property_to_color(prop, cmap=kwargs.get(\"cmap\", vertex_color))\n            mesh = trimesh.Trimesh(\n                vertices=iso.vertices,\n                faces=iso.faces,\n                normals=iso.normals,\n                vertex_colors=color,\n            )\n            for k, v in iso.vertex_prop.items():\n                mesh.vertex_attributes[k] = v\n            meshes.append(mesh)\n        return meshes\n\n    def functional_group_shape_descriptors(\n        self, l_max=5, radius=6.0, kind=\"carboxylic_acid\"\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the shape descriptors `[1,2]` for the all atoms in\n        the functional group given for all symmetry unique molecules in this crystal.\n\n        Args:\n            l_max (int, optional): maximum level of angular momenta to include\n                in the spherical harmonic transform of the molecular shape function.\n                (default: 5)\n            radius (float, optional): maximum distance (Angstroms) of neighbouring\n                atoms to include in stockholder weight calculation (default: 5)\n            kind (str, optional): Identifier for the functional group\n                type (default: 'carboxylic_acid')\n\n        Returns:\n            shape description vector\n\n        References:\n        ```\n        [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n            https://dx.doi.org/10.1038/srep22204\n        [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n            https://dx.doi.org/10.1002/anie.201906602\n        ```\n        \"\"\"\n        descriptors = []\n        from chmpy.shape import SHT, stockholder_weight_descriptor\n\n        sph = SHT(l_max)\n        for (\n            in_els,\n            in_pos,\n            neighbour_els,\n            neighbour_pos,\n        ) in self.functional_group_surroundings(kind=kind, radius=radius):\n            masses = np.asarray([Element[x].mass for x in in_els])\n            c = np.sum(in_pos * masses[:, np.newaxis] / np.sum(masses), axis=0).astype(\n                np.float32\n            )\n            dists = np.linalg.norm(in_pos - c, axis=1)\n            bounds = np.min(dists) / 2, np.max(dists) + 10.0\n            descriptors.append(\n                stockholder_weight_descriptor(\n                    sph,\n                    in_els,\n                    in_pos,\n                    neighbour_els,\n                    neighbour_pos,\n                    origin=c,\n                    bounds=bounds,\n                )\n            )\n        return np.asarray(descriptors)\n\n    def molecule_shape_descriptors(\n        self, mol, l_max=5, radius=6.0, with_property=None\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the molecular shape descriptors `[1,2]` for\n        the provided molecule in the crystal.\n\n        Args:\n            l_max (int, optional): maximum level of angular momenta to include\n                in the spherical harmonic\n                transform of the molecular shape function.\n            radius (float, optional): maximum distance (Angstroms) to include\n                surroundings in the shape description\n            with_property (str, optional): name of the surface property to include\n                in the shape description\n\n        Returns:\n            shape description vector\n\n        References:\n        ```\n        [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n            https://dx.doi.org/10.1038/srep22204\n        [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n            https://dx.doi.org/10.1002/anie.201906602\n        ```\n        \"\"\"\n        from chmpy.shape import SHT, stockholder_weight_descriptor\n\n        sph = SHT(l_max)\n        mol, neighbour_els, neighbour_pos = self.molecule_environment(\n            mol, radius=radius\n        )\n        c = np.array(mol.centroid, dtype=np.float32)\n        dists = np.linalg.norm(mol.positions - c, axis=1)\n        bounds = np.min(dists) / 2, np.max(dists) + 10.0\n        return stockholder_weight_descriptor(\n            sph,\n            mol.atomic_numbers,\n            mol.positions,\n            neighbour_els,\n            neighbour_pos,\n            origin=c,\n            bounds=bounds,\n            with_property=with_property,\n        )\n\n    def molecular_shape_descriptors(\n        self, l_max=5, radius=6.0, with_property=None, return_coefficients=False\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the molecular shape descriptors[1,2] for all symmetry unique\n        molecules in this crystal.\n\n        Args:\n            l_max (int, optional): maximum level of angular momenta to include\n                in the spherical harmonic transform of the molecular shape function.\n            radius (float, optional): maximum distance (Angstroms) to include\n                surroundings in the shape description\n            with_property (str, optional): name of the surface property to include\n                in the shape description\n            return_coefficients (bool, optional): also return the spherical\n                harmonic coefficients\n\n        Returns:\n            shape description vector\n\n        References:\n        ```\n        [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n            https://dx.doi.org/10.1038/srep22204\n        [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n            https://dx.doi.org/10.1002/anie.201906602\n        ```\n        \"\"\"\n        descriptors = []\n        coeffs = []\n        from chmpy.shape import SHT, stockholder_weight_descriptor\n\n        sph = SHT(l_max)\n        for mol, neighbour_els, neighbour_pos in self.molecule_environments(\n            radius=radius\n        ):\n            c = np.array(mol.centroid, dtype=np.float32)\n            dists = np.linalg.norm(mol.positions - c, axis=1)\n            bounds = np.min(dists) / 2, np.max(dists) + 10.0\n            descriptor = stockholder_weight_descriptor(\n                sph,\n                mol.atomic_numbers,\n                mol.positions,\n                neighbour_els,\n                neighbour_pos,\n                origin=c,\n                bounds=bounds,\n                with_property=with_property,\n                coefficients=return_coefficients,\n            )\n\n            if return_coefficients:\n                coeffs.append(descriptor[0])\n                descriptors.append(descriptor[1])\n            else:\n                descriptors.append(descriptor)\n        if return_coefficients:\n            return np.asarray(coeffs), np.asarray(descriptors)\n        else:\n            return np.asarray(descriptors)\n\n    def atomic_shape_descriptors(\n        self, l_max=5, radius=6.0, return_coefficients=False, with_property=None\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Calculate the shape descriptors[1,2] for all symmetry unique\n        atoms in this crystal.\n\n        Args:\n            l_max (int, optional): maximum level of angular momenta to include\n                in the spherical harmonic transform of the molecular shape function.\n            radius (float, optional): maximum distance (Angstroms) to include\n                surroundings in the shape description\n            with_property (str, optional): name of the surface property to include\n                in the shape description\n            return_coefficients (bool, optional): also return the spherical\n                harmonic coefficients\n\n        Returns:\n            shape description vector\n\n        References:\n        ```\n        [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n            https://dx.doi.org/10.1038/srep22204\n        [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n            https://dx.doi.org/10.1002/anie.201906602\n        ```\n        \"\"\"\n        descriptors = []\n        coeffs = []\n        from chmpy.shape import SHT, stockholder_weight_descriptor\n\n        sph = SHT(l_max)\n        for surrounds in self.atomic_surroundings(radius=radius):\n            n = surrounds[\"centre\"][\"element\"]\n            pos = surrounds[\"centre\"][\"cart_pos\"]\n            neighbour_els = surrounds[\"neighbours\"][\"element\"]\n            neighbour_pos = surrounds[\"neighbours\"][\"cart_pos\"]\n\n            ubound = Element[n].vdw_radius * 3 + 2.0\n            desc = stockholder_weight_descriptor(\n                sph,\n                [n],\n                [pos],\n                neighbour_els,\n                neighbour_pos,\n                bounds=(0.15, ubound),\n                coefficients=return_coefficients,\n                with_property=with_property,\n            )\n            if return_coefficients:\n                descriptors.append(desc[1])\n                coeffs.append(desc[0])\n            else:\n                descriptors.append(desc)\n        if return_coefficients:\n            return np.asarray(coeffs), np.asarray(descriptors)\n        else:\n            return np.asarray(descriptors)\n\n    def atom_group_shape_descriptors(self, atoms, l_max=5, radius=6.0) -&gt; np.ndarray:\n        \"\"\"Calculate the shape descriptors[1,2] for the given atomic\n        group in this crystal.\n\n        Args:\n            atoms (Tuple): atoms to include in the as the 'inside'\n                of the shape description.\n            l_max (int, optional): maximum level of angular momenta to include\n                in the spherical harmonic transform of the molecular shape function.\n            radius (float, optional): maximum distance (Angstroms) to include\n                surroundings in the shape description\n\n        Returns:\n            shape description vector\n\n        References:\n        ```\n        [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n            https://dx.doi.org/10.1038/srep22204\n        [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n            https://dx.doi.org/10.1002/anie.201906602\n        ```\n        \"\"\"\n        from chmpy.shape import SHT, stockholder_weight_descriptor\n\n        sph = SHT(l_max)\n        inside, outside = self.atom_group_surroundings(atoms, radius=radius)\n        m = Molecule.from_arrays(*inside)\n        c = np.array(m.centroid, dtype=np.float32)\n        dists = np.linalg.norm(m.positions - c, axis=1)\n        bounds = np.min(dists) / 2, np.max(dists) + 10.0\n        return np.asarray(\n            stockholder_weight_descriptor(\n                sph, *inside, *outside, origin=c, bounds=bounds\n            )\n        )\n\n    def shape_descriptors(self, kind=\"molecular\", **kwargs):\n        k = kind.lower()\n        if k == \"molecular\":\n            return self.molecular_shape_descriptors(**kwargs)\n        elif k == \"molecule\":\n            return self.molecule_shape_descriptors(**kwargs)\n        elif k == \"atomic\":\n            return self.atomic_shape_descriptors(**kwargs)\n        elif k == \"atom group\":\n            return self.atom_group_shape_descriptors(**kwargs)\n\n    @property\n    def site_labels(self):\n        \"array of labels for sites in the `asymmetric_unit`\"\n        return self.asymmetric_unit.labels\n\n    def __repr__(self):\n        if \"lattice_energy\" in self.properties and \"density\" in self.properties:\n            return \"&lt;Crystal {} {} ({:.3f}, {:.3f})&gt;\".format(\n                self.asymmetric_unit.formula,\n                self.space_group.symbol,\n                self.properties[\"density\"],\n                self.properties[\"lattice_energy\"],\n            )\n        return f\"&lt;Crystal {self.asymmetric_unit.formula} {self.space_group.symbol}&gt;\"\n\n    @property\n    def density(self):\n        \"Calculated density of this crystal structure in g/cm^3\"\n        if \"density\" in self.properties:\n            return self.properties[\"density\"]\n        uc_mass = sum(Element[x].mass for x in self.unit_cell_atoms()[\"element\"])\n        uc_vol = self.unit_cell.volume()\n        return uc_mass / uc_vol / 0.6022\n\n    @classmethod\n    def _ext_load_map(cls):\n        return {\n            \".cif\": cls.from_cif_file,\n            \".res\": cls.from_shelx_file,\n            \".vasp\": cls.from_vasp_file,\n            \".pdb\": cls.from_pdb_file,\n            \".gen\": cls.from_gen_file,\n        }\n\n    def _ext_save_map(self):\n        return {\".cif\": self.to_cif_file, \".res\": self.to_shelx_file}\n\n    @classmethod\n    def _fname_load_map(cls):\n        return {\"POSCAR\": cls.from_vasp_file, \"CONTCAR\": cls.from_vasp_file}\n\n    def _fname_save_map(self):\n        return {\"POSCAR\": self.to_poscar_file, \"CONTCAR\": self.to_poscar_file}\n\n    @classmethod\n    def load(cls, filename, **kwargs) -&gt; Union[\"Crystal\", dict]:\n        \"\"\"\n        Load a crystal structure from file (.res, .cif)\n\n        Args:\n            filename (str): the path to the crystal structure file\n\n        Returns:\n            the resulting crystal structure or dictionary of crystal structures\n        \"\"\"\n        fpath = Path(filename)\n        n = fpath.name\n        fname_map = cls._fname_load_map()\n        if n in fname_map:\n            return fname_map[n](filename)\n        extension_map = cls._ext_load_map()\n        extension = kwargs.pop(\"fmt\", fpath.suffix.lower())\n        if not extension.startswith(\".\"):\n            extension = \".\" + extension\n        return extension_map[extension](filename, **kwargs)\n\n    @classmethod\n    def from_vasp_string(cls, string, **kwargs):\n        \"Initialize a crystal structure from a VASP POSCAR string\"\n        from chmpy.fmt.vasp import parse_poscar\n\n        vasp_data = parse_poscar(string)\n        uc = UnitCell(vasp_data[\"direct\"])\n        sg = SpaceGroup(1)\n        coords = vasp_data[\"positions\"]\n        if not vasp_data[\"coord_type\"].startswith(\"d\"):\n            coords = uc.to_fractional(coords)\n        asym = AsymmetricUnit(vasp_data[\"elements\"], coords)\n        return Crystal(uc, sg, asym, titl=vasp_data[\"name\"])\n\n    @classmethod\n    def from_vasp_file(cls, filename, **kwargs):\n        \"Initialize a crystal structure from a VASP POSCAR file\"\n        return cls.from_vasp_string(Path(filename).read_text(), **kwargs)\n\n    @classmethod\n    def from_ase_atoms(cls, atoms, **kwargs):\n        from chmpy.ext.ase import ase_to_crystal\n\n        return ase_to_crystal(atoms, **kwargs)\n\n    @classmethod\n    def from_cif_data(cls, cif_data, titl=None):\n        \"\"\"Initialize a crystal structure from a dictionary\n        of CIF data\"\"\"\n        labels = cif_data.get(\"atom_site_label\", None)\n        symbols = cif_data.get(\"atom_site_type_symbol\", None)\n        if symbols is None:\n            if labels is None:\n                raise ValueError(\n                    \"Unable to determine elements in CIF, \"\n                    \"need one of _atom_site_label or \"\n                    \"_atom_site_type_symbol present\"\n                )\n            elements = [Element[x] for x in labels]\n        else:\n            elements = [Element[x] for x in symbols]\n        x = np.asarray(cif_data.get(\"atom_site_fract_x\", []))\n        y = np.asarray(cif_data.get(\"atom_site_fract_y\", []))\n        z = np.asarray(cif_data.get(\"atom_site_fract_z\", []))\n        occupation = np.asarray(cif_data.get(\"atom_site_occupancy\", [1] * len(x)))\n        frac_pos = np.array([x, y, z]).T\n        asym = AsymmetricUnit(\n            elements=elements, positions=frac_pos, labels=labels, occupation=occupation\n        )\n        lengths = [cif_data[f\"cell_length_{x}\"] for x in (\"a\", \"b\", \"c\")]\n        angles = [cif_data[f\"cell_angle_{x}\"] for x in (\"alpha\", \"beta\", \"gamma\")]\n        unit_cell = UnitCell.from_lengths_and_angles(lengths, angles, unit=\"degrees\")\n\n        space_group = SpaceGroup(1)\n        symop_data_names = (\n            \"symmetry_equiv_pos_as_xyz\",\n            \"space_group_symop_operation_xyz\",\n        )\n        number = space_group.international_tables_number\n        for k in (\"space_group_IT_number\", \"symmetry_Int_Tables_number\"):\n            if k in cif_data:\n                number = cif_data[k]\n                break\n\n        # Try to parse the Hermann-Mauguin symbol first\n        hm_parsed = False\n        hm_symbol = cif_data.get(\"symmetry_space_group_name_H-M\", \"\").strip()\n        if hm_symbol:\n            try:\n                # Convert CIF Hermann-Mauguin notation to correct SpaceGroup\n                space_group = cls._parse_hermann_mauguin_symbol(hm_symbol, number)\n                hm_parsed = True\n            except (ValueError, KeyError):\n                # Fall back to symmetry operations if HM symbol parsing fails\n                pass\n\n        # Only try symmetry operations if HM parsing failed\n        if not hm_parsed:\n            for symop_data_block in symop_data_names:\n                if symop_data_block in cif_data:\n                    symops = [\n                        SymmetryOperation.from_string_code(x)\n                        for x in cif_data[symop_data_block]\n                    ]\n                    try:\n                        new_sg = SpaceGroup.from_symmetry_operations(symops)\n                        space_group = new_sg\n                    except ValueError:\n                        space_group.symmetry_operations = symops\n                        symbol = cif_data.get(\n                            \"symmetry_space_group_name_H-M\", \"Unknown\"\n                        )\n                        space_group.international_tables_number = number\n                        space_group.symbol = symbol\n                        space_group.full_symbol = symbol\n                        LOG.warn(\n                            \"Initializing non-standard spacegroup setting %s, \"\n                            \"some SG data may be missing\",\n                            symbol,\n                        )\n                    break\n            else:\n                # fall back to international tables number\n                space_group = SpaceGroup(number)\n\n        return Crystal(unit_cell, space_group, asym, cif_data=cif_data, titl=titl)\n\n    @classmethod\n    def _parse_hermann_mauguin_symbol(cls, hm_symbol, sg_number):\n        \"\"\"\n        Parse Hermann-Mauguin symbol from CIF and find matching SpaceGroup.\n\n        Args:\n            hm_symbol (str): Hermann-Mauguin symbol from CIF (e.g. 'P C M 21')\n            sg_number (int): Space group number from CIF\n\n        Returns:\n            SpaceGroup: Matching space group object\n        \"\"\"\n        from .space_group import SG_FROM_NUMBER\n\n        # Clean up the symbol - remove extra spaces, normalize\n        clean_symbol = \" \".join(hm_symbol.upper().split())\n\n        # Get all possible settings for this space group number\n        if str(sg_number) not in SG_FROM_NUMBER:\n            raise ValueError(f\"Space group number {sg_number} not found\")\n\n        sg_settings = SG_FROM_NUMBER[str(sg_number)]\n\n        # Try each setting and check if crystal17_spacegroup_symbol matches\n        for sg_data in sg_settings:\n            try:\n                sg = SpaceGroup(sg_number, choice=sg_data.choice)\n                crystal17_symbol = sg.crystal17_spacegroup_symbol().upper()\n\n                if clean_symbol == crystal17_symbol:\n                    return sg\n            except Exception as e:\n                LOG.debug(\n                    \"Exception encountered when determining space group setting: %s\", e\n                )\n                continue\n\n        # If no match found, raise error\n        raise ValueError(\n            f\"Could not match Hermann-Mauguin symbol '{hm_symbol}' \"\n            f\"to any setting of space group #{sg_number}\"\n        )\n\n    @classmethod\n    def from_cif_file(cls, filename, data_block_name=None):\n        \"\"\"Initialize a crystal structure from a CIF file\"\"\"\n        cif = Cif.from_file(filename)\n        if data_block_name is not None:\n            return cls.from_cif_data(cif.data[data_block_name], titl=data_block_name)\n\n        crystals = {\n            name: cls.from_cif_data(data, titl=name) for name, data in cif.data.items()\n        }\n        keys = list(crystals.keys())\n        if len(keys) == 1:\n            return crystals[keys[0]]\n        return crystals\n\n    @classmethod\n    def from_pdb_file(cls, filename):\n        from chmpy.fmt.pdb import Pdb\n\n        pdb = Pdb.from_file(filename)\n        uc = UnitCell.from_lengths_and_angles(\n            [pdb.unit_cell[\"a\"], pdb.unit_cell[\"b\"], pdb.unit_cell[\"c\"]],\n            [pdb.unit_cell[\"alpha\"], pdb.unit_cell[\"beta\"], pdb.unit_cell[\"gamma\"]],\n            unit=\"degrees\",\n        )\n        pos_cart = np.c_[pdb.atoms[\"x\"], pdb.atoms[\"y\"], pdb.atoms[\"z\"]]\n        pos_frac = uc.to_fractional(pos_cart)\n        elements = [Element.from_string(x) for x in pdb.atoms[\"element\"]]\n        labels = pdb.atoms[\"name\"]\n        asym = AsymmetricUnit(elements, pos_frac, labels=labels)\n        sg = SpaceGroup.from_symbol(pdb.space_group)\n        return Crystal(uc, sg, asym)\n\n    @classmethod\n    def from_cif_string(cls, file_content, **kwargs):\n        data_block_name = kwargs.get(\"data_block_name\", None)\n        cif = Cif.from_string(file_content)\n        if data_block_name is not None:\n            return cls.from_cif_data(cif.data[data_block_name], titl=data_block_name)\n\n        crystals = {\n            name: cls.from_cif_data(data, titl=name) for name, data in cif.data.items()\n        }\n        keys = list(crystals.keys())\n        if len(keys) == 1:\n            return crystals[keys[0]]\n        return crystals\n\n    @classmethod\n    def from_shelx_file(cls, filename, **kwargs):\n        \"\"\"Initialize a crystal structure from a shelx .res file\"\"\"\n        p = Path(filename)\n        titl = p.stem\n        return cls.from_shelx_string(p.read_text(), titl=titl, **kwargs)\n\n    @classmethod\n    def from_shelx_string(cls, file_content, **kwargs):\n        \"\"\"Initialize a crystal structure from a shelx .res string\"\"\"\n        from chmpy.fmt.shelx import parse_shelx_file_content\n\n        shelx_dict = parse_shelx_file_content(file_content)\n        asymmetric_unit = AsymmetricUnit.from_records(shelx_dict[\"ATOM\"])\n        space_group = SpaceGroup.from_symmetry_operations(\n            shelx_dict[\"SYMM\"], expand_latt=shelx_dict[\"LATT\"]\n        )\n        unit_cell = UnitCell.from_lengths_and_angles(\n            shelx_dict[\"CELL\"][\"lengths\"], shelx_dict[\"CELL\"][\"angles\"], unit=\"degrees\"\n        )\n        return cls(unit_cell, space_group, asymmetric_unit, **kwargs)\n\n    @classmethod\n    def from_crystal17_opt_string(cls, string, **kwargs):\n        from chmpy.fmt.crystal17 import load_crystal17_geometry_string\n\n        data = load_crystal17_geometry_string(string)\n        unit_cell = UnitCell(data[\"direct\"])\n        space_group = SpaceGroup.from_symmetry_operations(data[\"symmetry_operations\"])\n        asym = AsymmetricUnit(data[\"elements\"], unit_cell.to_fractional(data[\"xyz\"]))\n        return Crystal(unit_cell, space_group, asym)\n\n    @classmethod\n    def from_crystal17_opt_file(cls, filename, **kwargs):\n        p = Path(filename)\n        titl = p.stem\n        return cls.from_crystal17_opt_string(p.read_text(), titl=titl, **kwargs)\n\n    @classmethod\n    def from_molecule(cls, molecule, **kwargs):\n        unit_cell = UnitCell.cubic(1000)\n\n        asym = AsymmetricUnit(\n            elements=molecule.elements,\n            positions=unit_cell.to_fractional(molecule.positions),\n            labels=molecule.labels,\n        )\n        space_group = SpaceGroup(1)\n        x = cls(unit_cell, space_group, asym)\n        _ = x.unit_cell_atoms(\n            tolerance=1e-12\n        )  # need to workaround default tolerance as we have a massive cell\n        return x\n\n    @classmethod\n    def from_gen_string(cls, contents, **kwargs):\n        from chmpy.fmt.gen import parse_gen_string\n\n        elements, positions, cell, fractional = parse_gen_string(contents)\n        unit_cell = UnitCell(cell[1:4, :])\n\n        asym = AsymmetricUnit(\n            elements=elements,\n            positions=positions,\n        )\n        space_group = SpaceGroup(1)\n        return cls(unit_cell, space_group, asym, **kwargs)\n\n    @classmethod\n    def from_gen_file(cls, filename, **kwargs):\n        p = Path(filename)\n        titl = p.stem\n        return cls.from_gen_string(p.read_text(), titl=titl, **kwargs)\n\n    @property\n    def name(self) -&gt; str:\n        \"synonym for titl\"\n        return self.titl\n\n    @property\n    def id(self) -&gt; str:\n        \"synonym for titl\"\n        return self.titl\n\n    @property\n    def titl(self) -&gt; str:\n        if \"titl\" in self.properties:\n            return self.properties[\"titl\"]\n        return self.asymmetric_unit.formula\n\n    def to_ase_atoms(self, **kwargs):\n        from chmpy.ext.ase import crystal_to_ase\n\n        return crystal_to_ase(self)\n\n    def to_cif_data(self, data_block_name=None) -&gt; dict:\n        \"Convert this crystal structure to cif data dict\"\n        version = \"1.0a1\"\n        if data_block_name is None:\n            data_block_name = self.titl\n        if \"cif_data\" in self.properties:\n            cif_data = self.properties[\"cif_data\"]\n            cif_data[\"audit_creation_method\"] = (\n                f\"chmpy python library version {version}\"\n            )\n            cif_data[\"atom_site_fract_x\"] = self.asymmetric_unit.positions[:, 0]\n            cif_data[\"atom_site_fract_y\"] = self.asymmetric_unit.positions[:, 1]\n            cif_data[\"atom_site_fract_z\"] = self.asymmetric_unit.positions[:, 2]\n        else:\n            cif_data = {\n                \"audit_creation_method\": f\"chmpy python library version {version}\",\n                \"symmetry_equiv_pos_site_id\": list(\n                    range(1, len(self.symmetry_operations) + 1)\n                ),\n                \"symmetry_equiv_pos_as_xyz\": [str(x) for x in self.symmetry_operations],\n                \"cell_length_a\": self.unit_cell.a,\n                \"cell_length_b\": self.unit_cell.b,\n                \"cell_length_c\": self.unit_cell.c,\n                \"cell_angle_alpha\": self.unit_cell.alpha_deg,\n                \"cell_angle_beta\": self.unit_cell.beta_deg,\n                \"cell_angle_gamma\": self.unit_cell.gamma_deg,\n                \"atom_site_label\": self.asymmetric_unit.labels,\n                \"atom_site_type_symbol\": [\n                    x.symbol for x in self.asymmetric_unit.elements\n                ],\n                \"atom_site_fract_x\": self.asymmetric_unit.positions[:, 0],\n                \"atom_site_fract_y\": self.asymmetric_unit.positions[:, 1],\n                \"atom_site_fract_z\": self.asymmetric_unit.positions[:, 2],\n                \"atom_site_occupancy\": self.asymmetric_unit.properties.get(\n                    \"occupation\", np.ones(len(self.asymmetric_unit))\n                ),\n            }\n        return {data_block_name: cif_data}\n\n    def structure_factors(self, **kwargs):\n        from chmpy.crystal.sfac import structure_factors\n\n        return structure_factors(self, **kwargs)\n\n    def unique_reflections(self, **kwargs):\n        from chmpy.crystal.sfac import reflections\n\n        return reflections(self, **kwargs)\n\n    def powder_pattern(self, **kwargs):\n        from chmpy.crystal.powder import PowderPattern\n        from chmpy.crystal.sfac import powder_pattern\n\n        tt, f2 = powder_pattern(self, **kwargs)\n        if not hasattr(self, \"_have_warned_powder\"):\n            LOG.warn(\n                \"Warning -- pattern calculation is a work in progress, currently\"\n                \"values may be incorrect for many systems. USE AT YOUR OWN RISK\"\n            )\n            self._have_warned_powder = True\n        return PowderPattern(tt, f2, **kwargs)\n\n    def to_translational_symmetry(self, supercell=(1, 1, 1)) -&gt; \"Crystal\":\n        \"\"\"\n        Create a supercell of this crystal in space group P 1.\n\n        Args:\n            supercell (Tuple[int]): size of the supercell to be created\n\n        Returns:\n            Crystal object of a supercell in space group P 1\n        \"\"\"\n        from itertools import product\n\n        hmax, kmax, lmax = supercell\n        a, b, c = self.unit_cell.lengths\n        sc = UnitCell.from_lengths_and_angles(\n            (hmax * a, kmax * b, lmax * c), self.unit_cell.angles\n        )\n\n        h = np.arange(hmax)\n        k = np.arange(kmax)\n        l = np.arange(lmax)\n        molecules = []\n        for q, r, s in product(h, k, l):\n            for uc_mol in self.unit_cell_molecules():\n                molecules.append(\n                    uc_mol.translated(np.asarray([q, r, s]) @ self.unit_cell.lattice)\n                )\n\n        asym_pos = np.vstack([x.positions for x in molecules])\n        asym_nums = np.hstack([x.atomic_numbers for x in molecules])\n        asymmetric_unit = AsymmetricUnit(\n            [Element[x] for x in asym_nums], sc.to_fractional(asym_pos)\n        )\n        new_titl = self.titl + \"_P1_supercell_{}_{}_{}\".format(*supercell)\n        new_crystal = Crystal(sc, SpaceGroup(1), asymmetric_unit, titl=new_titl)\n        return new_crystal\n\n    def to_cif_file(self, filename, **kwargs):\n        \"save this crystal to a CIF formatted file\"\n        cif_data = self.to_cif_data(**kwargs)\n        return Cif(cif_data).to_file(filename)\n\n    def to_cif_string(self, **kwargs):\n        \"save this crystal to a CIF formatted string\"\n        cif_data = self.to_cif_data(**kwargs)\n        return Cif(cif_data).to_string()\n\n    def to_poscar_string(self, **kwargs):\n        \"save this crystal to a VASP POSCAR formatted string\"\n        from chmpy.ext.vasp import poscar_string\n\n        return poscar_string(self, name=self.titl)\n\n    def to_poscar_file(self, filename, **kwargs):\n        \"save this crystal to a VASP POSCAR formatted file\"\n        Path(filename).write_text(self.to_poscar_string(**kwargs))\n\n    def to_shelx_file(self, filename):\n        \"\"\"Write this crystal structure as a shelx .res formatted file\"\"\"\n        Path(filename).write_text(self.to_shelx_string())\n\n    def to_shelx_string(self, titl=None):\n        \"\"\"Represent this crystal structure as a shelx .res formatted string\"\"\"\n        from chmpy.fmt.shelx import to_res_contents\n\n        sfac = list(np.unique(self.site_atoms))\n        atom_sfac = [sfac.index(x) + 1 for x in self.site_atoms]\n        shelx_data = {\n            \"TITL\": self.titl if titl is None else titl,\n            \"CELL\": self.unit_cell.parameters,\n            \"SFAC\": [Element[x].symbol for x in sfac],\n            \"SYMM\": [\n                str(s)\n                for s in self.space_group.reduced_symmetry_operations()\n                if not s.is_identity()\n            ],\n            \"LATT\": self.space_group.latt,\n            \"ATOM\": [\n                \"{:3} {:3} {: 20.12f} {: 20.12f} {: 20.12f}\".format(l, s, *pos)\n                for l, s, pos in zip(\n                    self.asymmetric_unit.labels,\n                    atom_sfac,\n                    self.site_positions,\n                    strict=False,\n                )\n            ],\n        }\n        return to_res_contents(shelx_data)\n\n    def to_pdb_string(self, header=None):\n        \"\"\"Represent this crystal structure as a PDB formatted string.\"\"\"\n        from chmpy.fmt.pdb import Pdb\n\n        pdb = Pdb.from_crystal(self, header=header)\n        return pdb.to_string()\n\n    def to_pdb_file(self, filename, header=None):\n        \"\"\"Write this crystal structure as a PDB formatted file.\"\"\"\n        Path(filename).write_text(self.to_pdb_string(header=header))\n\n    def save(self, filename, **kwargs):\n        \"\"\"Save this crystal structure to file (.cif, .res, POSCAR)\"\"\"\n        fpath = Path(filename)\n        n = fpath.name\n        fname_map = self._fname_save_map()\n        if n in fname_map:\n            return fname_map[n](filename, **kwargs)\n        extension_map = self._ext_save_map()\n        extension = kwargs.pop(\"fmt\", fpath.suffix.lower())\n        if not extension.startswith(\".\"):\n            extension = \".\" + extension\n        return extension_map[extension](filename, **kwargs)\n\n    def choose_trigonal_lattice(self, choice=\"H\"):\n        \"\"\"\n        Change the choice of lattice for this crystal to either\n        rhombohedral or hexagonal cell\n\n        Args:\n            choice (str, optional): The choice of the resulting lattice,\n                either 'H' for hexagonal or 'R' for rhombohedral (default 'H').\n        \"\"\"\n        if not self.space_group.has_hexagonal_rhombohedral_choices():\n            raise ValueError(\"Invalid space group for choose_trigonal_lattice\")\n        if self.space_group.choice == choice:\n            return\n        cart_asym_pos = self.to_cartesian(self.asymmetric_unit.positions)\n        assert choice in (\"H\", \"R\"), \"Valid choices are H, R\"\n        if self.space_group.choice == \"R\":\n            T = np.array(((-1, 1, 0), (1, 0, -1), (1, 1, 1)))\n        else:\n            T = 1 / 3 * np.array(((-1, 1, 1), (2, 1, 1), (-1, -2, 1)))\n        new_uc = UnitCell(np.dot(T, self.unit_cell.direct))\n        self.unit_cell = new_uc\n        self.asymmetric_unit.positions = self.to_fractional(cart_asym_pos)\n        self.space_group = SpaceGroup(\n            self.space_group.international_tables_number, choice=choice\n        )\n\n    def as_P1(self) -&gt; \"Crystal\":\n        \"\"\"Create a copy of this crystal in space group P 1, with the new\n        asymmetric_unit consisting of self.unit_cell_molecules()\"\"\"\n        return self.as_P1_supercell((1, 1, 1))\n\n    def as_P1_supercell(self, size) -&gt; \"Crystal\":\n        \"\"\"\n        Create a supercell of this crystal in space group P 1.\n\n        Args:\n            size (Tuple[int]): size of the P 1 supercell to be created\n\n        Returns:\n            Crystal object of a supercell in space group P 1\n        \"\"\"\n        import itertools as it\n\n        umax, vmax, wmax = size\n        a, b, c = self.unit_cell.lengths\n        sc = UnitCell.from_lengths_and_angles(\n            (umax * a, vmax * b, wmax * c), self.unit_cell.angles\n        )\n\n        u = np.arange(umax)\n        v = np.arange(vmax)\n        w = np.arange(wmax)\n        sc_mols = []\n        for q, r, s in it.product(u, v, w):\n            for uc_mol in self.unit_cell_molecules():\n                sc_mols.append(\n                    uc_mol.translated(np.asarray([q, r, s]) @ self.unit_cell.lattice)\n                )\n\n        asym_pos = np.vstack([x.positions for x in sc_mols])\n        asym_nums = np.hstack([x.atomic_numbers for x in sc_mols])\n        asymmetric_unit = AsymmetricUnit(\n            [Element[x] for x in asym_nums], sc.to_fractional(asym_pos)\n        )\n        new_crystal = Crystal(sc, SpaceGroup(1), asymmetric_unit)\n        new_crystal.properties[\"titl\"] = self.titl + \"-P1-{}-{}-{}\".format(*size)\n        return new_crystal\n\n    def cartesian_symmetry_operations(self):\n        \"\"\"\n        Create a list of symmetry operations (rotation, translation)\n        for evaluation of transformations in cartesian space.\n\n        The rotation matrices are stored to be used as np.dot(x, R),\n        (i.e. post-multiplicaiton on row-major coordinates)\n\n        Returns:\n            List[Tuple[np.ndarray, np.ndarray]]: a list of (rotation, translation)\n        \"\"\"\n        cart_symops = []\n        d = self.unit_cell.direct\n        i = self.unit_cell.inverse\n        for symop in self.symmetry_operations:\n            cart_symops.append(\n                (\n                    np.dot(d.T, np.dot(symop.rotation, i.T)).T,\n                    self.to_cartesian(symop.translation),\n                )\n            )\n        return cart_symops\n\n    def symmetry_unique_dimers(self, radius=3.8, distance_method=\"nearest_atom\"):\n        \"\"\"\n        Calculate the information for all molecule\n        pairs surrounding the symmetry_unique_molecules\n        in this crystal within the given radius.\n\n        Args:\n            radius (float, optional): Maximum distance in Angstroms between any\n                atom in the molecule and the resulting neighbouring atoms\n\n        Returns:\n            A dictionary of dimers (Molecule, elements, positions)\n                where `elements` is an `np.ndarray` of atomic numbers,\n                and `positions` is an `np.ndarray` of Cartesian atomic positions\n        \"\"\"\n        from chmpy.core.dimer import Dimer\n\n        hklmax = np.array([-np.inf, -np.inf, -np.inf])\n        hklmin = np.array([np.inf, np.inf, np.inf])\n        frac_radius = radius * 2 / np.array(self.unit_cell.lengths)\n\n        for pos in self.asymmetric_unit.positions:\n            hklmax = np.maximum(hklmax, np.ceil(frac_radius + pos))\n            hklmin = np.minimum(hklmin, np.floor(pos - frac_radius))\n        hklmin = np.minimum(hklmin, (-1, -1, -1))\n        hklmax = np.maximum(hklmax, (1, 1, 1))\n\n        hmax, kmax, lmax = hklmax.astype(int)\n        hmin, kmin, lmin = hklmin.astype(int)\n\n        shifts_frac = cartesian_product(\n            np.arange(hmin, hmax), np.arange(kmin, kmax), np.arange(lmin, lmax)\n        )\n\n        shifts = self.to_cartesian(shifts_frac)\n        LOG.debug(\n            \"Looking in %d neighbouring cells: %s : %s\",\n            len(shifts),\n            hklmin.astype(int),\n            hklmax.astype(int),\n        )\n        unique_dimers = []\n        mol_dimers = []\n        for mol_a in self.symmetry_unique_molecules():\n            dimers_a = []\n            for mol_b in self.unit_cell_molecules():\n                for shift, shift_frac in zip(shifts, shifts_frac, strict=False):\n                    # shift_frac assumes the molecule is generated from\n                    # the [0, 0, 0] cell, it's not\n                    mol_bt = mol_b.translated(shift)\n                    r = mol_a.distance_to(mol_bt, method=distance_method)\n                    if r &gt; 1e-1 and r &lt; radius:\n                        d = Dimer(\n                            mol_a,\n                            mol_bt,\n                            separation=r,\n                            transform_ab=\"calculate\",\n                            frac_shift=shift_frac,\n                        )\n                        for i, dimer in enumerate(unique_dimers):\n                            if dimer.separation &lt;= d.separation + 1e-3:\n                                if d == dimer:\n                                    dimers_a.append((i, d))\n                                    break\n                        else:\n                            dimers_a.append((len(unique_dimers), d))\n                            unique_dimers.append(d)\n            mol_dimers.append(dimers_a)\n        return unique_dimers, mol_dimers\n\n    def nearest_neighbour_info(self, points, mol_idx=0, **kwargs):\n        from collections import namedtuple\n\n        from scipy.spatial import cKDTree as KDTree\n\n        Neighbor = namedtuple(\"Neighbor\", \"asym_id generator_symop ab_symop separation\")\n        unique_dimers, mol_dimers = self.symmetry_unique_dimers(**kwargs)\n        npos = []\n        nidx = []\n        dimers = mol_dimers[mol_idx]\n        neighbour_info = []\n\n        def symm_string(x):\n            return str(SymmetryOperation.from_integer_code(x[0]))\n\n        for i, (_unique_idx, d) in enumerate(dimers):\n            npos.append(d.b.positions)\n            nidx.append(np.ones(len(d.b), dtype=np.uint8) * i)\n            neighbour_info.append(\n                Neighbor(\n                    d.b.properties[\"asym_mol_idx\"],\n                    symm_string(d.b.properties[\"generator_symop\"]),\n                    d.symm_str,\n                    d.com_separation,\n                )\n            )\n        npos = np.vstack(npos)\n        nidx = np.hstack(nidx)\n        tree = KDTree(npos)\n        distances, idx = tree.query(points)\n        return neighbour_info, nidx[idx]\n\n    def normalize_hydrogen_bondlengths(self, bond_tolerance=0.4, **kwargs):\n        BONDLENGTHS = {\n            \"C\": 1.083,\n            \"N\": 1.009,\n            \"O\": 0.983,\n            \"B\": 1.180,\n        }\n        nums = self.asymmetric_unit.atomic_numbers\n        pos_cart = self.to_cartesian(self.asymmetric_unit.positions)\n        H_idxs = np.where(nums == 1)[0]\n        conn, t = self.unit_cell_connectivity(bond_tolerance=bond_tolerance, **kwargs)\n        for key in conn.keys():\n            for h in H_idxs:\n                if h in key:\n                    at = key[1 if key.index(h) == 0 else 0]\n                    conn[key]\n                    break\n            else:\n                continue\n            el = str(Element[nums[at]])\n            if el in BONDLENGTHS:\n                v_xh = pos_cart[h, :] - pos_cart[at, :]\n                norm = np.linalg.norm(v_xh)\n                v_xh = BONDLENGTHS[el] * v_xh / norm\n                pos_cart[h, :] = pos_cart[at, :] + v_xh\n        self.asymmetric_unit.positions = self.to_fractional(pos_cart)\n\n    def assign_atom_types(self, force_field=\"UFF\", **kwargs):\n        \"\"\"\n        Assign atom types and force field parameters to this crystal structure.\n\n        Args:\n            force_field (str or ForceFieldType): Force field to use for typing.\n                Options: \"UFF\", \"UFF4MOF\", \"DREIDING\", \"COMPASS\"\n            **kwargs: Additional arguments passed to the atom typing system\n\n        Returns:\n            dict: Dictionary with typing results containing:\n                - atom_types: mapping of atom indices to (ff_type, descriptor) tuples\n                - parameters: mapping of atom indices to ForceFieldParameters objects\n                - force_field: name of the force field used\n                - unique_types: set of unique atom types found\n\n        Example:\n            &gt;&gt;&gt; crystal = Crystal.load(\"MOF.cif\")\n            &gt;&gt;&gt; results = crystal.assign_atom_types(\"UFF\")\n            &gt;&gt;&gt; print(f\"Found {len(results['unique_types'])} unique atom types\")\n            &gt;&gt;&gt; for i, params in results[\"parameters\"].items():\n            ...     print(f\"Atom {i}: {params.ff_type} (\u03b5={params.epsilon:.3f})\")\n        \"\"\"\n        from chmpy.ff.params import ForceFieldType, type_crystal_structure\n\n        # Convert string to enum if needed\n        if isinstance(force_field, str):\n            ff_enum = ForceFieldType(force_field.upper())\n        else:\n            ff_enum = force_field\n\n        results = type_crystal_structure(self, ff_enum, **kwargs)\n\n        # Cache results on the crystal object for future access\n        self._atom_typing_results = results\n\n        return results\n\n    def get_atom_types(self, force_field=\"UFF\", use_cached=True, **kwargs):\n        \"\"\"\n        Get atom type assignments for this crystal structure.\n\n        Args:\n            force_field (str or ForceFieldType): Force field to use\n            use_cached (bool): Whether to use cached results if available\n            **kwargs: Additional arguments for atom typing\n\n        Returns:\n            dict: Mapping of atom indices to (force_field_type, AtomTypeDescriptor) tuples\n        \"\"\"\n        if use_cached and hasattr(self, \"_atom_typing_results\"):\n            cached_ff = self._atom_typing_results.get(\"force_field\", \"\").upper()\n            if cached_ff == str(force_field).upper():\n                return self._atom_typing_results[\"atom_types\"]\n\n        results = self.assign_atom_types(force_field, **kwargs)\n        return results[\"atom_types\"]\n\n    def get_ff_parameters(self, force_field=\"UFF\", use_cached=True, **kwargs):\n        \"\"\"\n        Get force field parameters for this crystal structure.\n\n        Args:\n            force_field (str or ForceFieldType): Force field to use\n            use_cached (bool): Whether to use cached results if available\n            **kwargs: Additional arguments for atom typing\n\n        Returns:\n            dict: Mapping of atom indices to ForceFieldParameters objects\n        \"\"\"\n        if use_cached and hasattr(self, \"_atom_typing_results\"):\n            cached_ff = self._atom_typing_results.get(\"force_field\", \"\").upper()\n            if cached_ff == str(force_field).upper():\n                return self._atom_typing_results[\"parameters\"]\n\n        results = self.assign_atom_types(force_field, **kwargs)\n        return results[\"parameters\"]\n\n    def get_unique_atom_types(self, force_field=\"UFF\", use_cached=True, **kwargs):\n        \"\"\"\n        Get the set of unique atom types in this crystal structure.\n\n        Args:\n            force_field (str or ForceFieldType): Force field to use\n            use_cached (bool): Whether to use cached results if available\n            **kwargs: Additional arguments for atom typing\n\n        Returns:\n            set: Set of unique force field atom type strings\n        \"\"\"\n        if use_cached and hasattr(self, \"_atom_typing_results\"):\n            cached_ff = self._atom_typing_results.get(\"force_field\", \"\").upper()\n            if cached_ff == str(force_field).upper():\n                return self._atom_typing_results[\"unique_types\"]\n\n        results = self.assign_atom_types(force_field, **kwargs)\n        return results[\"unique_types\"]\n\n    def get_lj_parameters_array(self, force_field=\"UFF\", use_cached=True, **kwargs):\n        \"\"\"\n        Get Lennard-Jones parameters as structured arrays for simulation input.\n\n        Args:\n            force_field (str or ForceFieldType): Force field to use\n            use_cached (bool): Whether to use cached results if available\n            **kwargs: Additional arguments for atom typing\n\n        Returns:\n            tuple: (atom_types_array, epsilon_array, sigma_array, mass_array, charges_array)\n                where each array is ordered by atom index\n        \"\"\"\n        parameters = self.get_ff_parameters(force_field, use_cached, **kwargs)\n        uc_atoms = self.unit_cell_atoms()\n        n_atoms = len(uc_atoms[\"element\"])\n\n        # Initialize arrays\n        atom_types = []\n        epsilons = np.zeros(n_atoms)\n        sigmas = np.zeros(n_atoms)\n        masses = np.zeros(n_atoms)\n        charges = np.zeros(n_atoms)\n\n        # Fill arrays in atom index order\n        for i in range(n_atoms):\n            if i in parameters:\n                params = parameters[i]\n                atom_types.append(params.ff_type)\n                epsilons[i] = params.epsilon\n                sigmas[i] = params.sigma\n                masses[i] = params.mass if params.mass is not None else 0.0\n                charges[i] = params.charge\n            else:\n                # Fallback for missing parameters\n                element = Element[uc_atoms[\"element\"][i]].symbol\n                atom_types.append(f\"{element}_generic\")\n                masses[i] = Element[uc_atoms[\"element\"][i]].mass\n\n        return atom_types, epsilons, sigmas, masses, charges\n\n    def export_lammps_data(self, filename, force_field=\"UFF\", **kwargs):\n        \"\"\"\n        Export crystal structure with atom types in LAMMPS data format.\n\n        Args:\n            filename (str): Output filename for LAMMPS data file\n            force_field (str or ForceFieldType): Force field to use\n            **kwargs: Additional arguments for atom typing and export\n\n        Note:\n            This is a placeholder - would need integration with LAMMPS export functionality\n        \"\"\"\n        results = self.assign_atom_types(force_field, **kwargs)\n        atom_types, epsilons, sigmas, masses, charges = self.get_lj_parameters_array(\n            force_field, **kwargs\n        )\n\n        # This would integrate with existing LAMMPS export functionality\n        # For now, just store the information\n        lammps_data = {\n            \"atom_types\": atom_types,\n            \"epsilons\": epsilons,\n            \"sigmas\": sigmas,\n            \"masses\": masses,\n            \"charges\": charges,\n            \"positions\": self.unit_cell_atoms()[\"cart_pos\"],\n            \"cell_parameters\": self.unit_cell.parameters,\n        }\n\n        print(f\"LAMMPS export functionality would write to {filename}\")\n        print(f\"Found {len(results['unique_types'])} unique atom types:\")\n        for atom_type in sorted(results[\"unique_types\"]):\n            count = atom_types.count(atom_type)\n            print(f\"  {atom_type}: {count} atoms\")\n\n        return lammps_data\n\n    def export_raspa_files(self, force_field=\"UFF\", output_dir=\".\", **kwargs):\n        \"\"\"\n        Export force field parameters in RASPA format.\n\n        Args:\n            force_field (str or ForceFieldType): Force field to use\n            output_dir (str): Directory to write RASPA files\n            **kwargs: Additional arguments for atom typing\n\n        Returns:\n            dict: Paths to created RASPA files\n        \"\"\"\n        from pathlib import Path\n\n        _ = self.assign_atom_types(force_field, **kwargs)\n        output_path = Path(output_dir)\n        output_path.mkdir(exist_ok=True)\n\n        # Get arrays for RASPA format\n        atom_types, epsilons, sigmas, masses, charges = self.get_lj_parameters_array(\n            force_field, **kwargs\n        )\n\n        # Create pseudo_atoms.def file\n        pseudo_atoms_file = output_path / \"pseudo_atoms.def\"\n        ff_mixing_file = output_path / \"force_field_mixing_rules.def\"\n\n        # Write pseudo_atoms.def\n        with open(pseudo_atoms_file, \"w\") as f:\n            f.write(\"# Pseudo atoms definition file\\n\")\n            f.write(f\"# Generated by chmpy for crystal: {self.titl}\\n\")\n            f.write(f\"# Force field: {force_field}\\n\\n\")\n\n            unique_params = {}\n            for i, ff_type in enumerate(atom_types):\n                if ff_type not in unique_params:\n                    unique_params[ff_type] = {\n                        \"epsilon\": epsilons[i],\n                        \"sigma\": sigmas[i],\n                        \"mass\": masses[i],\n                        \"charge\": charges[i],\n                        \"element\": Element[self.unit_cell_atoms()[\"element\"][i]].symbol,\n                    }\n\n            f.write(f\"{len(unique_params)}\\n\")\n            for ff_type, params in unique_params.items():\n                f.write(\n                    f\"{ff_type:12s} yes {params['element']:2s} {params['element']:2s} \"\n                )\n                f.write(f\"0 {params['mass']:8.3f} {params['charge']:8.3f} \")\n                f.write(f\"0.0 1.0 {params['sigma']:8.3f} 0 0 relative 0\\n\")\n\n        # Write force_field_mixing_rules.def\n        with open(ff_mixing_file, \"w\") as f:\n            f.write(\"# Force field mixing rules\\n\")\n            f.write(f\"# Generated by chmpy for crystal: {self.titl}\\n\")\n            f.write(f\"# Force field: {force_field}\\n\\n\")\n\n            f.write(\"# general rule for Lorentz-Berthelot mixing\\n\")\n            f.write(\"# LJ potential\\n\")\n            f.write(f\"{len(unique_params)}\\n\")\n\n            for ff_type, params in unique_params.items():\n                f.write(\n                    f\"{ff_type:12s} lennard-jones {params['epsilon']:10.6f} {params['sigma']:10.6f}\\n\"\n                )\n\n            f.write(\"# general mixing rule\\n\")\n            f.write(\"lorentz-berthelot\\n\")\n\n        return {\n            \"pseudo_atoms\": str(pseudo_atoms_file),\n            \"mixing_rules\": str(ff_mixing_file),\n        }\n\n    def atom_typing_summary(self, force_field=\"UFF\", **kwargs):\n        \"\"\"\n        Print a summary of atom typing results for this crystal.\n\n        Args:\n            force_field (str or ForceFieldType): Force field to use\n            **kwargs: Additional arguments for atom typing\n        \"\"\"\n        results = self.assign_atom_types(force_field, **kwargs)\n\n        print(f\"\\nAtom Typing Summary for {self.titl}\")\n        print(f\"Force Field: {results['force_field']}\")\n        print(f\"Total atoms: {len(results['atom_types'])}\")\n        print(f\"Unique types: {len(results['unique_types'])}\")\n        print(\"-\" * 50)\n\n        # Count atoms by type\n        type_counts = {}\n        for ff_type, _descriptor in results[\"atom_types\"].values():\n            type_counts[ff_type] = type_counts.get(ff_type, 0) + 1\n\n        # Print sorted by count\n        for ff_type, count in sorted(\n            type_counts.items(), key=lambda x: x[1], reverse=True\n        ):\n            # Get example parameters\n            example_params = None\n            for params in results[\"parameters\"].values():\n                if params.ff_type == ff_type:\n                    example_params = params\n                    break\n\n            if example_params:\n                print(\n                    f\"{ff_type:12s}: {count:3d} atoms  \"\n                    f\"(\u03b5={example_params.epsilon:6.3f}, \u03c3={example_params.sigma:6.3f})\"\n                )\n            else:\n                print(f\"{ff_type:12s}: {count:3d} atoms\")\n\n        print(\"-\" * 50)\n\n        # Show any special environments\n        special_envs = set()\n        for _ff_type, descriptor in results[\"atom_types\"].values():\n            if descriptor.special_environment:\n                special_envs.add(descriptor.special_environment)\n\n        if special_envs:\n            print(f\"Special environments detected: {', '.join(special_envs)}\")\n\n        print()\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.asym","title":"<code>asym</code>  <code>property</code>","text":"<p>short accessor for <code>asymmetric_unit</code></p>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.density","title":"<code>density</code>  <code>property</code>","text":"<p>Calculated density of this crystal structure in g/cm^3</p>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.id","title":"<code>id</code>  <code>property</code>","text":"<p>synonym for titl</p>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.name","title":"<code>name</code>  <code>property</code>","text":"<p>synonym for titl</p>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.nsites","title":"<code>nsites</code>  <code>property</code>","text":"<p>The number of sites in the asymmetric unit.</p>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.sg","title":"<code>sg</code>  <code>property</code>","text":"<p>short accessor for <code>space_group</code></p>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.site_atoms","title":"<code>site_atoms</code>  <code>property</code>","text":"<p>Array of asymmetric unit atomic numbers</p>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.site_labels","title":"<code>site_labels</code>  <code>property</code>","text":"<p>array of labels for sites in the <code>asymmetric_unit</code></p>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.site_positions","title":"<code>site_positions</code>  <code>property</code>","text":"<p>Row major array of asymmetric unit atomic positions</p>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.symmetry_operations","title":"<code>symmetry_operations</code>  <code>property</code>","text":"<p>Symmetry operations belonging to the space group symmetry of this crystal.</p>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.uc","title":"<code>uc</code>  <code>property</code>","text":"<p>short accessor for <code>unit_cell</code></p>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.__init__","title":"<code>__init__(unit_cell, space_group, asymmetric_unit, **kwargs)</code>","text":"<p>Construct a new crystal.</p> <p>Parameters:</p> Name Type Description Default <code>unit_cell</code> <code>UnitCell</code> <p>The unit cell for this crystal i.e. the translational symmetry of the crystal structure.</p> required <code>space_group</code> <code>SpaceGroup</code> <p>The space group symmetry of this crystal i.e. the generators for populating the unit cell given the asymmetric unit.</p> required <code>asymmetric_unit</code> <code>AsymmetricUnit</code> <p>The asymmetric unit of this crystal.  The sites of this combined with the space group will generate all  translationally equivalent positions.</p> required <code>**kwargs</code> <p>Optional properties to (will populate the properties member) store about the the crystal structure.</p> <code>{}</code> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def __init__(\n    self,\n    unit_cell: UnitCell,\n    space_group: SpaceGroup,\n    asymmetric_unit: AsymmetricUnit,\n    **kwargs,\n):\n    \"\"\"\n    Construct a new crystal.\n\n\n    Arguments:\n        unit_cell: The unit cell for this crystal i.e. the\n            translational symmetry of the crystal structure.\n        space_group: The space group symmetry of this crystal\n            i.e. the generators for populating the unit cell given the\n            asymmetric unit.\n        asymmetric_unit: The asymmetric unit of this crystal.\n             The sites of this combined with the space group will generate all\n             translationally equivalent positions.\n        **kwargs: Optional properties to (will populate the properties member) store\n            about the the crystal structure.\n    \"\"\"\n\n    self.space_group = space_group\n    self.unit_cell = unit_cell\n    self.asymmetric_unit = asymmetric_unit\n    self.properties = {}\n    self.properties.update(kwargs)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.as_P1","title":"<code>as_P1()</code>","text":"<p>Create a copy of this crystal in space group P 1, with the new asymmetric_unit consisting of self.unit_cell_molecules()</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def as_P1(self) -&gt; \"Crystal\":\n    \"\"\"Create a copy of this crystal in space group P 1, with the new\n    asymmetric_unit consisting of self.unit_cell_molecules()\"\"\"\n    return self.as_P1_supercell((1, 1, 1))\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.as_P1_supercell","title":"<code>as_P1_supercell(size)</code>","text":"<p>Create a supercell of this crystal in space group P 1.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>Tuple[int]</code> <p>size of the P 1 supercell to be created</p> required <p>Returns:</p> Type Description <code>Crystal</code> <p>Crystal object of a supercell in space group P 1</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def as_P1_supercell(self, size) -&gt; \"Crystal\":\n    \"\"\"\n    Create a supercell of this crystal in space group P 1.\n\n    Args:\n        size (Tuple[int]): size of the P 1 supercell to be created\n\n    Returns:\n        Crystal object of a supercell in space group P 1\n    \"\"\"\n    import itertools as it\n\n    umax, vmax, wmax = size\n    a, b, c = self.unit_cell.lengths\n    sc = UnitCell.from_lengths_and_angles(\n        (umax * a, vmax * b, wmax * c), self.unit_cell.angles\n    )\n\n    u = np.arange(umax)\n    v = np.arange(vmax)\n    w = np.arange(wmax)\n    sc_mols = []\n    for q, r, s in it.product(u, v, w):\n        for uc_mol in self.unit_cell_molecules():\n            sc_mols.append(\n                uc_mol.translated(np.asarray([q, r, s]) @ self.unit_cell.lattice)\n            )\n\n    asym_pos = np.vstack([x.positions for x in sc_mols])\n    asym_nums = np.hstack([x.atomic_numbers for x in sc_mols])\n    asymmetric_unit = AsymmetricUnit(\n        [Element[x] for x in asym_nums], sc.to_fractional(asym_pos)\n    )\n    new_crystal = Crystal(sc, SpaceGroup(1), asymmetric_unit)\n    new_crystal.properties[\"titl\"] = self.titl + \"-P1-{}-{}-{}\".format(*size)\n    return new_crystal\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.assign_atom_types","title":"<code>assign_atom_types(force_field='UFF', **kwargs)</code>","text":"<p>Assign atom types and force field parameters to this crystal structure.</p> <p>Parameters:</p> Name Type Description Default <code>force_field</code> <code>str or ForceFieldType</code> <p>Force field to use for typing. Options: \"UFF\", \"UFF4MOF\", \"DREIDING\", \"COMPASS\"</p> <code>'UFF'</code> <code>**kwargs</code> <p>Additional arguments passed to the atom typing system</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary with typing results containing: - atom_types: mapping of atom indices to (ff_type, descriptor) tuples - parameters: mapping of atom indices to ForceFieldParameters objects - force_field: name of the force field used - unique_types: set of unique atom types found</p> Example <p>crystal = Crystal.load(\"MOF.cif\") results = crystal.assign_atom_types(\"UFF\") print(f\"Found {len(results['unique_types'])} unique atom types\") for i, params in results[\"parameters\"].items(): ...     print(f\"Atom {i}: {params.ff_type} (\u03b5={params.epsilon:.3f})\")</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def assign_atom_types(self, force_field=\"UFF\", **kwargs):\n    \"\"\"\n    Assign atom types and force field parameters to this crystal structure.\n\n    Args:\n        force_field (str or ForceFieldType): Force field to use for typing.\n            Options: \"UFF\", \"UFF4MOF\", \"DREIDING\", \"COMPASS\"\n        **kwargs: Additional arguments passed to the atom typing system\n\n    Returns:\n        dict: Dictionary with typing results containing:\n            - atom_types: mapping of atom indices to (ff_type, descriptor) tuples\n            - parameters: mapping of atom indices to ForceFieldParameters objects\n            - force_field: name of the force field used\n            - unique_types: set of unique atom types found\n\n    Example:\n        &gt;&gt;&gt; crystal = Crystal.load(\"MOF.cif\")\n        &gt;&gt;&gt; results = crystal.assign_atom_types(\"UFF\")\n        &gt;&gt;&gt; print(f\"Found {len(results['unique_types'])} unique atom types\")\n        &gt;&gt;&gt; for i, params in results[\"parameters\"].items():\n        ...     print(f\"Atom {i}: {params.ff_type} (\u03b5={params.epsilon:.3f})\")\n    \"\"\"\n    from chmpy.ff.params import ForceFieldType, type_crystal_structure\n\n    # Convert string to enum if needed\n    if isinstance(force_field, str):\n        ff_enum = ForceFieldType(force_field.upper())\n    else:\n        ff_enum = force_field\n\n    results = type_crystal_structure(self, ff_enum, **kwargs)\n\n    # Cache results on the crystal object for future access\n    self._atom_typing_results = results\n\n    return results\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.asymmetric_unit_coordination_numbers","title":"<code>asymmetric_unit_coordination_numbers()</code>","text":"<p>Calculate the coordination numbers for the asymmetric unit of this crystal using the EEQ method with periodic boundary conditions.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>an <code>ndarray</code> of coordination numbers for the asymmetric unit atoms.</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def asymmetric_unit_coordination_numbers(self) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the coordination numbers for the asymmetric unit of this\n    crystal using the EEQ method with periodic boundary conditions.\n\n    Returns:\n        an `ndarray` of coordination numbers for the asymmetric unit atoms.\n    \"\"\"\n    if hasattr(self, \"_asymmetric_unit_coordination_numbers\"):\n        return self._asymmetric_unit_coordination_numbers\n\n    # Get unit cell coordination numbers\n    uc_cn = self.unit_cell_coordination_numbers()\n    uc_atoms = self.unit_cell_atoms()\n\n    # Map back to asymmetric unit\n    asym_cn = np.empty(len(self.asymmetric_unit), dtype=np.float32)\n    for i, cn in enumerate(uc_cn):\n        asym_idx = uc_atoms[\"asym_atom\"][i]\n        asym_cn[asym_idx] = cn\n\n    self._asymmetric_unit_coordination_numbers = asym_cn\n    return asym_cn\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.asymmetric_unit_partial_charges","title":"<code>asymmetric_unit_partial_charges(method='eeq')</code>","text":"<p>Calculate the partial charges for the asymmetric unit of this crystal using the specified method.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Charge method to use ('eeq' or 'eem')</p> <code>'eeq'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>an <code>ndarray</code> of atomic partial charges.</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def asymmetric_unit_partial_charges(self, method=\"eeq\") -&gt; np.ndarray:\n    \"\"\"\n    Calculate the partial charges for the asymmetric unit of this\n    crystal using the specified method.\n\n    Args:\n        method (str): Charge method to use ('eeq' or 'eem')\n\n    Returns:\n        an `ndarray` of atomic partial charges.\n    \"\"\"\n    if method.lower() == \"eeq\":\n        # Get unit cell charges using EEQ with PBC\n        uc_charges = self.unit_cell_partial_charges(method=\"eeq\")\n        uc_atoms = self.unit_cell_atoms()\n\n        # Map back to asymmetric unit\n        charges = np.empty(len(self.asymmetric_unit), dtype=np.float32)\n        for i, charge in enumerate(uc_charges):\n            asym_idx = uc_atoms[\"asym_atom\"][i]\n            charges[asym_idx] = charge\n\n        return charges\n    else:\n        # Use the molecular approach for other methods\n        mols = self.symmetry_unique_molecules()\n        charges = np.empty(len(self.asymmetric_unit), dtype=np.float32)\n\n        # Set charge method for molecules\n        for mol in mols:\n            mol.properties[\"charge_method\"] = method\n\n        for mol in mols:\n            for idx, charge in zip(\n                mol.properties[\"asymmetric_unit_atoms\"],\n                mol.partial_charges,\n                strict=False,\n            ):\n                charges[idx] = charge\n\n        return charges\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.atom_group_shape_descriptors","title":"<code>atom_group_shape_descriptors(atoms, l_max=5, radius=6.0)</code>","text":"<p>Calculate the shape descriptors[1,2] for the given atomic group in this crystal.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <code>Tuple</code> <p>atoms to include in the as the 'inside' of the shape description.</p> required <code>l_max</code> <code>int</code> <p>maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function.</p> <code>5</code> <code>radius</code> <code>float</code> <p>maximum distance (Angstroms) to include surroundings in the shape description</p> <code>6.0</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>shape description vector</p> <p>References: <pre><code>[1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n    https://dx.doi.org/10.1038/srep22204\n[2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n    https://dx.doi.org/10.1002/anie.201906602\n</code></pre></p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def atom_group_shape_descriptors(self, atoms, l_max=5, radius=6.0) -&gt; np.ndarray:\n    \"\"\"Calculate the shape descriptors[1,2] for the given atomic\n    group in this crystal.\n\n    Args:\n        atoms (Tuple): atoms to include in the as the 'inside'\n            of the shape description.\n        l_max (int, optional): maximum level of angular momenta to include\n            in the spherical harmonic transform of the molecular shape function.\n        radius (float, optional): maximum distance (Angstroms) to include\n            surroundings in the shape description\n\n    Returns:\n        shape description vector\n\n    References:\n    ```\n    [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n        https://dx.doi.org/10.1038/srep22204\n    [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n        https://dx.doi.org/10.1002/anie.201906602\n    ```\n    \"\"\"\n    from chmpy.shape import SHT, stockholder_weight_descriptor\n\n    sph = SHT(l_max)\n    inside, outside = self.atom_group_surroundings(atoms, radius=radius)\n    m = Molecule.from_arrays(*inside)\n    c = np.array(m.centroid, dtype=np.float32)\n    dists = np.linalg.norm(m.positions - c, axis=1)\n    bounds = np.min(dists) / 2, np.max(dists) + 10.0\n    return np.asarray(\n        stockholder_weight_descriptor(\n            sph, *inside, *outside, origin=c, bounds=bounds\n        )\n    )\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.atom_group_surroundings","title":"<code>atom_group_surroundings(atoms, radius=6.0)</code>","text":"<p>Calculate all atoms within the given <code>radius</code> of the specified group of atoms in the asymetric unit.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>the maximum distance (Angstroms) from the origin for inclusion</p> <code>6.0</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A list of atomic number, Cartesian position for both the</p> <code>tuple</code> <p>atomic sites in question and their surroundings (as an array)</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def atom_group_surroundings(self, atoms, radius=6.0) -&gt; tuple:\n    \"\"\"\n    Calculate all atoms within the given `radius` of the specified\n    group of atoms in the asymetric unit.\n\n    Arguments:\n        radius (float): the maximum distance (Angstroms) from the origin\n            for inclusion\n\n    Returns:\n        A list of atomic number, Cartesian position for both the\n        atomic sites in question and their surroundings (as an array)\n    \"\"\"\n    hklmax = np.array([-np.inf, -np.inf, -np.inf])\n    hklmin = np.array([np.inf, np.inf, np.inf])\n    frac_radius = radius / np.array(self.unit_cell.lengths)\n    mol = self.symmetry_unique_molecules()[0]\n    central_positions = self.to_fractional(mol.positions[atoms])\n    central_elements = mol.atomic_numbers[atoms]\n    central_cart_positions = mol.positions[atoms]\n\n    for pos in central_positions:\n        hklmax = np.maximum(hklmax, np.ceil(frac_radius + pos))\n        hklmin = np.minimum(hklmin, np.floor(pos - frac_radius))\n    hmax, kmax, lmax = hklmax.astype(int)\n    hmin, kmin, lmin = hklmin.astype(int)\n    slab = self.slab(bounds=((hmin, kmin, lmin), (hmax, kmax, lmax)))\n    elements = slab[\"element\"]\n    positions = slab[\"cart_pos\"]\n    tree = KDTree(positions)\n    keep = np.zeros(positions.shape[0], dtype=bool)\n\n    this_mol = []\n    for pos in central_cart_positions:\n        idxs = tree.query_ball_point(pos, radius)\n        d, nn = tree.query(pos)\n        keep[idxs] = True\n        if d &lt; 1e-3:\n            this_mol.append(nn)\n            keep[this_mol] = False\n    return (\n        (central_elements, central_cart_positions),\n        (elements[keep], positions[keep]),\n    )\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.atom_typing_summary","title":"<code>atom_typing_summary(force_field='UFF', **kwargs)</code>","text":"<p>Print a summary of atom typing results for this crystal.</p> <p>Parameters:</p> Name Type Description Default <code>force_field</code> <code>str or ForceFieldType</code> <p>Force field to use</p> <code>'UFF'</code> <code>**kwargs</code> <p>Additional arguments for atom typing</p> <code>{}</code> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def atom_typing_summary(self, force_field=\"UFF\", **kwargs):\n    \"\"\"\n    Print a summary of atom typing results for this crystal.\n\n    Args:\n        force_field (str or ForceFieldType): Force field to use\n        **kwargs: Additional arguments for atom typing\n    \"\"\"\n    results = self.assign_atom_types(force_field, **kwargs)\n\n    print(f\"\\nAtom Typing Summary for {self.titl}\")\n    print(f\"Force Field: {results['force_field']}\")\n    print(f\"Total atoms: {len(results['atom_types'])}\")\n    print(f\"Unique types: {len(results['unique_types'])}\")\n    print(\"-\" * 50)\n\n    # Count atoms by type\n    type_counts = {}\n    for ff_type, _descriptor in results[\"atom_types\"].values():\n        type_counts[ff_type] = type_counts.get(ff_type, 0) + 1\n\n    # Print sorted by count\n    for ff_type, count in sorted(\n        type_counts.items(), key=lambda x: x[1], reverse=True\n    ):\n        # Get example parameters\n        example_params = None\n        for params in results[\"parameters\"].values():\n            if params.ff_type == ff_type:\n                example_params = params\n                break\n\n        if example_params:\n            print(\n                f\"{ff_type:12s}: {count:3d} atoms  \"\n                f\"(\u03b5={example_params.epsilon:6.3f}, \u03c3={example_params.sigma:6.3f})\"\n            )\n        else:\n            print(f\"{ff_type:12s}: {count:3d} atoms\")\n\n    print(\"-\" * 50)\n\n    # Show any special environments\n    special_envs = set()\n    for _ff_type, descriptor in results[\"atom_types\"].values():\n        if descriptor.special_environment:\n            special_envs.add(descriptor.special_environment)\n\n    if special_envs:\n        print(f\"Special environments detected: {', '.join(special_envs)}\")\n\n    print()\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.atomic_shape_descriptors","title":"<code>atomic_shape_descriptors(l_max=5, radius=6.0, return_coefficients=False, with_property=None)</code>","text":"<p>Calculate the shape descriptors[1,2] for all symmetry unique atoms in this crystal.</p> <p>Parameters:</p> Name Type Description Default <code>l_max</code> <code>int</code> <p>maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function.</p> <code>5</code> <code>radius</code> <code>float</code> <p>maximum distance (Angstroms) to include surroundings in the shape description</p> <code>6.0</code> <code>with_property</code> <code>str</code> <p>name of the surface property to include in the shape description</p> <code>None</code> <code>return_coefficients</code> <code>bool</code> <p>also return the spherical harmonic coefficients</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>shape description vector</p> <p>References: <pre><code>[1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n    https://dx.doi.org/10.1038/srep22204\n[2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n    https://dx.doi.org/10.1002/anie.201906602\n</code></pre></p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def atomic_shape_descriptors(\n    self, l_max=5, radius=6.0, return_coefficients=False, with_property=None\n) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the shape descriptors[1,2] for all symmetry unique\n    atoms in this crystal.\n\n    Args:\n        l_max (int, optional): maximum level of angular momenta to include\n            in the spherical harmonic transform of the molecular shape function.\n        radius (float, optional): maximum distance (Angstroms) to include\n            surroundings in the shape description\n        with_property (str, optional): name of the surface property to include\n            in the shape description\n        return_coefficients (bool, optional): also return the spherical\n            harmonic coefficients\n\n    Returns:\n        shape description vector\n\n    References:\n    ```\n    [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n        https://dx.doi.org/10.1038/srep22204\n    [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n        https://dx.doi.org/10.1002/anie.201906602\n    ```\n    \"\"\"\n    descriptors = []\n    coeffs = []\n    from chmpy.shape import SHT, stockholder_weight_descriptor\n\n    sph = SHT(l_max)\n    for surrounds in self.atomic_surroundings(radius=radius):\n        n = surrounds[\"centre\"][\"element\"]\n        pos = surrounds[\"centre\"][\"cart_pos\"]\n        neighbour_els = surrounds[\"neighbours\"][\"element\"]\n        neighbour_pos = surrounds[\"neighbours\"][\"cart_pos\"]\n\n        ubound = Element[n].vdw_radius * 3 + 2.0\n        desc = stockholder_weight_descriptor(\n            sph,\n            [n],\n            [pos],\n            neighbour_els,\n            neighbour_pos,\n            bounds=(0.15, ubound),\n            coefficients=return_coefficients,\n            with_property=with_property,\n        )\n        if return_coefficients:\n            descriptors.append(desc[1])\n            coeffs.append(desc[0])\n        else:\n            descriptors.append(desc)\n    if return_coefficients:\n        return np.asarray(coeffs), np.asarray(descriptors)\n    else:\n        return np.asarray(descriptors)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.atomic_surroundings","title":"<code>atomic_surroundings(radius=6.0)</code>","text":"<p>Calculate all atoms within the given <code>radius</code> of each atomic site in the asymmetric unit.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>the maximum distance (Angstroms) from the origin for inclusion</p> <code>6.0</code> <p>Returns:</p> Type Description <code>list[dict]</code> <p>A list of atomic number, Cartesian position for both the</p> <code>list[dict]</code> <p>atomic site in question and the surroundings (as an array)</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def atomic_surroundings(self, radius=6.0) -&gt; list[dict]:\n    \"\"\"\n    Calculate all atoms within the given `radius` of\n    each atomic site in the asymmetric unit.\n\n    Arguments:\n        radius (float): the maximum distance (Angstroms) from the origin\n            for inclusion\n\n    Returns:\n        A list of atomic number, Cartesian position for both the\n        atomic site in question and the surroundings (as an array)\n    \"\"\"\n    cart_asym = self.to_cartesian(self.asymmetric_unit.positions)\n    hklmax = np.array([-np.inf, -np.inf, -np.inf])\n    hklmin = np.array([np.inf, np.inf, np.inf])\n    frac_radius = radius / np.array(self.unit_cell.lengths)\n    for pos in self.asymmetric_unit.positions:\n        hklmax = np.maximum(hklmax, np.ceil(frac_radius + pos))\n        hklmin = np.minimum(hklmin, np.floor(pos - frac_radius))\n    hmax, kmax, lmax = hklmax.astype(int)\n    hmin, kmin, lmin = hklmin.astype(int)\n    slab = self.slab(bounds=((hmin, kmin, lmin), (hmax, kmax, lmax)))\n    tree = KDTree(slab[\"cart_pos\"])\n    results = []\n    for i, (n, pos) in enumerate(\n        zip(self.asymmetric_unit.elements, cart_asym, strict=False)\n    ):\n        idxs = tree.query_ball_point(pos, radius)\n        positions = slab[\"cart_pos\"][idxs]\n        elements = slab[\"element\"][idxs]\n        asym = slab[\"asym_atom\"][idxs]\n        d = np.linalg.norm(positions - pos, axis=1)\n        keep = np.where(d &gt; 1e-3)[0]\n        results.append(\n            {\n                \"centre\": {\n                    \"element\": n.atomic_number,\n                    \"cart_pos\": pos,\n                    \"asym_atom\": i,\n                },\n                \"neighbours\": {\n                    \"element\": elements[keep],\n                    \"cart_pos\": positions[keep],\n                    \"distance\": d[keep],\n                    \"asym_atom\": asym[keep],\n                },\n            }\n        )\n    return results\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.atoms_in_radius","title":"<code>atoms_in_radius(radius, origin=(0, 0, 0))</code>","text":"<p>Calculate all (periodic) atoms within the given <code>radius</code> of the specified <code>origin</code>.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>the maximum distance (Angstroms) from the origin for inclusion</p> required <code>origin</code> <code>Tuple</code> <p>the origin in fractional coordinates</p> <code>(0, 0, 0)</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary mapping (see the the <code>slab</code> method),</p> <code>dict</code> <p>of those atoms within <code>radius</code> of the <code>origin</code>.</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def atoms_in_radius(self, radius, origin=(0, 0, 0)) -&gt; dict:\n    \"\"\"\n    Calculate all (periodic) atoms within the given `radius` of the specified\n    `origin`.\n\n    Arguments:\n        radius (float): the maximum distance (Angstroms) from the origin\n            for inclusion\n        origin (Tuple, optional): the origin in fractional coordinates\n\n    Returns:\n        A dictionary mapping (see the the `slab` method),\n        of those atoms within `radius` of the `origin`.\n    \"\"\"\n    frac_origin = self.to_fractional(origin)\n    frac_radius = radius / np.array(self.unit_cell.lengths)\n    hmax, kmax, lmax = np.ceil(frac_radius + frac_origin).astype(int)\n    hmin, kmin, lmin = np.floor(frac_origin - frac_radius).astype(int)\n    slab = self.slab(bounds=((hmin, kmin, lmin), (hmax, kmax, lmax)))\n    tree = KDTree(slab[\"cart_pos\"])\n    idxs = sorted(tree.query_ball_point(origin, radius))\n    result = {k: v[idxs] for k, v in slab.items() if isinstance(v, np.ndarray)}\n    result[\"uc_atom\"] = np.tile(np.arange(slab[\"n_uc\"]), slab[\"n_cells\"])[idxs]\n    return result\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.cartesian_symmetry_operations","title":"<code>cartesian_symmetry_operations()</code>","text":"<p>Create a list of symmetry operations (rotation, translation) for evaluation of transformations in cartesian space.</p> <p>The rotation matrices are stored to be used as np.dot(x, R), (i.e. post-multiplicaiton on row-major coordinates)</p> <p>Returns:</p> Type Description <p>List[Tuple[np.ndarray, np.ndarray]]: a list of (rotation, translation)</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def cartesian_symmetry_operations(self):\n    \"\"\"\n    Create a list of symmetry operations (rotation, translation)\n    for evaluation of transformations in cartesian space.\n\n    The rotation matrices are stored to be used as np.dot(x, R),\n    (i.e. post-multiplicaiton on row-major coordinates)\n\n    Returns:\n        List[Tuple[np.ndarray, np.ndarray]]: a list of (rotation, translation)\n    \"\"\"\n    cart_symops = []\n    d = self.unit_cell.direct\n    i = self.unit_cell.inverse\n    for symop in self.symmetry_operations:\n        cart_symops.append(\n            (\n                np.dot(d.T, np.dot(symop.rotation, i.T)).T,\n                self.to_cartesian(symop.translation),\n            )\n        )\n    return cart_symops\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.choose_trigonal_lattice","title":"<code>choose_trigonal_lattice(choice='H')</code>","text":"<p>Change the choice of lattice for this crystal to either rhombohedral or hexagonal cell</p> <p>Parameters:</p> Name Type Description Default <code>choice</code> <code>str</code> <p>The choice of the resulting lattice, either 'H' for hexagonal or 'R' for rhombohedral (default 'H').</p> <code>'H'</code> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def choose_trigonal_lattice(self, choice=\"H\"):\n    \"\"\"\n    Change the choice of lattice for this crystal to either\n    rhombohedral or hexagonal cell\n\n    Args:\n        choice (str, optional): The choice of the resulting lattice,\n            either 'H' for hexagonal or 'R' for rhombohedral (default 'H').\n    \"\"\"\n    if not self.space_group.has_hexagonal_rhombohedral_choices():\n        raise ValueError(\"Invalid space group for choose_trigonal_lattice\")\n    if self.space_group.choice == choice:\n        return\n    cart_asym_pos = self.to_cartesian(self.asymmetric_unit.positions)\n    assert choice in (\"H\", \"R\"), \"Valid choices are H, R\"\n    if self.space_group.choice == \"R\":\n        T = np.array(((-1, 1, 0), (1, 0, -1), (1, 1, 1)))\n    else:\n        T = 1 / 3 * np.array(((-1, 1, 1), (2, 1, 1), (-1, -2, 1)))\n    new_uc = UnitCell(np.dot(T, self.unit_cell.direct))\n    self.unit_cell = new_uc\n    self.asymmetric_unit.positions = self.to_fractional(cart_asym_pos)\n    self.space_group = SpaceGroup(\n        self.space_group.international_tables_number, choice=choice\n    )\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.export_lammps_data","title":"<code>export_lammps_data(filename, force_field='UFF', **kwargs)</code>","text":"<p>Export crystal structure with atom types in LAMMPS data format.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Output filename for LAMMPS data file</p> required <code>force_field</code> <code>str or ForceFieldType</code> <p>Force field to use</p> <code>'UFF'</code> <code>**kwargs</code> <p>Additional arguments for atom typing and export</p> <code>{}</code> Note <p>This is a placeholder - would need integration with LAMMPS export functionality</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def export_lammps_data(self, filename, force_field=\"UFF\", **kwargs):\n    \"\"\"\n    Export crystal structure with atom types in LAMMPS data format.\n\n    Args:\n        filename (str): Output filename for LAMMPS data file\n        force_field (str or ForceFieldType): Force field to use\n        **kwargs: Additional arguments for atom typing and export\n\n    Note:\n        This is a placeholder - would need integration with LAMMPS export functionality\n    \"\"\"\n    results = self.assign_atom_types(force_field, **kwargs)\n    atom_types, epsilons, sigmas, masses, charges = self.get_lj_parameters_array(\n        force_field, **kwargs\n    )\n\n    # This would integrate with existing LAMMPS export functionality\n    # For now, just store the information\n    lammps_data = {\n        \"atom_types\": atom_types,\n        \"epsilons\": epsilons,\n        \"sigmas\": sigmas,\n        \"masses\": masses,\n        \"charges\": charges,\n        \"positions\": self.unit_cell_atoms()[\"cart_pos\"],\n        \"cell_parameters\": self.unit_cell.parameters,\n    }\n\n    print(f\"LAMMPS export functionality would write to {filename}\")\n    print(f\"Found {len(results['unique_types'])} unique atom types:\")\n    for atom_type in sorted(results[\"unique_types\"]):\n        count = atom_types.count(atom_type)\n        print(f\"  {atom_type}: {count} atoms\")\n\n    return lammps_data\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.export_raspa_files","title":"<code>export_raspa_files(force_field='UFF', output_dir='.', **kwargs)</code>","text":"<p>Export force field parameters in RASPA format.</p> <p>Parameters:</p> Name Type Description Default <code>force_field</code> <code>str or ForceFieldType</code> <p>Force field to use</p> <code>'UFF'</code> <code>output_dir</code> <code>str</code> <p>Directory to write RASPA files</p> <code>'.'</code> <code>**kwargs</code> <p>Additional arguments for atom typing</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Paths to created RASPA files</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def export_raspa_files(self, force_field=\"UFF\", output_dir=\".\", **kwargs):\n    \"\"\"\n    Export force field parameters in RASPA format.\n\n    Args:\n        force_field (str or ForceFieldType): Force field to use\n        output_dir (str): Directory to write RASPA files\n        **kwargs: Additional arguments for atom typing\n\n    Returns:\n        dict: Paths to created RASPA files\n    \"\"\"\n    from pathlib import Path\n\n    _ = self.assign_atom_types(force_field, **kwargs)\n    output_path = Path(output_dir)\n    output_path.mkdir(exist_ok=True)\n\n    # Get arrays for RASPA format\n    atom_types, epsilons, sigmas, masses, charges = self.get_lj_parameters_array(\n        force_field, **kwargs\n    )\n\n    # Create pseudo_atoms.def file\n    pseudo_atoms_file = output_path / \"pseudo_atoms.def\"\n    ff_mixing_file = output_path / \"force_field_mixing_rules.def\"\n\n    # Write pseudo_atoms.def\n    with open(pseudo_atoms_file, \"w\") as f:\n        f.write(\"# Pseudo atoms definition file\\n\")\n        f.write(f\"# Generated by chmpy for crystal: {self.titl}\\n\")\n        f.write(f\"# Force field: {force_field}\\n\\n\")\n\n        unique_params = {}\n        for i, ff_type in enumerate(atom_types):\n            if ff_type not in unique_params:\n                unique_params[ff_type] = {\n                    \"epsilon\": epsilons[i],\n                    \"sigma\": sigmas[i],\n                    \"mass\": masses[i],\n                    \"charge\": charges[i],\n                    \"element\": Element[self.unit_cell_atoms()[\"element\"][i]].symbol,\n                }\n\n        f.write(f\"{len(unique_params)}\\n\")\n        for ff_type, params in unique_params.items():\n            f.write(\n                f\"{ff_type:12s} yes {params['element']:2s} {params['element']:2s} \"\n            )\n            f.write(f\"0 {params['mass']:8.3f} {params['charge']:8.3f} \")\n            f.write(f\"0.0 1.0 {params['sigma']:8.3f} 0 0 relative 0\\n\")\n\n    # Write force_field_mixing_rules.def\n    with open(ff_mixing_file, \"w\") as f:\n        f.write(\"# Force field mixing rules\\n\")\n        f.write(f\"# Generated by chmpy for crystal: {self.titl}\\n\")\n        f.write(f\"# Force field: {force_field}\\n\\n\")\n\n        f.write(\"# general rule for Lorentz-Berthelot mixing\\n\")\n        f.write(\"# LJ potential\\n\")\n        f.write(f\"{len(unique_params)}\\n\")\n\n        for ff_type, params in unique_params.items():\n            f.write(\n                f\"{ff_type:12s} lennard-jones {params['epsilon']:10.6f} {params['sigma']:10.6f}\\n\"\n            )\n\n        f.write(\"# general mixing rule\\n\")\n        f.write(\"lorentz-berthelot\\n\")\n\n    return {\n        \"pseudo_atoms\": str(pseudo_atoms_file),\n        \"mixing_rules\": str(ff_mixing_file),\n    }\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.from_cif_data","title":"<code>from_cif_data(cif_data, titl=None)</code>  <code>classmethod</code>","text":"<p>Initialize a crystal structure from a dictionary of CIF data</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>@classmethod\ndef from_cif_data(cls, cif_data, titl=None):\n    \"\"\"Initialize a crystal structure from a dictionary\n    of CIF data\"\"\"\n    labels = cif_data.get(\"atom_site_label\", None)\n    symbols = cif_data.get(\"atom_site_type_symbol\", None)\n    if symbols is None:\n        if labels is None:\n            raise ValueError(\n                \"Unable to determine elements in CIF, \"\n                \"need one of _atom_site_label or \"\n                \"_atom_site_type_symbol present\"\n            )\n        elements = [Element[x] for x in labels]\n    else:\n        elements = [Element[x] for x in symbols]\n    x = np.asarray(cif_data.get(\"atom_site_fract_x\", []))\n    y = np.asarray(cif_data.get(\"atom_site_fract_y\", []))\n    z = np.asarray(cif_data.get(\"atom_site_fract_z\", []))\n    occupation = np.asarray(cif_data.get(\"atom_site_occupancy\", [1] * len(x)))\n    frac_pos = np.array([x, y, z]).T\n    asym = AsymmetricUnit(\n        elements=elements, positions=frac_pos, labels=labels, occupation=occupation\n    )\n    lengths = [cif_data[f\"cell_length_{x}\"] for x in (\"a\", \"b\", \"c\")]\n    angles = [cif_data[f\"cell_angle_{x}\"] for x in (\"alpha\", \"beta\", \"gamma\")]\n    unit_cell = UnitCell.from_lengths_and_angles(lengths, angles, unit=\"degrees\")\n\n    space_group = SpaceGroup(1)\n    symop_data_names = (\n        \"symmetry_equiv_pos_as_xyz\",\n        \"space_group_symop_operation_xyz\",\n    )\n    number = space_group.international_tables_number\n    for k in (\"space_group_IT_number\", \"symmetry_Int_Tables_number\"):\n        if k in cif_data:\n            number = cif_data[k]\n            break\n\n    # Try to parse the Hermann-Mauguin symbol first\n    hm_parsed = False\n    hm_symbol = cif_data.get(\"symmetry_space_group_name_H-M\", \"\").strip()\n    if hm_symbol:\n        try:\n            # Convert CIF Hermann-Mauguin notation to correct SpaceGroup\n            space_group = cls._parse_hermann_mauguin_symbol(hm_symbol, number)\n            hm_parsed = True\n        except (ValueError, KeyError):\n            # Fall back to symmetry operations if HM symbol parsing fails\n            pass\n\n    # Only try symmetry operations if HM parsing failed\n    if not hm_parsed:\n        for symop_data_block in symop_data_names:\n            if symop_data_block in cif_data:\n                symops = [\n                    SymmetryOperation.from_string_code(x)\n                    for x in cif_data[symop_data_block]\n                ]\n                try:\n                    new_sg = SpaceGroup.from_symmetry_operations(symops)\n                    space_group = new_sg\n                except ValueError:\n                    space_group.symmetry_operations = symops\n                    symbol = cif_data.get(\n                        \"symmetry_space_group_name_H-M\", \"Unknown\"\n                    )\n                    space_group.international_tables_number = number\n                    space_group.symbol = symbol\n                    space_group.full_symbol = symbol\n                    LOG.warn(\n                        \"Initializing non-standard spacegroup setting %s, \"\n                        \"some SG data may be missing\",\n                        symbol,\n                    )\n                break\n        else:\n            # fall back to international tables number\n            space_group = SpaceGroup(number)\n\n    return Crystal(unit_cell, space_group, asym, cif_data=cif_data, titl=titl)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.from_cif_file","title":"<code>from_cif_file(filename, data_block_name=None)</code>  <code>classmethod</code>","text":"<p>Initialize a crystal structure from a CIF file</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>@classmethod\ndef from_cif_file(cls, filename, data_block_name=None):\n    \"\"\"Initialize a crystal structure from a CIF file\"\"\"\n    cif = Cif.from_file(filename)\n    if data_block_name is not None:\n        return cls.from_cif_data(cif.data[data_block_name], titl=data_block_name)\n\n    crystals = {\n        name: cls.from_cif_data(data, titl=name) for name, data in cif.data.items()\n    }\n    keys = list(crystals.keys())\n    if len(keys) == 1:\n        return crystals[keys[0]]\n    return crystals\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.from_shelx_file","title":"<code>from_shelx_file(filename, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize a crystal structure from a shelx .res file</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>@classmethod\ndef from_shelx_file(cls, filename, **kwargs):\n    \"\"\"Initialize a crystal structure from a shelx .res file\"\"\"\n    p = Path(filename)\n    titl = p.stem\n    return cls.from_shelx_string(p.read_text(), titl=titl, **kwargs)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.from_shelx_string","title":"<code>from_shelx_string(file_content, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize a crystal structure from a shelx .res string</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>@classmethod\ndef from_shelx_string(cls, file_content, **kwargs):\n    \"\"\"Initialize a crystal structure from a shelx .res string\"\"\"\n    from chmpy.fmt.shelx import parse_shelx_file_content\n\n    shelx_dict = parse_shelx_file_content(file_content)\n    asymmetric_unit = AsymmetricUnit.from_records(shelx_dict[\"ATOM\"])\n    space_group = SpaceGroup.from_symmetry_operations(\n        shelx_dict[\"SYMM\"], expand_latt=shelx_dict[\"LATT\"]\n    )\n    unit_cell = UnitCell.from_lengths_and_angles(\n        shelx_dict[\"CELL\"][\"lengths\"], shelx_dict[\"CELL\"][\"angles\"], unit=\"degrees\"\n    )\n    return cls(unit_cell, space_group, asymmetric_unit, **kwargs)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.from_vasp_file","title":"<code>from_vasp_file(filename, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize a crystal structure from a VASP POSCAR file</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>@classmethod\ndef from_vasp_file(cls, filename, **kwargs):\n    \"Initialize a crystal structure from a VASP POSCAR file\"\n    return cls.from_vasp_string(Path(filename).read_text(), **kwargs)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.from_vasp_string","title":"<code>from_vasp_string(string, **kwargs)</code>  <code>classmethod</code>","text":"<p>Initialize a crystal structure from a VASP POSCAR string</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>@classmethod\ndef from_vasp_string(cls, string, **kwargs):\n    \"Initialize a crystal structure from a VASP POSCAR string\"\n    from chmpy.fmt.vasp import parse_poscar\n\n    vasp_data = parse_poscar(string)\n    uc = UnitCell(vasp_data[\"direct\"])\n    sg = SpaceGroup(1)\n    coords = vasp_data[\"positions\"]\n    if not vasp_data[\"coord_type\"].startswith(\"d\"):\n        coords = uc.to_fractional(coords)\n    asym = AsymmetricUnit(vasp_data[\"elements\"], coords)\n    return Crystal(uc, sg, asym, titl=vasp_data[\"name\"])\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.functional_group_shape_descriptors","title":"<code>functional_group_shape_descriptors(l_max=5, radius=6.0, kind='carboxylic_acid')</code>","text":"<p>Calculate the shape descriptors <code>[1,2]</code> for the all atoms in the functional group given for all symmetry unique molecules in this crystal.</p> <p>Parameters:</p> Name Type Description Default <code>l_max</code> <code>int</code> <p>maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function. (default: 5)</p> <code>5</code> <code>radius</code> <code>float</code> <p>maximum distance (Angstroms) of neighbouring atoms to include in stockholder weight calculation (default: 5)</p> <code>6.0</code> <code>kind</code> <code>str</code> <p>Identifier for the functional group type (default: 'carboxylic_acid')</p> <code>'carboxylic_acid'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>shape description vector</p> <p>References: <pre><code>[1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n    https://dx.doi.org/10.1038/srep22204\n[2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n    https://dx.doi.org/10.1002/anie.201906602\n</code></pre></p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def functional_group_shape_descriptors(\n    self, l_max=5, radius=6.0, kind=\"carboxylic_acid\"\n) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the shape descriptors `[1,2]` for the all atoms in\n    the functional group given for all symmetry unique molecules in this crystal.\n\n    Args:\n        l_max (int, optional): maximum level of angular momenta to include\n            in the spherical harmonic transform of the molecular shape function.\n            (default: 5)\n        radius (float, optional): maximum distance (Angstroms) of neighbouring\n            atoms to include in stockholder weight calculation (default: 5)\n        kind (str, optional): Identifier for the functional group\n            type (default: 'carboxylic_acid')\n\n    Returns:\n        shape description vector\n\n    References:\n    ```\n    [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n        https://dx.doi.org/10.1038/srep22204\n    [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n        https://dx.doi.org/10.1002/anie.201906602\n    ```\n    \"\"\"\n    descriptors = []\n    from chmpy.shape import SHT, stockholder_weight_descriptor\n\n    sph = SHT(l_max)\n    for (\n        in_els,\n        in_pos,\n        neighbour_els,\n        neighbour_pos,\n    ) in self.functional_group_surroundings(kind=kind, radius=radius):\n        masses = np.asarray([Element[x].mass for x in in_els])\n        c = np.sum(in_pos * masses[:, np.newaxis] / np.sum(masses), axis=0).astype(\n            np.float32\n        )\n        dists = np.linalg.norm(in_pos - c, axis=1)\n        bounds = np.min(dists) / 2, np.max(dists) + 10.0\n        descriptors.append(\n            stockholder_weight_descriptor(\n                sph,\n                in_els,\n                in_pos,\n                neighbour_els,\n                neighbour_pos,\n                origin=c,\n                bounds=bounds,\n            )\n        )\n    return np.asarray(descriptors)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.functional_group_surroundings","title":"<code>functional_group_surroundings(radius=6.0, kind='carboxylic_acid')</code>","text":"<p>Calculate the atomic information for all atoms surrounding each functional group in each symmetry unique molecule in this crystal within the given radius.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms</p> <code>6.0</code> <code>kind</code> <code>str</code> <p>the functional group type</p> <code>'carboxylic_acid'</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of tuples of (func_el, func_pos, neigh_el, neigh_pos)</p> <code>list</code> <p>where <code>func_el</code> and <code>neigh_el</code> are <code>np.ndarray</code> of atomic numbers,</p> <code>list</code> <p>and <code>func_pos</code> and <code>neigh_pos</code> are <code>np.ndarray</code> of</p> <code>list</code> <p>Cartesian atomic positions</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def functional_group_surroundings(self, radius=6.0, kind=\"carboxylic_acid\") -&gt; list:\n    \"\"\"\n    Calculate the atomic information for all\n    atoms surrounding each functional group in each symmetry unique molecule\n    in this crystal within the given radius.\n\n    Args:\n        radius (float, optional): Maximum distance in Angstroms between\n            any atom in the molecule and the resulting neighbouring atoms\n        kind (str, optional): the functional group type\n\n    Returns:\n        A list of tuples of (func_el, func_pos, neigh_el, neigh_pos)\n        where `func_el` and `neigh_el` are `np.ndarray` of atomic numbers,\n        and `func_pos` and `neigh_pos` are `np.ndarray` of\n        Cartesian atomic positions\n    \"\"\"\n    results = []\n    for mol in self.symmetry_unique_molecules():\n        hklmax = np.array([-np.inf, -np.inf, -np.inf])\n        hklmin = np.array([np.inf, np.inf, np.inf])\n        frac_radius = radius / np.array(self.unit_cell.lengths)\n        for pos in self.to_fractional(mol.positions):\n            hklmax = np.maximum(hklmax, np.ceil(frac_radius + pos))\n            hklmin = np.minimum(hklmin, np.floor(pos - frac_radius))\n        hmax, kmax, lmax = hklmax.astype(int)\n        hmin, kmin, lmin = hklmin.astype(int)\n        slab = self.slab(bounds=((hmin, kmin, lmin), (hmax, kmax, lmax)))\n        elements = slab[\"element\"]\n        positions = slab[\"cart_pos\"]\n        tree = KDTree(positions)\n        groups = mol.functional_groups(kind=kind)\n        for fg in groups:\n            fg = list(fg)\n            keep = np.zeros(positions.shape[0], dtype=bool)\n            inside = []\n            for pos in mol.positions[fg]:\n                idxs = tree.query_ball_point(pos, radius)\n                d, nn = tree.query(pos)\n                keep[idxs] = True\n                if d &lt; 1e-3:\n                    inside.append(nn)\n                    keep[inside] = False\n            results.append(\n                (\n                    mol.atomic_numbers[fg],\n                    mol.positions[fg],\n                    elements[keep],\n                    positions[keep],\n                )\n            )\n    return results\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.get_atom_types","title":"<code>get_atom_types(force_field='UFF', use_cached=True, **kwargs)</code>","text":"<p>Get atom type assignments for this crystal structure.</p> <p>Parameters:</p> Name Type Description Default <code>force_field</code> <code>str or ForceFieldType</code> <p>Force field to use</p> <code>'UFF'</code> <code>use_cached</code> <code>bool</code> <p>Whether to use cached results if available</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments for atom typing</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Mapping of atom indices to (force_field_type, AtomTypeDescriptor) tuples</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def get_atom_types(self, force_field=\"UFF\", use_cached=True, **kwargs):\n    \"\"\"\n    Get atom type assignments for this crystal structure.\n\n    Args:\n        force_field (str or ForceFieldType): Force field to use\n        use_cached (bool): Whether to use cached results if available\n        **kwargs: Additional arguments for atom typing\n\n    Returns:\n        dict: Mapping of atom indices to (force_field_type, AtomTypeDescriptor) tuples\n    \"\"\"\n    if use_cached and hasattr(self, \"_atom_typing_results\"):\n        cached_ff = self._atom_typing_results.get(\"force_field\", \"\").upper()\n        if cached_ff == str(force_field).upper():\n            return self._atom_typing_results[\"atom_types\"]\n\n    results = self.assign_atom_types(force_field, **kwargs)\n    return results[\"atom_types\"]\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.get_ff_parameters","title":"<code>get_ff_parameters(force_field='UFF', use_cached=True, **kwargs)</code>","text":"<p>Get force field parameters for this crystal structure.</p> <p>Parameters:</p> Name Type Description Default <code>force_field</code> <code>str or ForceFieldType</code> <p>Force field to use</p> <code>'UFF'</code> <code>use_cached</code> <code>bool</code> <p>Whether to use cached results if available</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments for atom typing</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Mapping of atom indices to ForceFieldParameters objects</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def get_ff_parameters(self, force_field=\"UFF\", use_cached=True, **kwargs):\n    \"\"\"\n    Get force field parameters for this crystal structure.\n\n    Args:\n        force_field (str or ForceFieldType): Force field to use\n        use_cached (bool): Whether to use cached results if available\n        **kwargs: Additional arguments for atom typing\n\n    Returns:\n        dict: Mapping of atom indices to ForceFieldParameters objects\n    \"\"\"\n    if use_cached and hasattr(self, \"_atom_typing_results\"):\n        cached_ff = self._atom_typing_results.get(\"force_field\", \"\").upper()\n        if cached_ff == str(force_field).upper():\n            return self._atom_typing_results[\"parameters\"]\n\n    results = self.assign_atom_types(force_field, **kwargs)\n    return results[\"parameters\"]\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.get_lj_parameters_array","title":"<code>get_lj_parameters_array(force_field='UFF', use_cached=True, **kwargs)</code>","text":"<p>Get Lennard-Jones parameters as structured arrays for simulation input.</p> <p>Parameters:</p> Name Type Description Default <code>force_field</code> <code>str or ForceFieldType</code> <p>Force field to use</p> <code>'UFF'</code> <code>use_cached</code> <code>bool</code> <p>Whether to use cached results if available</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments for atom typing</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(atom_types_array, epsilon_array, sigma_array, mass_array, charges_array) where each array is ordered by atom index</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def get_lj_parameters_array(self, force_field=\"UFF\", use_cached=True, **kwargs):\n    \"\"\"\n    Get Lennard-Jones parameters as structured arrays for simulation input.\n\n    Args:\n        force_field (str or ForceFieldType): Force field to use\n        use_cached (bool): Whether to use cached results if available\n        **kwargs: Additional arguments for atom typing\n\n    Returns:\n        tuple: (atom_types_array, epsilon_array, sigma_array, mass_array, charges_array)\n            where each array is ordered by atom index\n    \"\"\"\n    parameters = self.get_ff_parameters(force_field, use_cached, **kwargs)\n    uc_atoms = self.unit_cell_atoms()\n    n_atoms = len(uc_atoms[\"element\"])\n\n    # Initialize arrays\n    atom_types = []\n    epsilons = np.zeros(n_atoms)\n    sigmas = np.zeros(n_atoms)\n    masses = np.zeros(n_atoms)\n    charges = np.zeros(n_atoms)\n\n    # Fill arrays in atom index order\n    for i in range(n_atoms):\n        if i in parameters:\n            params = parameters[i]\n            atom_types.append(params.ff_type)\n            epsilons[i] = params.epsilon\n            sigmas[i] = params.sigma\n            masses[i] = params.mass if params.mass is not None else 0.0\n            charges[i] = params.charge\n        else:\n            # Fallback for missing parameters\n            element = Element[uc_atoms[\"element\"][i]].symbol\n            atom_types.append(f\"{element}_generic\")\n            masses[i] = Element[uc_atoms[\"element\"][i]].mass\n\n    return atom_types, epsilons, sigmas, masses, charges\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.get_unique_atom_types","title":"<code>get_unique_atom_types(force_field='UFF', use_cached=True, **kwargs)</code>","text":"<p>Get the set of unique atom types in this crystal structure.</p> <p>Parameters:</p> Name Type Description Default <code>force_field</code> <code>str or ForceFieldType</code> <p>Force field to use</p> <code>'UFF'</code> <code>use_cached</code> <code>bool</code> <p>Whether to use cached results if available</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments for atom typing</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>set</code> <p>Set of unique force field atom type strings</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def get_unique_atom_types(self, force_field=\"UFF\", use_cached=True, **kwargs):\n    \"\"\"\n    Get the set of unique atom types in this crystal structure.\n\n    Args:\n        force_field (str or ForceFieldType): Force field to use\n        use_cached (bool): Whether to use cached results if available\n        **kwargs: Additional arguments for atom typing\n\n    Returns:\n        set: Set of unique force field atom type strings\n    \"\"\"\n    if use_cached and hasattr(self, \"_atom_typing_results\"):\n        cached_ff = self._atom_typing_results.get(\"force_field\", \"\").upper()\n        if cached_ff == str(force_field).upper():\n            return self._atom_typing_results[\"unique_types\"]\n\n    results = self.assign_atom_types(force_field, **kwargs)\n    return results[\"unique_types\"]\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.hirshfeld_surfaces","title":"<code>hirshfeld_surfaces(**kwargs)</code>","text":"<p>Alias for <code>self.stockholder_weight_isosurfaces</code></p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def hirshfeld_surfaces(self, **kwargs):\n    \"Alias for `self.stockholder_weight_isosurfaces`\"\n    return self.stockholder_weight_isosurfaces(**kwargs)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.load","title":"<code>load(filename, **kwargs)</code>  <code>classmethod</code>","text":"<p>Load a crystal structure from file (.res, .cif)</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the path to the crystal structure file</p> required <p>Returns:</p> Type Description <code>Union[Crystal, dict]</code> <p>the resulting crystal structure or dictionary of crystal structures</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>@classmethod\ndef load(cls, filename, **kwargs) -&gt; Union[\"Crystal\", dict]:\n    \"\"\"\n    Load a crystal structure from file (.res, .cif)\n\n    Args:\n        filename (str): the path to the crystal structure file\n\n    Returns:\n        the resulting crystal structure or dictionary of crystal structures\n    \"\"\"\n    fpath = Path(filename)\n    n = fpath.name\n    fname_map = cls._fname_load_map()\n    if n in fname_map:\n        return fname_map[n](filename)\n    extension_map = cls._ext_load_map()\n    extension = kwargs.pop(\"fmt\", fpath.suffix.lower())\n    if not extension.startswith(\".\"):\n        extension = \".\" + extension\n    return extension_map[extension](filename, **kwargs)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.mesh_scene","title":"<code>mesh_scene(**kwargs)</code>","text":"<p>Calculate a scene of this meshes of unit cell molecules in this crystal, along with optional void surface.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>optional arguments used in the generation of this scene.</p> <code>{}</code> <p>Returns:</p> Type Description <p>trimesh.scene.Scene: trimesh scene object.</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def mesh_scene(self, **kwargs):\n    \"\"\"\n    Calculate a scene of this meshes of unit cell molecules in this crystal,\n    along with optional void surface.\n\n    Args:\n        kwargs: optional arguments used in the generation of this scene.\n\n    Returns:\n        trimesh.scene.Scene: trimesh scene object.\n    \"\"\"\n    from trimesh import Scene\n\n    meshes = {}\n    for i, m in enumerate(self.unit_cell_molecules()):\n        mesh = m.to_mesh(representation=kwargs.get(\"representation\", \"ball_stick\"))\n        n = m.molecular_formula\n        for k, v in mesh.items():\n            meshes[f\"mol_{i}_{n}.{k}\"] = v\n\n    if kwargs.get(\"void\", False):\n        void_kwargs = kwargs.get(\"void_kwargs\", {})\n        meshes[\"void_surface\"] = self.void_surface(**void_kwargs)\n    if kwargs.get(\"axes\", False):\n        from trimesh.creation import axis\n\n        meshes[\"axes\"] = axis(\n            transform=self.unit_cell.direct_homogeneous.T, axis_length=1.0\n        )\n    return Scene(meshes)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.molecular_shape_descriptors","title":"<code>molecular_shape_descriptors(l_max=5, radius=6.0, with_property=None, return_coefficients=False)</code>","text":"<p>Calculate the molecular shape descriptors[1,2] for all symmetry unique molecules in this crystal.</p> <p>Parameters:</p> Name Type Description Default <code>l_max</code> <code>int</code> <p>maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function.</p> <code>5</code> <code>radius</code> <code>float</code> <p>maximum distance (Angstroms) to include surroundings in the shape description</p> <code>6.0</code> <code>with_property</code> <code>str</code> <p>name of the surface property to include in the shape description</p> <code>None</code> <code>return_coefficients</code> <code>bool</code> <p>also return the spherical harmonic coefficients</p> <code>False</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>shape description vector</p> <p>References: <pre><code>[1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n    https://dx.doi.org/10.1038/srep22204\n[2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n    https://dx.doi.org/10.1002/anie.201906602\n</code></pre></p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def molecular_shape_descriptors(\n    self, l_max=5, radius=6.0, with_property=None, return_coefficients=False\n) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the molecular shape descriptors[1,2] for all symmetry unique\n    molecules in this crystal.\n\n    Args:\n        l_max (int, optional): maximum level of angular momenta to include\n            in the spherical harmonic transform of the molecular shape function.\n        radius (float, optional): maximum distance (Angstroms) to include\n            surroundings in the shape description\n        with_property (str, optional): name of the surface property to include\n            in the shape description\n        return_coefficients (bool, optional): also return the spherical\n            harmonic coefficients\n\n    Returns:\n        shape description vector\n\n    References:\n    ```\n    [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n        https://dx.doi.org/10.1038/srep22204\n    [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n        https://dx.doi.org/10.1002/anie.201906602\n    ```\n    \"\"\"\n    descriptors = []\n    coeffs = []\n    from chmpy.shape import SHT, stockholder_weight_descriptor\n\n    sph = SHT(l_max)\n    for mol, neighbour_els, neighbour_pos in self.molecule_environments(\n        radius=radius\n    ):\n        c = np.array(mol.centroid, dtype=np.float32)\n        dists = np.linalg.norm(mol.positions - c, axis=1)\n        bounds = np.min(dists) / 2, np.max(dists) + 10.0\n        descriptor = stockholder_weight_descriptor(\n            sph,\n            mol.atomic_numbers,\n            mol.positions,\n            neighbour_els,\n            neighbour_pos,\n            origin=c,\n            bounds=bounds,\n            with_property=with_property,\n            coefficients=return_coefficients,\n        )\n\n        if return_coefficients:\n            coeffs.append(descriptor[0])\n            descriptors.append(descriptor[1])\n        else:\n            descriptors.append(descriptor)\n    if return_coefficients:\n        return np.asarray(coeffs), np.asarray(descriptors)\n    else:\n        return np.asarray(descriptors)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.molecular_shell","title":"<code>molecular_shell(mol_idx=0, radius=3.8, method='nearest_atom')</code>","text":"<p>Calculate the neighbouring molecules around the molecule with index <code>mol_idx</code>, within the given <code>radius</code> using the specified <code>method</code>.</p> <p>Parameters:</p> Name Type Description Default <code>mol_idx</code> <code>int</code> <p>The index (into <code>symmetry_unique_molecules</code>) of the central molecule for the shell</p> <code>0</code> <code>radius</code> <code>float</code> <p>The maximum distance (Angstroms) between the central molecule and the neighbours.</p> <code>3.8</code> <code>method</code> <code>str</code> <p>the method to use when determining inclusion of neighbours.</p> <code>'nearest_atom'</code> <p>Returns:</p> Type Description <code>list[Molecule]</code> <p>A list of neighbouring molecules using the given method.</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def molecular_shell(\n    self, mol_idx=0, radius=3.8, method=\"nearest_atom\"\n) -&gt; list[Molecule]:\n    \"\"\"\n    Calculate the neighbouring molecules around the molecule with index\n    `mol_idx`, within the given `radius` using the specified `method`.\n\n    Arguments:\n        mol_idx (int, optional): The index (into `symmetry_unique_molecules`)\n            of the central molecule for the shell\n        radius (float, optional): The maximum distance (Angstroms) between\n            the central molecule and the neighbours.\n        method (str, optional): the method to use when determining inclusion\n            of neighbours.\n\n    Returns:\n        A list of neighbouring molecules using the given method.\n    \"\"\"\n    mol = self.symmetry_unique_molecules()[mol_idx]\n    frac_origin = self.to_fractional(mol.center_of_mass)\n    frac_radius = radius / np.array(self.unit_cell.lengths)\n    hmax, kmax, lmax = np.ceil(frac_radius + frac_origin).astype(int) + 1\n    hmin, kmin, lmin = np.floor(frac_origin - frac_radius).astype(int) - 1\n    uc_mols = self.unit_cell_molecules()\n    shifts = self.to_cartesian(\n        cartesian_product(\n            np.arange(hmin, hmax), np.arange(kmin, kmax), np.arange(lmin, lmax)\n        )\n    )\n    neighbours = []\n    for uc_mol in uc_mols:\n        for shift in shifts:\n            uc_mol_t = uc_mol.translated(shift)\n            dist = mol.distance_to(uc_mol_t, method=method)\n            if (dist &lt; radius) and (dist &gt; 1e-2):\n                neighbours.append(uc_mol_t)\n    return neighbours\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.molecule_dict","title":"<code>molecule_dict(**kwargs)</code>","text":"<p>A dictionary of <code>symmetry_unique_molecules</code>, grouped by their chemical formulae.</p> <p>Returns:</p> Type Description <code>dict</code> <p>the dictionary of molecules with chemical formula keys</p> <code>dict</code> <p>and list of molecule values.</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def molecule_dict(self, **kwargs) -&gt; dict:\n    \"\"\"\n    A dictionary of `symmetry_unique_molecules`, grouped by\n    their chemical formulae.\n\n    Returns:\n        the dictionary of molecules with chemical formula keys\n        and list of molecule values.\n    \"\"\"\n    result = {}\n    mols = self.symmetry_unique_molecules()\n    for m in mols:\n        f = m.molecular_formula\n        if f not in result:\n            result[f] = []\n        result[f].append(m)\n    return result\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.molecule_environment","title":"<code>molecule_environment(mol, radius=6.0, threshold=0.001)</code>","text":"<p>Calculate the atomic information for all atoms surrounding the given molecule in this crystal within the given radius. Atoms closer than <code>threshold</code> to any atom in the provided molecule will be excluded and considered part of the molecule.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Molecule</code> <p>the molecule whose environment to calculate</p> required <code>radius</code> <code>float</code> <p>Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms</p> <code>6.0</code> <code>threshold</code> <code>float</code> <p>tolerance for detecting the neighbouring sites as part of the given molecule.</p> <code>0.001</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A list of tuples of (Molecule, elements, positions) where <code>elements</code> is an <code>np.ndarray</code> of atomic numbers, and <code>positions</code> is an <code>np.ndarray</code> of Cartesian atomic positions</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def molecule_environment(self, mol, radius=6.0, threshold=1e-3) -&gt; tuple:\n    \"\"\"\n    Calculate the atomic information for all\n    atoms surrounding the given molecule in this crystal\n    within the given radius. Atoms closer than `threshold`\n    to any atom in the provided molecule will be excluded and\n    considered part of the molecule.\n\n    Args:\n        mol (Molecule): the molecule whose environment to calculate\n        radius (float, optional): Maximum distance in Angstroms between\n            any atom in the molecule and the resulting neighbouring atoms\n        threshold (float, optional): tolerance for detecting the neighbouring\n            sites as part of the given molecule.\n\n    Returns:\n        A list of tuples of (Molecule, elements, positions)\n            where `elements` is an `np.ndarray` of atomic numbers,\n            and `positions` is an `np.ndarray` of Cartesian atomic positions\n    \"\"\"\n\n    hklmax = np.array([-np.inf, -np.inf, -np.inf])\n    hklmin = np.array([np.inf, np.inf, np.inf])\n    frac_radius = radius / np.array(self.unit_cell.lengths)\n    for pos in self.to_fractional(mol.positions):\n        hklmax = np.maximum(hklmax, np.ceil(frac_radius + pos))\n        hklmin = np.minimum(hklmin, np.floor(pos - frac_radius))\n    hmax, kmax, lmax = hklmax.astype(int)\n    hmin, kmin, lmin = hklmin.astype(int)\n    slab = self.slab(bounds=((hmin, kmin, lmin), (hmax, kmax, lmax)))\n    elements = slab[\"element\"]\n    positions = slab[\"cart_pos\"]\n    tree = KDTree(positions)\n    keep = np.zeros(positions.shape[0], dtype=bool)\n    this_mol = []\n    for pos in mol.positions:\n        idxs = tree.query_ball_point(pos, radius)\n        d, nn = tree.query(pos)\n        keep[idxs] = True\n        if d &lt; threshold:\n            this_mol.append(nn)\n            keep[this_mol] = False\n    return (mol, elements[keep], positions[keep])\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.molecule_environments","title":"<code>molecule_environments(radius=6.0, threshold=0.001)</code>","text":"<p>Calculate the atomic information for all atoms surrounding each symmetry unique molecule in this crystal within the given radius.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms</p> <code>6.0</code> <code>threshold</code> <code>float</code> <p>tolerance for detecting the neighbouring sites as part of the given molecule.</p> <code>0.001</code> <p>Returns:</p> Type Description <code>list[tuple]</code> <p>A list of tuples of (Molecule, elements, positions)</p> <code>list[tuple]</code> <p>where <code>elements</code> is an <code>np.ndarray</code> of atomic numbers,</p> <code>list[tuple]</code> <p>and <code>positions</code> is an <code>np.ndarray</code> of Cartesian atomic positions</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def molecule_environments(self, radius=6.0, threshold=1e-3) -&gt; list[tuple]:\n    \"\"\"\n    Calculate the atomic information for all\n    atoms surrounding each symmetry unique molecule\n    in this crystal within the given radius.\n\n    Args:\n        radius (float, optional): Maximum distance in Angstroms between\n            any atom in the molecule and the resulting neighbouring atoms\n        threshold (float, optional): tolerance for detecting the neighbouring\n            sites as part of the given molecule.\n\n    Returns:\n        A list of tuples of (Molecule, elements, positions)\n        where `elements` is an `np.ndarray` of atomic numbers,\n        and `positions` is an `np.ndarray` of Cartesian atomic positions\n    \"\"\"\n    return [\n        self.molecule_environment(x, radius=radius, threshold=threshold)\n        for x in self.symmetry_unique_molecules()\n    ]\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.molecule_shape_descriptors","title":"<code>molecule_shape_descriptors(mol, l_max=5, radius=6.0, with_property=None)</code>","text":"<p>Calculate the molecular shape descriptors <code>[1,2]</code> for the provided molecule in the crystal.</p> <p>Parameters:</p> Name Type Description Default <code>l_max</code> <code>int</code> <p>maximum level of angular momenta to include in the spherical harmonic transform of the molecular shape function.</p> <code>5</code> <code>radius</code> <code>float</code> <p>maximum distance (Angstroms) to include surroundings in the shape description</p> <code>6.0</code> <code>with_property</code> <code>str</code> <p>name of the surface property to include in the shape description</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>shape description vector</p> <p>References: <pre><code>[1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n    https://dx.doi.org/10.1038/srep22204\n[2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n    https://dx.doi.org/10.1002/anie.201906602\n</code></pre></p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def molecule_shape_descriptors(\n    self, mol, l_max=5, radius=6.0, with_property=None\n) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the molecular shape descriptors `[1,2]` for\n    the provided molecule in the crystal.\n\n    Args:\n        l_max (int, optional): maximum level of angular momenta to include\n            in the spherical harmonic\n            transform of the molecular shape function.\n        radius (float, optional): maximum distance (Angstroms) to include\n            surroundings in the shape description\n        with_property (str, optional): name of the surface property to include\n            in the shape description\n\n    Returns:\n        shape description vector\n\n    References:\n    ```\n    [1] PR Spackman et al. Sci. Rep. 6, 22204 (2016)\n        https://dx.doi.org/10.1038/srep22204\n    [2] PR Spackman et al. Angew. Chem. 58 (47), 16780-16784 (2019)\n        https://dx.doi.org/10.1002/anie.201906602\n    ```\n    \"\"\"\n    from chmpy.shape import SHT, stockholder_weight_descriptor\n\n    sph = SHT(l_max)\n    mol, neighbour_els, neighbour_pos = self.molecule_environment(\n        mol, radius=radius\n    )\n    c = np.array(mol.centroid, dtype=np.float32)\n    dists = np.linalg.norm(mol.positions - c, axis=1)\n    bounds = np.min(dists) / 2, np.max(dists) + 10.0\n    return stockholder_weight_descriptor(\n        sph,\n        mol.atomic_numbers,\n        mol.positions,\n        neighbour_els,\n        neighbour_pos,\n        origin=c,\n        bounds=bounds,\n        with_property=with_property,\n    )\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.promolecule_density_isosurfaces","title":"<code>promolecule_density_isosurfaces(**kwargs)</code>","text":"<p>Calculate promolecule electron density isosurfaces for each symmetry unique molecule in this crystal.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>Keyword arguments used by <code>Molecule.promolecule_density_isosurface</code>.</p> <p>Options are: <pre><code>isovalue (float, optional): level set value for the isosurface\n    (default=0.002) in au.\nseparation (float, optional): separation between density grid\n    used in the surface calculation (default 0.2) in Angstroms.\ncolor (str, optional): surface property to use for vertex coloring,\n    one of ('d_norm_i', 'd_i', 'd_norm_e', 'd_e')\ncolormap (str, optional): matplotlib colormap to use for surface\n    coloring (default 'viridis_r')\nmidpoint (float, optional): midpoint of the segmented\n    colormap (if applicable)\n</code></pre></p> <code>{}</code> <p>Returns:</p> Type Description <code>list[Trimesh]</code> <p>A list of meshes representing the promolecule density isosurfaces</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def promolecule_density_isosurfaces(self, **kwargs) -&gt; list[Trimesh]:\n    \"\"\"\n    Calculate promolecule electron density isosurfaces\n    for each symmetry unique molecule in this crystal.\n\n    Args:\n        kwargs: Keyword arguments used by `Molecule.promolecule_density_isosurface`.\n\n            Options are:\n            ```\n            isovalue (float, optional): level set value for the isosurface\n                (default=0.002) in au.\n            separation (float, optional): separation between density grid\n                used in the surface calculation (default 0.2) in Angstroms.\n            color (str, optional): surface property to use for vertex coloring,\n                one of ('d_norm_i', 'd_i', 'd_norm_e', 'd_e')\n            colormap (str, optional): matplotlib colormap to use for surface\n                coloring (default 'viridis_r')\n            midpoint (float, optional): midpoint of the segmented\n                colormap (if applicable)\n            ```\n\n    Returns:\n        A list of meshes representing the promolecule density isosurfaces\n    \"\"\"\n    if kwargs.get(\"color\", None) == \"fragment_patch\":\n        color = kwargs.pop(\"color\")\n        surfaces = [\n            mol.promolecule_density_isosurface(**kwargs)\n            for mol in self.symmetry_unique_molecules()\n        ]\n        radius = kwargs.get(\"fragment_patch_radius\", 6.0)\n        from chmpy.util.color import property_to_color\n        from chmpy.util.mesh import face_centroids\n\n        for i, (_mol, n_e, n_p) in enumerate(\n            self.molecule_environments(radius=radius)\n        ):\n            surf = surfaces[i]\n            prop = _nearest_molecule_idx(surf.vertices, n_e, n_p)\n            color = property_to_color(prop, cmap=kwargs.get(\"colormap\", color))\n            face_points = face_centroids(surf)\n            surf.visual.vertex_colors = color\n            surf.vertex_attributes[\"fragment_patch\"] = prop\n            surf.face_attributes[\"fragment_patch\"] = _nearest_molecule_idx(\n                face_points, n_e, n_p\n            )\n    else:\n        surfaces = [\n            mol.promolecule_density_isosurface(**kwargs)\n            for mol in self.symmetry_unique_molecules()\n        ]\n    return surfaces\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.save","title":"<code>save(filename, **kwargs)</code>","text":"<p>Save this crystal structure to file (.cif, .res, POSCAR)</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def save(self, filename, **kwargs):\n    \"\"\"Save this crystal structure to file (.cif, .res, POSCAR)\"\"\"\n    fpath = Path(filename)\n    n = fpath.name\n    fname_map = self._fname_save_map()\n    if n in fname_map:\n        return fname_map[n](filename, **kwargs)\n    extension_map = self._ext_save_map()\n    extension = kwargs.pop(\"fmt\", fpath.suffix.lower())\n    if not extension.startswith(\".\"):\n        extension = \".\" + extension\n    return extension_map[extension](filename, **kwargs)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.slab","title":"<code>slab(bounds=((-1, -1, -1), (1, 1, 1)))</code>","text":"<p>Calculate the atoms and associated information for a slab consisting of multiple unit cells.</p> <p>If unit cell atoms have not been calculated, this calculates their information and caches it.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Tuple</code> <p>Tuple of upper and lower corners (hkl) describing the bounds of the slab.</p> <code>((-1, -1, -1), (1, 1, 1))</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary of arrays associated with all sites contained</p> <code>dict</code> <p>in the unit cell of this crystal, members are: asym_atom: corresponding asymmetric unit atom indices for all sites. frac_pos: (N, 3) array of fractional positions for all sites. cart_pos: (N, 3) array of cartesian positions for all sites. element: (N) array of atomic numbers for all sites. symop: (N) array of indices corresponding to the generator symmetry     operation for each site. label: (N) array of string labels corresponding to each site occupation: (N) array of occupation numbers for each site. Will     warn if any of these are greater than 1.0 cell: (N,3) array of cell indices for each site</p> <code>n_uc</code> <code>dict</code> <p>number of atoms in the unit cell</p> <code>n_cells</code> <code>dict</code> <p>number of cells in this slab</p> <code>occupation</code> <code>dict</code> <p>(N) array of occupation numbers for each site. Will</p> <code>dict</code> <p>warn if any of these are greater than 1.0</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def slab(self, bounds=((-1, -1, -1), (1, 1, 1))) -&gt; dict:\n    \"\"\"\n    Calculate the atoms and associated information\n    for a slab consisting of multiple unit cells.\n\n    If unit cell atoms have not been calculated, this calculates\n    their information and caches it.\n\n    Args:\n        bounds (Tuple, optional): Tuple of upper and lower corners (hkl)\n            describing the bounds of the slab.\n\n    Returns:\n        A dictionary of arrays associated with all sites contained\n        in the unit cell of this crystal, members are:\n            asym_atom: corresponding asymmetric unit atom indices for all sites.\n            frac_pos: (N, 3) array of fractional positions for all sites.\n            cart_pos: (N, 3) array of cartesian positions for all sites.\n            element: (N) array of atomic numbers for all sites.\n            symop: (N) array of indices corresponding to the generator symmetry\n                operation for each site.\n            label: (N) array of string labels corresponding to each site\n            occupation: (N) array of occupation numbers for each site. Will\n                warn if any of these are greater than 1.0\n            cell: (N,3) array of cell indices for each site\n\n        n_uc: number of atoms in the unit cell\n\n        n_cells: number of cells in this slab\n\n        occupation: (N) array of occupation numbers for each site. Will\n        warn if any of these are greater than 1.0\n\n    \"\"\"\n    uc_atoms = self.unit_cell_atoms()\n    (hmin, kmin, lmin), (hmax, kmax, lmax) = bounds\n    h = np.arange(hmin, hmax + 1)\n    k = np.arange(kmin, kmax + 1)\n    l = np.arange(lmin, lmax + 1)  # noqa: E741\n    cells = cartesian_product(\n        h[np.argsort(np.abs(h))], k[np.argsort(np.abs(k))], l[np.argsort(np.abs(l))]\n    )\n    ncells = len(cells)\n    uc_pos = uc_atoms[\"frac_pos\"]\n    n_uc = len(uc_pos)\n    pos = np.empty((ncells * n_uc, 3), dtype=np.float64)\n    slab_cells = np.empty((ncells * n_uc, 3), dtype=np.float64)\n    for i, cell in enumerate(cells):\n        pos[i * n_uc : (i + 1) * n_uc, :] = uc_pos + cell\n        slab_cells[i * n_uc : (i + 1) * n_uc] = cell\n    slab_dict = {\n        k: np.tile(v, ncells) for k, v in uc_atoms.items() if not k.endswith(\"pos\")\n    }\n    slab_dict[\"frac_pos\"] = pos\n    slab_dict[\"cell\"] = slab_cells\n    slab_dict[\"n_uc\"] = n_uc\n    slab_dict[\"n_cells\"] = ncells\n    slab_dict[\"cart_pos\"] = self.to_cartesian(pos)\n    return slab_dict\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.stockholder_weight_isosurfaces","title":"<code>stockholder_weight_isosurfaces(kind='mol', **kwargs)</code>","text":"<p>Calculate stockholder weight isosurfaces (i.e. Hirshfeld surfaces) for each symmetry unique molecule or atom in this crystal.</p> <p>Parameters:</p> Name Type Description Default <code>kind</code> <code>str</code> <p>dictates whether we calculate surfaces for each unique molecule or for each unique atom</p> <code>'mol'</code> <code>kwargs</code> <p>keyword arguments passed to <code>stockholder_weight_isosurface</code>.</p> <p>Options include: <pre><code>isovalue: float, optional\n    level set value for the isosurface (default=0.5). Must be between\n    0 and 1, but values other than 0.5 probably won't make sense anyway.\nseparation: float, optional\n    separation between density grid used in the surface calculation\n    (default 0.2) in Angstroms.\nradius: float, optional\n    maximum distance for contributing neighbours for the stockholder\n    weight calculation\ncolor: str, optional\n    surface property to use for vertex coloring, one of ('d_norm_i',\n    'd_i', 'd_norm_e', 'd_e', 'd_norm', 'fragment_patch')\ncolormap: str, optional\n    matplotlib colormap to use for surface coloring\n    (default 'viridis_r')\nmidpoint: float, optional, default 0.0 if using d_norm\n    use the midpoint norm (as is used in CrystalExplorer)\n</code></pre></p> <code>{}</code> <p>Returns:</p> Type Description <code>list[Trimesh]</code> <p>A list of meshes representing the stockholder weight isosurfaces</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def stockholder_weight_isosurfaces(self, kind=\"mol\", **kwargs) -&gt; list[Trimesh]:\n    \"\"\"\n    Calculate stockholder weight isosurfaces (i.e. Hirshfeld surfaces)\n    for each symmetry unique molecule or atom in this crystal.\n\n    Args:\n        kind (str, optional): dictates whether we calculate surfaces\n            for each unique molecule or for each unique atom\n        kwargs: keyword arguments passed to `stockholder_weight_isosurface`.\n\n            Options include:\n            ```\n            isovalue: float, optional\n                level set value for the isosurface (default=0.5). Must be between\n                0 and 1, but values other than 0.5 probably won't make sense anyway.\n            separation: float, optional\n                separation between density grid used in the surface calculation\n                (default 0.2) in Angstroms.\n            radius: float, optional\n                maximum distance for contributing neighbours for the stockholder\n                weight calculation\n            color: str, optional\n                surface property to use for vertex coloring, one of ('d_norm_i',\n                'd_i', 'd_norm_e', 'd_e', 'd_norm', 'fragment_patch')\n            colormap: str, optional\n                matplotlib colormap to use for surface coloring\n                (default 'viridis_r')\n            midpoint: float, optional, default 0.0 if using d_norm\n                use the midpoint norm (as is used in CrystalExplorer)\n            ```\n\n    Returns:\n        A list of meshes representing the stockholder weight isosurfaces\n    \"\"\"\n    import trimesh\n\n    from chmpy import StockholderWeight\n    from chmpy.surface import stockholder_weight_isosurface\n    from chmpy.util.color import property_to_color\n\n    sep = kwargs.get(\"separation\", kwargs.get(\"resolution\", 0.2))\n    radius = kwargs.get(\"radius\", 12.0)\n    vertex_color = kwargs.get(\"color\", \"d_norm\")\n    isovalue = kwargs.get(\"isovalue\", 0.5)\n    meshes = []\n    extra_props = {}\n    isos = []\n\n    def nearest_atomic_number(pos, n_e, n_p):\n        return np.array(n_e[_nearest_atom_idx(pos, n_e, n_p)], dtype=np.uint8)\n\n    if kind == \"atom\":\n        for surrounds in self.atomic_surroundings(radius=radius):\n            n = surrounds[\"centre\"][\"element\"]\n            pos = surrounds[\"centre\"][\"cart_pos\"]\n            neighbour_els = surrounds[\"neighbours\"][\"element\"]\n            neighbour_pos = surrounds[\"neighbours\"][\"cart_pos\"]\n            s = StockholderWeight.from_arrays(\n                [n], [pos], neighbour_els, neighbour_pos\n            )\n            iso = stockholder_weight_isosurface(s, isovalue=isovalue, sep=sep)\n            isos.append(iso)\n    elif kind == \"mol\":\n        for _i, (mol, n_e, n_p) in enumerate(\n            self.molecule_environments(radius=radius)\n        ):\n            extra_props = {}\n            if vertex_color == \"esp\":\n                extra_props[\"esp\"] = mol.electrostatic_potential\n            elif vertex_color == \"fragment_patch\":\n                extra_props[\"fragment_patch\"] = (\n                    lambda x, _n_e=n_e, _n_p=n_p: _nearest_molecule_idx(\n                        x, _n_e, _n_p\n                    )\n                )\n            extra_props[\"nearest_atom_external\"] = (\n                lambda x, _n_e=n_e, _n_p=n_p: nearest_atomic_number(x, _n_e, _n_p)\n            )\n            extra_props[\"nearest_atom_internal\"] = (\n                lambda x,\n                _atomic_nums=mol.atomic_numbers,\n                _positions=mol.positions: nearest_atomic_number(\n                    x, _atomic_nums, _positions\n                )\n            )\n            s = StockholderWeight.from_arrays(\n                mol.atomic_numbers, mol.positions, n_e, n_p\n            )\n            iso = stockholder_weight_isosurface(\n                s, isovalue=isovalue, sep=sep, extra_props=extra_props\n            )\n            isos.append(iso)\n    else:\n        for arr in self.functional_group_surroundings(radius=radius, kind=kind):\n            s = StockholderWeight.from_arrays(*arr)\n            iso = stockholder_weight_isosurface(s, isovalue=isovalue, sep=sep)\n            isos.append(iso)\n\n    for iso in isos:\n        prop = iso.vertex_prop[vertex_color]\n        color = property_to_color(prop, cmap=kwargs.get(\"cmap\", vertex_color))\n        mesh = trimesh.Trimesh(\n            vertices=iso.vertices,\n            faces=iso.faces,\n            normals=iso.normals,\n            vertex_colors=color,\n        )\n        for k, v in iso.vertex_prop.items():\n            mesh.vertex_attributes[k] = v\n        meshes.append(mesh)\n    return meshes\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.symmetry_unique_dimers","title":"<code>symmetry_unique_dimers(radius=3.8, distance_method='nearest_atom')</code>","text":"<p>Calculate the information for all molecule pairs surrounding the symmetry_unique_molecules in this crystal within the given radius.</p> <p>Parameters:</p> Name Type Description Default <code>radius</code> <code>float</code> <p>Maximum distance in Angstroms between any atom in the molecule and the resulting neighbouring atoms</p> <code>3.8</code> <p>Returns:</p> Type Description <p>A dictionary of dimers (Molecule, elements, positions) where <code>elements</code> is an <code>np.ndarray</code> of atomic numbers, and <code>positions</code> is an <code>np.ndarray</code> of Cartesian atomic positions</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def symmetry_unique_dimers(self, radius=3.8, distance_method=\"nearest_atom\"):\n    \"\"\"\n    Calculate the information for all molecule\n    pairs surrounding the symmetry_unique_molecules\n    in this crystal within the given radius.\n\n    Args:\n        radius (float, optional): Maximum distance in Angstroms between any\n            atom in the molecule and the resulting neighbouring atoms\n\n    Returns:\n        A dictionary of dimers (Molecule, elements, positions)\n            where `elements` is an `np.ndarray` of atomic numbers,\n            and `positions` is an `np.ndarray` of Cartesian atomic positions\n    \"\"\"\n    from chmpy.core.dimer import Dimer\n\n    hklmax = np.array([-np.inf, -np.inf, -np.inf])\n    hklmin = np.array([np.inf, np.inf, np.inf])\n    frac_radius = radius * 2 / np.array(self.unit_cell.lengths)\n\n    for pos in self.asymmetric_unit.positions:\n        hklmax = np.maximum(hklmax, np.ceil(frac_radius + pos))\n        hklmin = np.minimum(hklmin, np.floor(pos - frac_radius))\n    hklmin = np.minimum(hklmin, (-1, -1, -1))\n    hklmax = np.maximum(hklmax, (1, 1, 1))\n\n    hmax, kmax, lmax = hklmax.astype(int)\n    hmin, kmin, lmin = hklmin.astype(int)\n\n    shifts_frac = cartesian_product(\n        np.arange(hmin, hmax), np.arange(kmin, kmax), np.arange(lmin, lmax)\n    )\n\n    shifts = self.to_cartesian(shifts_frac)\n    LOG.debug(\n        \"Looking in %d neighbouring cells: %s : %s\",\n        len(shifts),\n        hklmin.astype(int),\n        hklmax.astype(int),\n    )\n    unique_dimers = []\n    mol_dimers = []\n    for mol_a in self.symmetry_unique_molecules():\n        dimers_a = []\n        for mol_b in self.unit_cell_molecules():\n            for shift, shift_frac in zip(shifts, shifts_frac, strict=False):\n                # shift_frac assumes the molecule is generated from\n                # the [0, 0, 0] cell, it's not\n                mol_bt = mol_b.translated(shift)\n                r = mol_a.distance_to(mol_bt, method=distance_method)\n                if r &gt; 1e-1 and r &lt; radius:\n                    d = Dimer(\n                        mol_a,\n                        mol_bt,\n                        separation=r,\n                        transform_ab=\"calculate\",\n                        frac_shift=shift_frac,\n                    )\n                    for i, dimer in enumerate(unique_dimers):\n                        if dimer.separation &lt;= d.separation + 1e-3:\n                            if d == dimer:\n                                dimers_a.append((i, d))\n                                break\n                    else:\n                        dimers_a.append((len(unique_dimers), d))\n                        unique_dimers.append(d)\n        mol_dimers.append(dimers_a)\n    return unique_dimers, mol_dimers\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.symmetry_unique_molecules","title":"<code>symmetry_unique_molecules(bond_tolerance=0.4, **kwargs)</code>","text":"<p>Calculate a list of connected molecules which contain every site in the asymmetric_unit</p> <p>Populates the _symmetry_unique_molecules member, subsequent calls to this function will be a no-op.</p> <p>Parameters:</p> Name Type Description Default <code>bond_tolerance</code> <code>float</code> <p>Bonding tolerance (bonded if d &lt; cov_a + cov_b + bond_tolerance)</p> <code>0.4</code> <p>Returns:</p> Type Description <code>list[Molecule]</code> <p>List of all connected molecules in the asymmetric_unit of this</p> <code>list[Molecule]</code> <p>crystal, i.e. the minimum list of connected molecules which contain</p> <code>list[Molecule]</code> <p>all sites in the asymmetric unit.</p> <code>list[Molecule]</code> <p>If the asymmetric is molecular, the list will be of length</p> <code>list[Molecule]</code> <p>num_molecules_in_asymmetric_unit and the total number of atoms</p> <code>list[Molecule]</code> <p>will be equal to the number of atoms in the asymmetric_unit</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def symmetry_unique_molecules(self, bond_tolerance=0.4, **kwargs) -&gt; list[Molecule]:\n    \"\"\"\n    Calculate a list of connected molecules which contain\n    every site in the asymmetric_unit\n\n    Populates the _symmetry_unique_molecules member, subsequent\n    calls to this function will be a no-op.\n\n    Args:\n        bond_tolerance (float, optional): Bonding tolerance\n            (bonded if d &lt; cov_a + cov_b + bond_tolerance)\n\n    Returns:\n        List of all connected molecules in the asymmetric_unit of this\n        crystal, i.e. the minimum list of connected molecules which contain\n        all sites in the asymmetric unit.\n\n        If the asymmetric is molecular, the list will be of length\n        num_molecules_in_asymmetric_unit and the total number of atoms\n        will be equal to the number of atoms in the asymmetric_unit\n    \"\"\"\n\n    if hasattr(self, \"_symmetry_unique_molecules\"):\n        return self._symmetry_unique_molecules\n    uc_molecules = self.unit_cell_molecules(bond_tolerance=bond_tolerance, **kwargs)\n    asym_atoms = np.zeros(len(self.asymmetric_unit), dtype=bool)\n    molecules = []\n\n    # sort by % of identity symop\n    def order(x):\n        return len(np.where(x.asym_symops == 16484)[0]) / len(x)\n\n    for mol in sorted(uc_molecules, key=order, reverse=True):\n        asym_atoms_in_g = np.unique(mol.properties[\"asymmetric_unit_atoms\"])\n        if np.all(asym_atoms[asym_atoms_in_g]):\n            continue\n        asym_atoms[asym_atoms_in_g] = True\n        molecules.append(mol)\n        if np.all(asym_atoms):\n            break\n    LOG.debug(\"%d symmetry unique molecules\", len(molecules))\n    self._symmetry_unique_molecules = molecules\n    for i, mol in enumerate(molecules):\n        mol.properties[\"asym_mol_idx\"] = i\n\n    ak = \"asymmetric_unit_atoms\"\n    for mol in self.unit_cell_molecules():\n        if \"asym_mol_idx\" in mol.properties:\n            continue\n        else:\n            for asym_mol in molecules:\n                if len(mol) != len(asym_mol):\n                    continue\n                if np.all(mol.properties[ak] == asym_mol.properties[ak]):\n                    mol.properties[\"asym_mol_idx\"] = asym_mol.properties[\n                        \"asym_mol_idx\"\n                    ]\n                    break\n            else:\n                LOG.warn(\n                    \"No equivalent asymmetric unit molecule found!?\"\n                    \"-- this should not happen!\"\n                )\n    return molecules\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_cartesian","title":"<code>to_cartesian(coords)</code>","text":"<p>Convert coordinates (row major) from fractional to Cartesian coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>ndarray</code> <p>(N, 3) array of positions assumed to be in fractional coordinates</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>(N, 3) array of positions transformed to Cartesian (orthogonal) coordinates by the unit cell of this crystal.</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def to_cartesian(self, coords) -&gt; np.ndarray:\n    \"\"\"\n    Convert coordinates (row major) from fractional to\n    Cartesian coordinates.\n\n    Arguments:\n        coords (np.ndarray): (N, 3) array of positions assumed to be in\n            fractional coordinates\n\n    Returns:\n        (N, 3) array of positions transformed to Cartesian (orthogonal)\n            coordinates by the unit cell of this crystal.\n    \"\"\"\n    return self.unit_cell.to_cartesian(coords)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_cif_data","title":"<code>to_cif_data(data_block_name=None)</code>","text":"<p>Convert this crystal structure to cif data dict</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def to_cif_data(self, data_block_name=None) -&gt; dict:\n    \"Convert this crystal structure to cif data dict\"\n    version = \"1.0a1\"\n    if data_block_name is None:\n        data_block_name = self.titl\n    if \"cif_data\" in self.properties:\n        cif_data = self.properties[\"cif_data\"]\n        cif_data[\"audit_creation_method\"] = (\n            f\"chmpy python library version {version}\"\n        )\n        cif_data[\"atom_site_fract_x\"] = self.asymmetric_unit.positions[:, 0]\n        cif_data[\"atom_site_fract_y\"] = self.asymmetric_unit.positions[:, 1]\n        cif_data[\"atom_site_fract_z\"] = self.asymmetric_unit.positions[:, 2]\n    else:\n        cif_data = {\n            \"audit_creation_method\": f\"chmpy python library version {version}\",\n            \"symmetry_equiv_pos_site_id\": list(\n                range(1, len(self.symmetry_operations) + 1)\n            ),\n            \"symmetry_equiv_pos_as_xyz\": [str(x) for x in self.symmetry_operations],\n            \"cell_length_a\": self.unit_cell.a,\n            \"cell_length_b\": self.unit_cell.b,\n            \"cell_length_c\": self.unit_cell.c,\n            \"cell_angle_alpha\": self.unit_cell.alpha_deg,\n            \"cell_angle_beta\": self.unit_cell.beta_deg,\n            \"cell_angle_gamma\": self.unit_cell.gamma_deg,\n            \"atom_site_label\": self.asymmetric_unit.labels,\n            \"atom_site_type_symbol\": [\n                x.symbol for x in self.asymmetric_unit.elements\n            ],\n            \"atom_site_fract_x\": self.asymmetric_unit.positions[:, 0],\n            \"atom_site_fract_y\": self.asymmetric_unit.positions[:, 1],\n            \"atom_site_fract_z\": self.asymmetric_unit.positions[:, 2],\n            \"atom_site_occupancy\": self.asymmetric_unit.properties.get(\n                \"occupation\", np.ones(len(self.asymmetric_unit))\n            ),\n        }\n    return {data_block_name: cif_data}\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_cif_file","title":"<code>to_cif_file(filename, **kwargs)</code>","text":"<p>save this crystal to a CIF formatted file</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def to_cif_file(self, filename, **kwargs):\n    \"save this crystal to a CIF formatted file\"\n    cif_data = self.to_cif_data(**kwargs)\n    return Cif(cif_data).to_file(filename)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_cif_string","title":"<code>to_cif_string(**kwargs)</code>","text":"<p>save this crystal to a CIF formatted string</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def to_cif_string(self, **kwargs):\n    \"save this crystal to a CIF formatted string\"\n    cif_data = self.to_cif_data(**kwargs)\n    return Cif(cif_data).to_string()\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_fractional","title":"<code>to_fractional(coords)</code>","text":"<p>Convert coordinates (row major) from Cartesian to fractional coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>ndarray</code> <p>(N, 3) array of positions assumed to be in Cartesian (orthogonal) coordinates</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>(N, 3) array of positions transformed to fractional coordinates</p> <code>ndarray</code> <p>by the unit cell of this crystal.</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def to_fractional(self, coords) -&gt; np.ndarray:\n    \"\"\"\n    Convert coordinates (row major) from Cartesian to\n    fractional coordinates.\n\n    Args:\n        coords (np.ndarray): (N, 3) array of positions assumed to be\n            in Cartesian (orthogonal) coordinates\n\n    Returns:\n        (N, 3) array of positions transformed to fractional coordinates\n        by the unit cell of this crystal.\n    \"\"\"\n\n    return self.unit_cell.to_fractional(coords)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_pdb_file","title":"<code>to_pdb_file(filename, header=None)</code>","text":"<p>Write this crystal structure as a PDB formatted file.</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def to_pdb_file(self, filename, header=None):\n    \"\"\"Write this crystal structure as a PDB formatted file.\"\"\"\n    Path(filename).write_text(self.to_pdb_string(header=header))\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_pdb_string","title":"<code>to_pdb_string(header=None)</code>","text":"<p>Represent this crystal structure as a PDB formatted string.</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def to_pdb_string(self, header=None):\n    \"\"\"Represent this crystal structure as a PDB formatted string.\"\"\"\n    from chmpy.fmt.pdb import Pdb\n\n    pdb = Pdb.from_crystal(self, header=header)\n    return pdb.to_string()\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_poscar_file","title":"<code>to_poscar_file(filename, **kwargs)</code>","text":"<p>save this crystal to a VASP POSCAR formatted file</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def to_poscar_file(self, filename, **kwargs):\n    \"save this crystal to a VASP POSCAR formatted file\"\n    Path(filename).write_text(self.to_poscar_string(**kwargs))\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_poscar_string","title":"<code>to_poscar_string(**kwargs)</code>","text":"<p>save this crystal to a VASP POSCAR formatted string</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def to_poscar_string(self, **kwargs):\n    \"save this crystal to a VASP POSCAR formatted string\"\n    from chmpy.ext.vasp import poscar_string\n\n    return poscar_string(self, name=self.titl)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_reciprocal","title":"<code>to_reciprocal(coords)</code>","text":"<p>Convert coordinates (row major) from fractional to reciprocal space coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>ndarray</code> <p>(N, 3) array of positions assumed to be in fractional coordinates</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>(N, 3) array of positions transformed to reciprocal (orthogonal) coordinates by the unit cell of this crystal.</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def to_reciprocal(self, coords) -&gt; np.ndarray:\n    \"\"\"\n    Convert coordinates (row major) from fractional to\n    reciprocal space coordinates.\n\n    Arguments:\n        coords (np.ndarray): (N, 3) array of positions assumed to be in\n            fractional coordinates\n\n    Returns:\n        (N, 3) array of positions transformed to reciprocal (orthogonal)\n            coordinates by the unit cell of this crystal.\n    \"\"\"\n    return self.unit_cell.to_reciprocal(coords)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_shelx_file","title":"<code>to_shelx_file(filename)</code>","text":"<p>Write this crystal structure as a shelx .res formatted file</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def to_shelx_file(self, filename):\n    \"\"\"Write this crystal structure as a shelx .res formatted file\"\"\"\n    Path(filename).write_text(self.to_shelx_string())\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_shelx_string","title":"<code>to_shelx_string(titl=None)</code>","text":"<p>Represent this crystal structure as a shelx .res formatted string</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def to_shelx_string(self, titl=None):\n    \"\"\"Represent this crystal structure as a shelx .res formatted string\"\"\"\n    from chmpy.fmt.shelx import to_res_contents\n\n    sfac = list(np.unique(self.site_atoms))\n    atom_sfac = [sfac.index(x) + 1 for x in self.site_atoms]\n    shelx_data = {\n        \"TITL\": self.titl if titl is None else titl,\n        \"CELL\": self.unit_cell.parameters,\n        \"SFAC\": [Element[x].symbol for x in sfac],\n        \"SYMM\": [\n            str(s)\n            for s in self.space_group.reduced_symmetry_operations()\n            if not s.is_identity()\n        ],\n        \"LATT\": self.space_group.latt,\n        \"ATOM\": [\n            \"{:3} {:3} {: 20.12f} {: 20.12f} {: 20.12f}\".format(l, s, *pos)\n            for l, s, pos in zip(\n                self.asymmetric_unit.labels,\n                atom_sfac,\n                self.site_positions,\n                strict=False,\n            )\n        ],\n    }\n    return to_res_contents(shelx_data)\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.to_translational_symmetry","title":"<code>to_translational_symmetry(supercell=(1, 1, 1))</code>","text":"<p>Create a supercell of this crystal in space group P 1.</p> <p>Parameters:</p> Name Type Description Default <code>supercell</code> <code>Tuple[int]</code> <p>size of the supercell to be created</p> <code>(1, 1, 1)</code> <p>Returns:</p> Type Description <code>Crystal</code> <p>Crystal object of a supercell in space group P 1</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def to_translational_symmetry(self, supercell=(1, 1, 1)) -&gt; \"Crystal\":\n    \"\"\"\n    Create a supercell of this crystal in space group P 1.\n\n    Args:\n        supercell (Tuple[int]): size of the supercell to be created\n\n    Returns:\n        Crystal object of a supercell in space group P 1\n    \"\"\"\n    from itertools import product\n\n    hmax, kmax, lmax = supercell\n    a, b, c = self.unit_cell.lengths\n    sc = UnitCell.from_lengths_and_angles(\n        (hmax * a, kmax * b, lmax * c), self.unit_cell.angles\n    )\n\n    h = np.arange(hmax)\n    k = np.arange(kmax)\n    l = np.arange(lmax)\n    molecules = []\n    for q, r, s in product(h, k, l):\n        for uc_mol in self.unit_cell_molecules():\n            molecules.append(\n                uc_mol.translated(np.asarray([q, r, s]) @ self.unit_cell.lattice)\n            )\n\n    asym_pos = np.vstack([x.positions for x in molecules])\n    asym_nums = np.hstack([x.atomic_numbers for x in molecules])\n    asymmetric_unit = AsymmetricUnit(\n        [Element[x] for x in asym_nums], sc.to_fractional(asym_pos)\n    )\n    new_titl = self.titl + \"_P1_supercell_{}_{}_{}\".format(*supercell)\n    new_crystal = Crystal(sc, SpaceGroup(1), asymmetric_unit, titl=new_titl)\n    return new_crystal\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.unit_cell_atoms","title":"<code>unit_cell_atoms(tolerance=0.01)</code>","text":"<p>Generate all atoms in the unit cell (i.e. with fractional coordinates in [0, 1]) along with associated information about symmetry operations, occupation, elements related asymmetric_unit atom etc.</p> <p>Will merge atom sites within tolerance of each other, and sum their occupation numbers. A warning will be logged if any atom site in the unit cell has &gt; 1.0 occupancy after this.</p> <p>Sets the <code>_unit_cell_atom_dict</code> member as this is an expensive operation and is worth caching the result. Subsequent calls to this function will be a no-op.</p> <p>Parameters:</p> Name Type Description Default <code>tolerance</code> <code>float</code> <p>Minimum separation of sites in the unit cell, below which atoms/sites will be merged and their (partial) occupations added.</p> <code>0.01</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of arrays associated with all sites contained</p> <code>dict</code> <p>in the unit cell of this crystal, members are:</p> <p>asym_atom: corresponding asymmetric unit atom indices for all sites. frac_pos: (N, 3) array of fractional positions for all sites. cart_pos: (N, 3) array of cartesian positions for all sites. element: (N) array of atomic numbers for all sites. symop: (N) array of indices corresponding to the generator symmetry operation for each site. label: (N) array of string labels corresponding to each site occupation: (N) array of occupation numbers for each site. Will     warn if any of these are greater than 1.0</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def unit_cell_atoms(self, tolerance=1e-2) -&gt; dict:\n    \"\"\"\n    Generate all atoms in the unit cell (i.e. with\n    fractional coordinates in [0, 1]) along with associated\n    information about symmetry operations, occupation, elements\n    related asymmetric_unit atom etc.\n\n    Will merge atom sites within tolerance of each other, and\n    sum their occupation numbers. A warning will be logged if\n    any atom site in the unit cell has &gt; 1.0 occupancy after\n    this.\n\n    Sets the `_unit_cell_atom_dict` member as this is an expensive\n    operation and is worth caching the result. Subsequent calls\n    to this function will be a no-op.\n\n    Arguments:\n        tolerance (float, optional): Minimum separation of sites in the unit\n            cell, below which atoms/sites will be merged and their (partial)\n            occupations added.\n\n    Returns:\n        A dictionary of arrays associated with all sites contained\n        in the unit cell of this crystal, members are:\n\n            asym_atom: corresponding asymmetric unit atom indices for all sites.\n            frac_pos: (N, 3) array of fractional positions for all sites.\n            cart_pos: (N, 3) array of cartesian positions for all sites.\n            element: (N) array of atomic numbers for all sites.\n            symop: (N) array of indices corresponding to the generator symmetry\n            operation for each site.\n            label: (N) array of string labels corresponding to each site\n            occupation: (N) array of occupation numbers for each site. Will\n                warn if any of these are greater than 1.0\n    \"\"\"\n\n    if hasattr(self, \"_unit_cell_atom_dict\"):\n        return self._unit_cell_atom_dict\n    pos = self.site_positions\n    atoms = self.site_atoms\n    natom = self.nsites\n    nsymops = len(self.space_group.symmetry_operations)\n    occupation = np.tile(\n        self.asymmetric_unit.properties.get(\"occupation\", np.ones(natom)), nsymops\n    )\n    labels = np.tile(self.asymmetric_unit.labels, nsymops)\n    uc_nums = np.tile(atoms, nsymops)\n    asym = np.arange(len(uc_nums)) % natom\n    sym, uc_pos = self.space_group.apply_all_symops(pos)\n    translated = np.fmod(uc_pos + 7.0, 1)\n    tree = KDTree(translated)\n    dist = tree.sparse_distance_matrix(tree, max_distance=tolerance)\n    mask = np.ones(len(uc_pos), dtype=bool)\n    # because crystals may have partially occupied sites\n    # on special positions, we need to merge some sites\n    # expected_natoms = np.sum(occupation)\n    for (i, j), _ in dist.items():\n        if not (i &lt; j):\n            continue\n        occupation[i] += occupation[j]\n        mask[j] = False\n    occupation = occupation[mask]\n    if np.any(occupation &gt; 1.0):\n        LOG.debug(\"Some unit cell site occupations are &gt; 1.0\")\n    self._unit_cell_atom_dict = {\n        \"asym_atom\": asym[mask],\n        \"frac_pos\": translated[mask],\n        \"element\": uc_nums[mask],\n        \"symop\": sym[mask],\n        \"label\": labels[mask],\n        \"occupation\": occupation,\n        \"cart_pos\": self.to_cartesian(translated[mask]),\n    }\n    return self._unit_cell_atom_dict\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.unit_cell_connectivity","title":"<code>unit_cell_connectivity(tolerance=0.4, neighbouring_cells=1, **kwargs)</code>","text":"<p>Periodic connectiviy for the unit cell, populates _uc_graph with a networkx.Graph object, where nodes are indices into the _unit_cell_atom_dict arrays and the edges contain the translation (cell) for the image of the corresponding unit cell atom with the higher index to be bonded to the lower</p> <p>Bonding is determined by interatomic distances being less than the sum of covalent radii for the sites plus the tolerance (provided as a parameter)</p> <p>Parameters:</p> Name Type Description Default <code>tolerance</code> <code>float</code> <p>Bonding tolerance (bonded if d &lt; cov_a + cov_b + tolerance)</p> <code>0.4</code> <code>neighbouring_cells</code> <code>int</code> <p>Number of neighbouring cells in which to look for bonded atoms. We start at the (0, 0, 0) cell, so a value of 1 will look in the (0, 0, 1), (0, 1, 1), (1, 1, 1) i.e. all 26 neighbouring cells. 1 is typically sufficient for organic systems.</p> <code>1</code> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple of (sparse_matrix in dict of keys format, dict)</p> <code>tuple</code> <p>the (i, j) value in this matrix is the bond length from i,j</p> <code>tuple</code> <p>the (i, j) value in the dict is the cell translation on j which</p> <code>tuple</code> <p>bonds these two sites</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def unit_cell_connectivity(\n    self, tolerance=0.4, neighbouring_cells=1, **kwargs\n) -&gt; tuple:\n    \"\"\"\n    Periodic connectiviy for the unit cell, populates _uc_graph\n    with a networkx.Graph object, where nodes are indices into the\n    _unit_cell_atom_dict arrays and the edges contain the translation\n    (cell) for the image of the corresponding unit cell atom with the\n    higher index to be bonded to the lower\n\n    Bonding is determined by interatomic distances being less than the\n    sum of covalent radii for the sites plus the tolerance (provided\n    as a parameter)\n\n    Arguments:\n        tolerance (float, optional):\n            Bonding tolerance (bonded if d &lt; cov_a + cov_b + tolerance)\n        neighbouring_cells (int, optional):\n            Number of neighbouring cells in which to look for bonded atoms.\n            We start at the (0, 0, 0) cell, so a value of 1 will look in the\n            (0, 0, 1), (0, 1, 1), (1, 1, 1) i.e. all 26 neighbouring cells.\n            1 is typically sufficient for organic systems.\n\n    Returns:\n        A tuple of (sparse_matrix in dict of keys format, dict)\n        the (i, j) value in this matrix is the bond length from i,j\n        the (i, j) value in the dict is the cell translation on j which\n        bonds these two sites\n    \"\"\"\n\n    if hasattr(self, \"_uc_graph\"):\n        return self._uc_graph\n    slab = self.slab(bounds=((-1, -1, -1), (1, 1, 1)))\n    n_uc = slab[\"n_uc\"]\n    uc_pos = slab[\"frac_pos\"][:n_uc]\n    uc_nums = slab[\"element\"][:n_uc]\n    neighbour_pos = slab[\"frac_pos\"][n_uc:]\n    cart_uc_pos = self.to_cartesian(uc_pos)\n    covalent_radii_dict = {\n        x: Element.from_atomic_number(x).cov for x in np.unique(uc_nums)\n    }\n    covalent_radii_dict.update(kwargs.get(\"covalent_radii\", {}))\n    # first establish all connections in the unit cell\n    covalent_radii = np.array([covalent_radii_dict[x] for x in uc_nums])\n    max_cov = np.max(covalent_radii)\n    # TODO this needs to be sped up for large cells, tends to slow for &gt; 1000 atoms\n    # and the space storage will become a problem\n    tree = KDTree(cart_uc_pos)\n    dist = tree.sparse_distance_matrix(tree, max_distance=2 * max_cov + tolerance)\n    uc_edges = []\n\n    for (i, j), d in dist.items():\n        if not (i &lt; j):\n            continue\n        if d &gt; 1e-3 and d &lt; (covalent_radii[i] + covalent_radii[j] + tolerance):\n            uc_edges.append((i, j, d, (0, 0, 0)))\n\n    cart_neighbour_pos = self.unit_cell.to_cartesian(neighbour_pos)\n    tree2 = KDTree(cart_neighbour_pos)\n    dist = tree.sparse_distance_matrix(tree2, max_distance=2 * max_cov + tolerance)\n    # could be sped up if done outside python\n    cells = slab[\"cell\"][n_uc:]\n    for (uc_atom, neighbour_atom), d in dist.items():\n        uc_idx = neighbour_atom % n_uc\n        if not (uc_atom &lt; uc_idx):\n            continue\n        if d &gt; 1e-3 and d &lt; (\n            covalent_radii[uc_atom] + covalent_radii[uc_idx] + tolerance\n        ):\n            cell = cells[neighbour_atom]\n            uc_edges.append((uc_atom, uc_idx, d, tuple(cell)))\n\n    properties = {}\n    uc_graph = dok_matrix((n_uc, n_uc))\n    for i, j, d, cell in uc_edges:\n        uc_graph[i, j] = d\n        properties[(i, j)] = cell\n\n    self._uc_graph = uc_graph, properties\n    return self._uc_graph\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.unit_cell_coordination_numbers","title":"<code>unit_cell_coordination_numbers()</code>","text":"<p>Calculate the coordination numbers for the unit cell atoms of this crystal using the EEQ method with periodic boundary conditions.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>an <code>ndarray</code> of coordination numbers for the unit cell atoms.</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def unit_cell_coordination_numbers(self) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the coordination numbers for the unit cell atoms of this\n    crystal using the EEQ method with periodic boundary conditions.\n\n    Returns:\n        an `ndarray` of coordination numbers for the unit cell atoms.\n    \"\"\"\n    if hasattr(self, \"_unit_cell_coordination_numbers\"):\n        return self._unit_cell_coordination_numbers\n\n    from chmpy.crystal.eeq_pbc import calculate_coordination_numbers_crystal\n\n    # Calculate coordination numbers with PBC\n    cn = calculate_coordination_numbers_crystal(self)\n    self._unit_cell_coordination_numbers = cn.astype(np.float32)\n\n    return self._unit_cell_coordination_numbers\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.unit_cell_molecules","title":"<code>unit_cell_molecules(bond_tolerance=0.4, **kwargs)</code>","text":"<p>Calculate the molecules for all sites in the unit cell, where the number of molecules will be equal to number of symmetry unique molecules times number of symmetry operations.</p> <p>Parameters:</p> Name Type Description Default <code>bond_tolerance</code> <code>float</code> <p>Bonding tolerance (bonded if d &lt; cov_a + cov_b + bond_tolerance)</p> <code>0.4</code> <p>Returns:</p> Type Description <code>list[Molecule]</code> <p>A list of all connected molecules in this crystal, which</p> <code>list[Molecule]</code> <p>when translated by the unit cell would produce the full crystal.</p> <code>list[Molecule]</code> <p>If the asymmetric is molecular, the list will be of length</p> <code>list[Molecule]</code> <p>num_molecules_in_asymmetric_unit * num_symm_operations</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def unit_cell_molecules(self, bond_tolerance=0.4, **kwargs) -&gt; list[Molecule]:\n    \"\"\"\n    Calculate the molecules for all sites in the unit cell,\n    where the number of molecules will be equal to number of\n    symmetry unique molecules times number of symmetry operations.\n\n    Args:\n        bond_tolerance (float, optional): Bonding tolerance\n            (bonded if d &lt; cov_a + cov_b + bond_tolerance)\n\n    Returns:\n        A list of all connected molecules in this crystal, which\n        when translated by the unit cell would produce the full crystal.\n        If the asymmetric is molecular, the list will be of length\n        num_molecules_in_asymmetric_unit * num_symm_operations\n    \"\"\"\n\n    if hasattr(self, \"_unit_cell_molecules\"):\n        return self._unit_cell_molecules\n    uc_graph, edge_cells = self.unit_cell_connectivity(\n        tolerance=bond_tolerance, **kwargs\n    )\n    n_uc_mols, uc_mols = csgraph.connected_components(\n        csgraph=uc_graph, directed=False, return_labels=True\n    )\n    uc_dict = self._unit_cell_atom_dict\n    uc_frac = uc_dict[\"frac_pos\"]\n    uc_elements = uc_dict[\"element\"]\n    uc_asym = uc_dict[\"asym_atom\"]\n    uc_symop = uc_dict[\"symop\"]\n\n    molecules = []\n\n    n_uc = len(uc_frac)\n    LOG.debug(\"%d molecules in unit cell\", n_uc_mols)\n    for i in range(n_uc_mols):\n        nodes = np.where(uc_mols == i)[0]\n        root = nodes[0]\n        elements = uc_elements[nodes]\n        shifts = np.zeros((n_uc, 3))\n        ordered, pred = csgraph.breadth_first_order(\n            csgraph=uc_graph, i_start=root, directed=False\n        )\n        for j in ordered[1:]:\n            i = pred[j]\n            if j &lt; i:\n                shifts[j, :] = shifts[i, :] - edge_cells[(j, i)]\n            else:\n                shifts[j, :] = shifts[i, :] + edge_cells[(i, j)]\n        positions = self.to_cartesian((uc_frac + shifts)[nodes])\n        asym_atoms = uc_asym[nodes]\n        reorder = np.argsort(asym_atoms)\n        asym_atoms = asym_atoms[reorder]\n        mol = Molecule.from_arrays(\n            elements=elements[reorder],\n            positions=positions[reorder],\n            guess_bonds=True,\n            unit_cell_atoms=np.array(nodes)[reorder],\n            asymmetric_unit_atoms=asym_atoms,\n            asymmetric_unit_labels=self.asymmetric_unit.labels[asym_atoms],\n            generator_symop=uc_symop[np.asarray(nodes)[reorder]],\n        )\n        centroid = mol.center_of_mass\n        frac_centroid = self.to_fractional(centroid)\n        new_centroid = np.fmod(frac_centroid + 7.0, 1.0)\n        translation = self.to_cartesian(new_centroid - frac_centroid)\n        mol.translate(translation)\n        molecules.append(mol)\n    self._unit_cell_molecules = molecules\n    return molecules\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.unit_cell_partial_charges","title":"<code>unit_cell_partial_charges(method='eeq')</code>","text":"<p>Calculate the partial charges for the unit cell atoms of this crystal using the specified method with periodic boundary conditions.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Charge method to use ('eeq' or 'eem')</p> <code>'eeq'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>an <code>ndarray</code> of partial charges for the unit cell atoms.</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def unit_cell_partial_charges(self, method=\"eeq\") -&gt; np.ndarray:\n    \"\"\"\n    Calculate the partial charges for the unit cell atoms of this\n    crystal using the specified method with periodic boundary conditions.\n\n    Args:\n        method (str): Charge method to use ('eeq' or 'eem')\n\n    Returns:\n        an `ndarray` of partial charges for the unit cell atoms.\n    \"\"\"\n    if hasattr(self, \"_unit_cell_partial_charges\"):\n        return self._unit_cell_partial_charges\n\n    method = method.lower()\n\n    if method == \"eeq\":\n        from chmpy.crystal.eeq_pbc import calculate_eeq_charges_pbc\n\n        # Get unit cell atoms\n        uc_atoms = self.unit_cell_atoms()\n        positions = uc_atoms[\"cart_pos\"]\n        atomic_numbers = uc_atoms[\"element\"]\n\n        # Get cell vectors\n        cell_vectors = self.unit_cell.lattice\n\n        # Calculate net charge (usually 0 for crystals)\n        charge = 0.0\n\n        # Calculate charges with PBC\n        charges = calculate_eeq_charges_pbc(\n            atomic_numbers, positions, cell_vectors, charge\n        )\n    else:\n        # Use molecular approach for EEM (less accurate for crystals)\n        mols = self.unit_cell_molecules()\n        charges = np.empty(len(self.unit_cell_atoms()[\"element\"]), dtype=np.float32)\n\n        # Set charge method for molecules\n        for mol in mols:\n            mol.properties[\"charge_method\"] = method\n\n        # Get charges from molecules\n        for mol in mols:\n            uc_indices = mol.properties.get(\"unit_cell_atoms\", [])\n            for i, charge in enumerate(mol.partial_charges):\n                if i &lt; len(uc_indices):\n                    charges[uc_indices[i]] = charge\n\n    self._unit_cell_partial_charges = charges.astype(np.float32)\n    return charges\n</code></pre>"},{"location":"reference/chmpy/crystal/crystal/#chmpy.crystal.crystal.Crystal.void_surface","title":"<code>void_surface(*args, **kwargs)</code>","text":"<p>Calculate void surface based on promolecule electron density for the unit cell of this crystal</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>Keyword arguments used in the evaluation of the surface.</p> <p>Options are: <pre><code>isovalue (float, optional): level set value for the\n    isosurface (default=0.002) in au.\nseparation (float, optional): separation between density grid\n    used in the surface calculation (default 0.2) in Angstroms.\n</code></pre></p> <code>{}</code> <p>Returns:</p> Type Description <code>Trimesh</code> <p>the mesh representing the promolecule density void isosurface</p> Source code in <code>chmpy/crystal/crystal.py</code> <pre><code>def void_surface(self, *args, **kwargs) -&gt; Trimesh:\n    \"\"\"\n    Calculate void surface based on promolecule electron density\n    for the unit cell of this crystal\n\n    Args:\n        kwargs: Keyword arguments used in the evaluation of the surface.\n\n            Options are:\n            ```\n            isovalue (float, optional): level set value for the\n                isosurface (default=0.002) in au.\n            separation (float, optional): separation between density grid\n                used in the surface calculation (default 0.2) in Angstroms.\n            ```\n\n    Returns:\n        the mesh representing the promolecule density void isosurface\n    \"\"\"\n\n    import trimesh\n\n    from chmpy import PromoleculeDensity\n    from chmpy.mc import marching_cubes\n\n    vertex_color = kwargs.get(\"color\", None)\n\n    atoms = self.slab(bounds=((-1, -1, -1), (1, 1, 1)))\n    density = PromoleculeDensity((atoms[\"element\"], atoms[\"cart_pos\"]))\n    sep = kwargs.get(\"separation\", kwargs.get(\"resolution\", 0.5))\n    isovalue = kwargs.get(\"isovalue\", 3e-4)\n    grid_type = kwargs.get(\"grid_type\", \"uc\")\n    if grid_type == \"uc\":\n        seps = sep / np.array(self.unit_cell.lengths)\n        x_grid = np.arange(0, 1.0, seps[0], dtype=np.float32)\n        y_grid = np.arange(0, 1.0, seps[1], dtype=np.float32)\n        z_grid = np.arange(0, 1.0, seps[2], dtype=np.float32)\n        x, y, z = np.meshgrid(x_grid, y_grid, z_grid)\n        shape = x.shape\n        pts = np.c_[x.ravel(), y.ravel(), z.ravel()]\n        pts = pts.astype(np.float32)\n        pts = self.to_cartesian(pts)\n    elif grid_type == \"box\":\n        ((x0, y0, z0), (x1, y1, z1)) = kwargs.get(\n            \"box_corners\", ((0.0, 0.0, 0.0), (5.0, 5.0, 5.0))\n        )\n        x, y, z = np.mgrid[x0:x1:sep, y0:y1:sep, z0:z1:sep]\n        pts = np.c_[x.ravel(), y.ravel(), z.ravel()]\n        pts = pts.astype(np.float32)\n        shape = x.shape\n        seps = (sep, sep, sep)\n    else:\n        raise NotImplementedError(\"Only uc grid supported currently\")\n    tree = KDTree(atoms[\"cart_pos\"])\n    distances, _ = tree.query(pts)\n    values = np.ones(pts.shape[0], dtype=np.float32)\n    mask = distances &gt; 1.0  # minimum bigger than 1 angstrom\n    rho = density.rho(pts[mask])\n    values[mask] = rho\n    values = values.reshape(shape)\n    verts, faces, normals, _ = marching_cubes(\n        values, isovalue, spacing=seps, gradient_direction=\"ascent\"\n    )\n    if grid_type == \"uc\":\n        verts = self.to_cartesian(np.c_[verts[:, 1], verts[:, 0], verts[:, 2]])\n    mesh = trimesh.Trimesh(vertices=verts, faces=faces, normals=normals)\n\n    if kwargs.get(\"subdivide\", False):\n        for _ in range(int(kwargs.get(\"subdivide\", False))):\n            mesh = mesh.subdivide()\n\n    if vertex_color == \"esp\":\n        from chmpy.util.color import property_to_color\n\n        asym_charges = self.asymmetric_unit_partial_charges()\n        mol = Molecule.from_arrays(atoms[\"element\"], atoms[\"cart_pos\"])\n        partial_charges = np.empty(len(mol), dtype=np.float32)\n        partial_charges = asym_charges[atoms[\"asym_atom\"]]\n        mol._partial_charges = partial_charges\n        prop = mol.electrostatic_potential(mesh.vertices)\n        mesh.visual.vertex_colors = property_to_color(\n            prop, cmap=kwargs.get(\"cmap\", \"esp\")\n        )\n    return mesh\n</code></pre>"},{"location":"reference/chmpy/crystal/eeq_pbc/","title":"eeq_pbc","text":""},{"location":"reference/chmpy/crystal/eeq_pbc/#chmpy.crystal.eeq_pbc.build_x_vector_crystal","title":"<code>build_x_vector_crystal(crystal, cn, charge=0.0)</code>","text":"<p>Build the X vector for EEQ charge calculation in periodic systems.</p> <p>Parameters:</p> Name Type Description Default <code>crystal</code> <p>The Crystal instance</p> required <code>cn</code> <code>ndarray</code> <p>Array of coordination numbers for each atom</p> required <code>charge</code> <code>float</code> <p>Total charge of the system</p> <code>0.0</code> <p>Returns:</p> Type Description <p>np.ndarray: X vector for the EEQ calculation</p> Source code in <code>chmpy/crystal/eeq_pbc.py</code> <pre><code>def build_x_vector_crystal(crystal, cn, charge=0.0):\n    \"\"\"\n    Build the X vector for EEQ charge calculation in periodic systems.\n\n    Args:\n        crystal: The Crystal instance\n        cn (np.ndarray): Array of coordination numbers for each atom\n        charge (float): Total charge of the system\n\n    Returns:\n        np.ndarray: X vector for the EEQ calculation\n    \"\"\"\n    # Get atomic numbers from unit cell\n    uc_atoms = crystal.unit_cell_atoms()\n    atomic_numbers = uc_atoms[\"element\"]\n    N = len(atomic_numbers)\n\n    eps = 1e-14  # Avoid singularity with 0\n    X = np.empty(N + 1)\n\n    # Chemical potential terms with coordination number correction\n    X[:N] = -CHI[atomic_numbers] + cn * KCN_PARAM[atomic_numbers] / np.sqrt(cn + eps)\n\n    # Total charge constraint\n    X[N] = charge\n\n    return X\n</code></pre>"},{"location":"reference/chmpy/crystal/eeq_pbc/#chmpy.crystal.eeq_pbc.calculate_coordination_numbers_crystal","title":"<code>calculate_coordination_numbers_crystal(crystal, cutoff=None)</code>","text":"<p>Calculate coordination numbers for all atoms in a crystal using the EEQ method.</p> <p>Parameters:</p> Name Type Description Default <code>crystal</code> <p>The Crystal instance</p> required <code>cutoff</code> <code>float</code> <p>Cutoff distance for neighbor search in Angstroms</p> <code>None</code> <p>Returns:</p> Type Description <p>np.ndarray: Array of coordination numbers for each atom</p> Source code in <code>chmpy/crystal/eeq_pbc.py</code> <pre><code>def calculate_coordination_numbers_crystal(crystal, cutoff=None):\n    \"\"\"\n    Calculate coordination numbers for all atoms in a crystal using the EEQ method.\n\n    Args:\n        crystal: The Crystal instance\n        cutoff (float): Cutoff distance for neighbor search in Angstroms\n\n    Returns:\n        np.ndarray: Array of coordination numbers for each atom\n    \"\"\"\n    kcn_value = 7.5  # Constant from the C++ implementation\n\n    # Get atomic numbers\n    uc_atoms = crystal.unit_cell_atoms()\n    atomic_numbers = uc_atoms[\"element\"]\n    N = len(atomic_numbers)\n    uc_cov = COVALENT_D3[atomic_numbers]\n\n    # Initialize coordination numbers\n    cn = np.zeros(N)\n\n    if cutoff is None:\n        cutoff = np.max(uc_cov) * 4  # 1.4 * sum of cov should give around erf(-3)\n\n    # Find all neighbors within cutoff distance\n    neighbors = find_neighbors_pbc(crystal, cutoff)\n\n    for i, atom_neighbors in enumerate(neighbors):\n        if atom_neighbors.shape[0] &lt; 1:\n            continue\n        rc = (\n            uc_cov[i] + COVALENT_D3[atom_neighbors[:, 1].astype(int)]\n        ) * ANGSTROM_TO_BOHR\n\n        dists = atom_neighbors[:, 2] * ANGSTROM_TO_BOHR\n\n        count = 0.5 * (1.0 + erf(-kcn_value * (dists - rc) / rc))\n\n        cn[i] += 0.5 * count.sum()\n        cn[atom_neighbors[:, 0].astype(int)] += 0.5 * count[:]\n\n    return cn\n</code></pre>"},{"location":"reference/chmpy/crystal/eeq_pbc/#chmpy.crystal.eeq_pbc.calculate_eeq_charges_crystal","title":"<code>calculate_eeq_charges_crystal(crystal, charge=0.0, cutoff=12.0)</code>","text":"<p>Calculate EEQ partial charges for a crystal structure.</p> <p>Parameters:</p> Name Type Description Default <code>crystal</code> <p>The Crystal instance</p> required <code>charge</code> <code>float</code> <p>Total charge of the system</p> <code>0.0</code> <code>cutoff</code> <code>float</code> <p>Cutoff distance for neighbor search in Angstroms</p> <code>12.0</code> <p>Returns:</p> Type Description <p>np.ndarray: Array of partial charges for each atom in the unit cell</p> Source code in <code>chmpy/crystal/eeq_pbc.py</code> <pre><code>def calculate_eeq_charges_crystal(crystal, charge=0.0, cutoff=12.0):\n    \"\"\"\n    Calculate EEQ partial charges for a crystal structure.\n\n    Args:\n        crystal: The Crystal instance\n        charge (float): Total charge of the system\n        cutoff (float): Cutoff distance for neighbor search in Angstroms\n\n    Returns:\n        np.ndarray: Array of partial charges for each atom in the unit cell\n    \"\"\"\n    # Calculate coordination numbers\n    cn = calculate_coordination_numbers_crystal(crystal, cutoff=None)\n\n    # Build A matrix\n    A = build_a_matrix_crystal(crystal, cutoff=cutoff)\n\n    # Build X vector\n    X = build_x_vector_crystal(crystal, cn, charge)\n\n    # Solve linear system A * Q = X\n    Q = np.linalg.solve(A, X)\n\n    # Return charges (excluding Lagrange multiplier)\n    return Q[:-1]\n</code></pre>"},{"location":"reference/chmpy/crystal/eeq_pbc/#chmpy.crystal.eeq_pbc.find_neighbors_pbc","title":"<code>find_neighbors_pbc(crystal, cutoff=6.0)</code>","text":"<p>Find all neighbors within a cutoff distance considering periodic boundary conditions. This is based on the unit_cell_connectivity method but optimized for EEQ calculations.</p> <p>Parameters:</p> Name Type Description Default <code>crystal</code> <p>The Crystal instance</p> required <code>cutoff</code> <code>float</code> <p>Maximum distance to consider for neighbors in Angstroms</p> <code>6.0</code> <p>Returns:</p> Name Type Description <code>list</code> <p>List of tuples (i, j, distance, cell_translation) for all neighbor pairs</p> Source code in <code>chmpy/crystal/eeq_pbc.py</code> <pre><code>def find_neighbors_pbc(crystal, cutoff=6.0):\n    \"\"\"\n    Find all neighbors within a cutoff distance considering periodic boundary conditions.\n    This is based on the unit_cell_connectivity method but optimized for EEQ calculations.\n\n    Args:\n        crystal: The Crystal instance\n        cutoff (float): Maximum distance to consider for neighbors in Angstroms\n\n    Returns:\n        list: List of tuples (i, j, distance, cell_translation) for all neighbor pairs\n    \"\"\"\n\n    frac_cutoff = cutoff / np.array(crystal.unit_cell.lengths)\n    bounds = (\n        np.floor(-frac_cutoff).astype(int) - 1,\n        np.ceil(frac_cutoff).astype(int) + 1,\n    )\n\n    slab = crystal.slab(bounds=bounds)\n\n    n_uc = slab[\"n_uc\"]\n    uc_nums = slab[\"element\"][:n_uc]\n    uc_pos = crystal.to_cartesian(slab[\"frac_pos\"][:n_uc])\n    nums = slab[\"element\"]\n    neighbour_pos = crystal.to_cartesian(slab[\"frac_pos\"][n_uc:])\n\n    tree_uc = KDTree(uc_pos)\n\n    dist_uc = tree_uc.sparse_distance_matrix(tree_uc, max_distance=cutoff)\n\n    neighbors = [[] for _ in range(n_uc)]\n    for (i, j), d in dist_uc.items():\n        if d &gt; 1e-3:\n            neighbors[i].append((j, nums[j], d))\n\n    tree_neighbors = KDTree(neighbour_pos)\n    dist_neighbors = tree_uc.sparse_distance_matrix(tree_neighbors, max_distance=cutoff)\n\n    for (uc_atom, neighbor_atom), d in dist_neighbors.items():\n        uc_idx = neighbor_atom % n_uc\n        if d &gt; 1e-3:\n            neighbors[uc_atom].append((uc_idx, uc_nums[uc_idx], d))\n\n    return [np.array(n) for n in neighbors]\n</code></pre>"},{"location":"reference/chmpy/crystal/fingerprint/","title":"fingerprint","text":""},{"location":"reference/chmpy/crystal/fingerprint/#chmpy.crystal.fingerprint.filtered_histogram","title":"<code>filtered_histogram(mesh, internal, external, bins=200, xrange=None, yrange=None, samples_per_edge=4)</code>","text":"<p>Create histogram with multiple samples per face.</p> Source code in <code>chmpy/crystal/fingerprint.py</code> <pre><code>def filtered_histogram(\n    mesh, internal, external, bins=200, xrange=None, yrange=None, samples_per_edge=4\n):\n    \"\"\"Create histogram with multiple samples per face.\"\"\"\n    di = mesh.vertex_attributes[\"d_i\"]\n    de = mesh.vertex_attributes[\"d_e\"]\n    if xrange is None:\n        xrange = np.min(di), np.max(di)\n    if yrange is None:\n        yrange = np.min(de), np.max(de)\n\n    di_atom = mesh.vertex_attributes[\"nearest_atom_internal\"]\n    de_atom = mesh.vertex_attributes[\"nearest_atom_external\"]\n    vertex_mask = (de_atom == external) &amp; (di_atom == internal)\n\n    face_mask = np.any(vertex_mask[mesh.faces], axis=1)\n    filtered_faces = mesh.faces[face_mask]\n\n    if len(filtered_faces) == 0:\n        return np.histogram2d([], [], bins=bins, range=(xrange, yrange))\n\n    vertices = np.stack([di, de], axis=1)\n\n    interpolated, weights = sample_face_points(\n        vertices, filtered_faces, samples_per_edge\n    )\n\n    di_samples = interpolated[..., 0].flatten()\n    de_samples = interpolated[..., 1].flatten()\n\n    weights_tiled = np.tile(weights, len(filtered_faces))\n\n    return np.histogram2d(\n        di_samples, de_samples, bins=bins, range=(xrange, yrange), weights=weights_tiled\n    )\n</code></pre>"},{"location":"reference/chmpy/crystal/fingerprint/#chmpy.crystal.fingerprint.fingerprint_histogram","title":"<code>fingerprint_histogram(mesh, bins=200, xrange=None, yrange=None, samples_per_edge=4)</code>","text":"<p>Create histogram for all faces with multiple samples per face.</p> Source code in <code>chmpy/crystal/fingerprint.py</code> <pre><code>def fingerprint_histogram(mesh, bins=200, xrange=None, yrange=None, samples_per_edge=4):\n    \"\"\"Create histogram for all faces with multiple samples per face.\"\"\"\n    di = mesh.vertex_attributes[\"d_i\"]\n    de = mesh.vertex_attributes[\"d_e\"]\n    if xrange is None:\n        xrange = np.min(di), np.max(di)\n    if yrange is None:\n        yrange = np.min(de), np.max(de)\n\n    vertices = np.stack([di, de], axis=1)\n\n    interpolated, weights = sample_face_points(vertices, mesh.faces, samples_per_edge)\n\n    di_samples = interpolated[..., 0].flatten()\n    de_samples = interpolated[..., 1].flatten()\n\n    weights_tiled = np.tile(weights, len(mesh.faces))\n\n    return np.histogram2d(\n        di_samples, de_samples, bins=bins, range=(xrange, yrange), weights=weights_tiled\n    )\n</code></pre>"},{"location":"reference/chmpy/crystal/fingerprint/#chmpy.crystal.fingerprint.sample_face_points","title":"<code>sample_face_points(vertices, faces, samples_per_edge=4)</code>","text":"<p>Generate sample points within triangle faces using barycentric coordinates.</p> Source code in <code>chmpy/crystal/fingerprint.py</code> <pre><code>def sample_face_points(vertices, faces, samples_per_edge=4):\n    \"\"\"Generate sample points within triangle faces using barycentric coordinates.\"\"\"\n    points = []\n    weights = []\n\n    for i in range(samples_per_edge + 1):\n        for j in range(samples_per_edge + 1 - i):\n            a = i / samples_per_edge\n            b = j / samples_per_edge\n            c = 1.0 - a - b\n            points.append([a, b, c])\n            weights.append(1.0 / ((samples_per_edge + 1) * (samples_per_edge + 2) / 2))\n\n    points = np.array(points)\n    weights = np.array(weights)\n\n    face_vertices = vertices[faces]\n\n    points = points[:, None, :]\n\n    interpolated = np.sum(points[..., None] * face_vertices[None, ...], axis=2)\n\n    return interpolated, weights\n</code></pre>"},{"location":"reference/chmpy/crystal/point_group/","title":"point_group","text":""},{"location":"reference/chmpy/crystal/powder/","title":"powder","text":""},{"location":"reference/chmpy/crystal/space_group/","title":"space_group","text":""},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup","title":"<code>SpaceGroup</code>","text":"<p>Represent a crystallographic space group, including all necessary symmetry operations in fractional coordinates, the international tables number from 1-230, and the international tables symbol.</p> <p>Attributes:</p> Name Type Description <code>symbol</code> <code>str</code> <p>The international tables short space group symbol</p> <code>full_symbol</code> <code>str</code> <p>The full international tables space group symbol</p> <code>choice</code> <code>str</code> <p>The space group choice (if applicable)</p> <code>centering</code> <code>str</code> <p>The space group centering (if applicable)</p> <code>schoenflies</code> <code>str</code> <p>The Schoenflies space group symbol</p> <code>centrosymmetric</code> <code>bool</code> <p>Whether or not the space group is centrosymmetric</p> <code>symmetry_operations</code> <code>List[SymmetryOperation]</code> <p>List of symmetry operations making up this space group</p> Source code in <code>chmpy/crystal/space_group.py</code> <pre><code>class SpaceGroup:\n    \"\"\"\n    Represent a crystallographic space group, including\n    all necessary symmetry operations in fractional coordinates,\n    the international tables number from 1-230, and the international\n    tables symbol.\n\n    Attributes:\n        symbol (str): The international tables short space group symbol\n        full_symbol (str): The full international tables space group symbol\n        choice (str): The space group choice (if applicable)\n        centering (str): The space group centering (if applicable)\n        schoenflies (str): The Schoenflies space group symbol\n        centrosymmetric (bool): Whether or not the space group is centrosymmetric\n        symmetry_operations (List[SymmetryOperation]): List of symmetry operations\n            making up this space group\n    \"\"\"\n\n    def __init__(self, international_tables_number, choice=\"\"):\n        if international_tables_number &lt; 1 or international_tables_number &gt; 230:\n            raise ValueError(\"Space group number must be between [1, 230]\")\n        self.international_tables_number = international_tables_number\n        if international_tables_number in SG_DEFAULT_SETTING_CHOICE and not choice:\n            choice = SG_DEFAULT_SETTING_CHOICE[international_tables_number]\n        if not choice:\n            sgdata = SG_FROM_NUMBER[str(international_tables_number)][0]\n        else:\n            candidates = SG_FROM_NUMBER[str(international_tables_number)]\n            for candidate in candidates:\n                if choice == candidate.choice:\n                    sgdata = candidate\n                    break\n            else:\n                raise ValueError(f\"Could not find choice {choice}\")\n        self.symbol = sgdata.short\n        self.full_symbol = sgdata.full\n        self.choice = sgdata.choice\n        self.centering = sgdata.centering\n        if choice not in (\"b\", \"c\", \"R\"):\n            choice = None\n        self._point_group = PointGroup.from_number(sgdata.pointgroup, choice=choice)\n        self.schoenflies = sgdata.schoenflies\n        self.centrosymmetric = sgdata.centrosymmetric\n        symops = sgdata.symops\n        self.symmetry_operations = [\n            SymmetryOperation.from_integer_code(s) for s in symops\n        ]\n        self._sgdata = sgdata\n\n    @property\n    def cif_section(self) -&gt; str:\n        \"Representation of the SpaceGroup in CIF files\"\n        return \"\\n\".join(\n            f\"{i} {sym.cif_form}\"\n            for i, sym in enumerate(self.symmetry_operations, start=1)\n        )\n\n    def crystal17_spacegroup_symbol(self):\n        tokens = []\n        s = self._sgdata.international.upper()\n        if \"=\" in s:\n            s = s.split(\"=\")[-1]\n        s = iter(s)\n        for ch in s:\n            if ch == \"_\":\n                tokens[-1] += next(s)\n            elif ch == \"/\":\n                tokens[-1] += ch + next(s)\n            elif ch == \"-\":\n                tokens.append(ch + next(s))\n            else:\n                tokens.append(ch)\n        return \" \".join(tokens)\n\n    @property\n    def crystal_system(self) -&gt; str:\n        \"The crystal system of the space group e.g. triclinic, monoclinic etc.\"\n        sg = self.international_tables_number\n        if sg &lt;= 0 or sg &gt;= 231:\n            raise ValueError(\"International spacegroup number must be between 1-230\")\n        if sg &lt;= 2:\n            return \"triclinic\"\n        if sg &lt;= 16:\n            return \"monoclinic\"\n        if sg &lt;= 74:\n            return \"orthorhombic\"\n        if sg &lt;= 142:\n            return \"tetragonal\"\n        if sg &lt;= 167:\n            return \"trigonal\"\n        if sg &lt;= 194:\n            return \"hexagonal\"\n        return \"cubic\"\n\n    @property\n    def point_group(self):\n        \"the point group of this space group\"\n        return self._point_group\n\n    @property\n    def pg(self):\n        \"alias for `self.point_group`\"\n        return self._point_group\n\n    @property\n    def sym(self) -&gt; str:\n        \"alias for `self.symbol`\"\n        return self.symbol\n\n    @property\n    def symbol_unicode(self) -&gt; str:\n        \"the space group symbol with unicode subscripts\"\n        symbol = deepcopy(self.full_symbol)\n        if \"_\" in symbol:\n            tokens = symbol.split(\"_\")\n            symbol = tokens[0] + \"\".join(subscript(x[0]) + x[1:] for x in tokens[1:])\n        if \"-\" in symbol:\n            tokens = symbol.split(\"-\")\n            symbol = tokens[0] + \"\".join(overline(x[0]) + x[1:] for x in tokens[1:])\n        return symbol\n\n    @property\n    def symops(self):\n        \"alias for `self.symmetry_operations`\"\n        return self.symmetry_operations\n\n    @property\n    def laue_class(self) -&gt; str:\n        \"the Laue class of the point group associated with this space group\"\n        return self._point_group.laue_group\n\n    @property\n    def lattice_type(self) -&gt; str:\n        \"the lattice type of this space group e.g. rhombohedral, hexagonal etc.\"\n        inum = self.international_tables_number\n        if inum &lt; 143 or inum &gt; 194:\n            return self.crystal_system\n        if inum in (146, 148, 155, 160, 161, 166, 167):\n            if self.choice == \"H\":\n                return \"hexagonal\"\n            elif self.choice == \"R\":\n                return \"rhombohedral\"\n        else:\n            return \"hexagonal\"\n\n    @property\n    def latt(self) -&gt; int:\n        \"\"\"\n        The SHELX LATT number associated with this space group. Returns\n        a negative if there is no inversion.\n\n        Options are\n        ```\n        1: P,\n        2: I,\n        3: rhombohedral obverse on hexagonal axes,\n        4: F,\n        5: A,\n        6: B,\n        7: C\n        ```\n\n        Examples:\n            &gt;&gt;&gt; P1 = SpaceGroup(1)\n            &gt;&gt;&gt; P21c = SpaceGroup(14)\n            &gt;&gt;&gt; I41 = SpaceGroup(14)\n            &gt;&gt;&gt; R3bar = SpaceGroup(148)\n            &gt;&gt;&gt; P1.latt\n            -1\n            &gt;&gt;&gt; P21c.latt\n            1\n            &gt;&gt;&gt; R3bar.latt\n            3\n\n        Returns:\n            int: the SHELX LATT number of this space group\n        \"\"\"\n        centering_to_latt = {\n            \"primitive\": 1,  # P\n            \"body\": 2,  # I\n            \"rcenter\": 3,  # R\n            \"face\": 4,  # F\n            \"aface\": 5,  # A\n            \"bface\": 6,  # B\n            \"cface\": 7,  # C\n        }\n        if not self.centrosymmetric:\n            return -centering_to_latt[self.centering]\n        return centering_to_latt[self.centering]\n\n    def __len__(self):\n        return len(self.symmetry_operations)\n\n    def ordered_symmetry_operations(self):\n        \"The symmetry operations of this space group in order (with identiy first)\"\n        # make sure we do the unit symop first\n        unity = 0\n        for i, s in enumerate(self.symmetry_operations):\n            if s.is_identity():\n                unity = i\n                break\n        else:\n            raise ValueError(\n                \"Could not find identity symmetry_operation -- invalide space group\"\n            )\n        other_symops = (\n            self.symmetry_operations[:unity] + self.symmetry_operations[unity + 1 :]\n        )\n        return [self.symmetry_operations[unity]] + other_symops\n\n    def apply_all_symops(self, coordinates: np.ndarray):\n        \"\"\"\n        For a given set of coordinates, apply all symmetry\n        operations in this space group, yielding a set subject\n        to only translational symmetry (i.e. a unit cell).\n        Assumes the input coordinates are fractional.\n\n        Args:\n            coordinates (np.ndarray): (N, 3) set of fractional coordinates\n\n        Returns:\n            Tuple[np.ndarray, np.ndarray]: a (MxN) array of generator symop integers\n                and an (MxN, 3) array of coordinates where M is the number of symmetry\n                operations in this space group.\n        \"\"\"\n        nsites = len(coordinates)\n        transformed = np.empty((nsites * len(self), 3))\n        generator_symop = np.empty(nsites * len(self), dtype=np.int32)\n\n        # make sure we do the unit symop first\n        unity = 0\n        for i, s in enumerate(self.symmetry_operations):\n            if s.integer_code == 16484:\n                unity = i\n                break\n        transformed[0:nsites] = coordinates\n        generator_symop[0:nsites] = 16484\n        other_symops = (\n            self.symmetry_operations[:unity] + self.symmetry_operations[unity + 1 :]\n        )\n        for i, s in enumerate(other_symops, start=1):\n            transformed[i * nsites : (i + 1) * nsites] = s(coordinates)\n            generator_symop[i * nsites : (i + 1) * nsites] = s.integer_code\n        return generator_symop, transformed\n\n    def __repr__(self):\n        return f\"&lt;{self.__class__.__name__} {self.international_tables_number}: {self.full_symbol}&gt;\"\n\n    def __eq__(self, other):\n        return (\n            self.international_tables_number == other.international_tables_number\n        ) and (self.choice == other.choice)\n\n    def __hash__(self):\n        return hash((self.international_tables_number, self.choice))\n\n    def reduced_symmetry_operations(self):\n        \"returns a reduced list of symmetry operations\"\n        return reduced_symmetry_list(self.symmetry_operations, self.latt)\n\n    def has_hexagonal_rhombohedral_choices(self) -&gt; bool:\n        \"returns true if this space group could be\"\n        \"represented as hexagonal or rhombohedral\"\n        return self.international_tables_number in (146, 148, 155, 160, 161, 166, 167)\n\n    @classmethod\n    def from_symmetry_operations(cls, symops, expand_latt=None):\n        \"\"\"\n        Find a matching spacegroup for a given set of symmetry\n        operations, optionally treating them as a reduced set of\n        symmetry operations and expanding them based on the lattice\n        type.\n\n        Args:\n            symops (List[SymmetryOperation]): a reduced or full list\n                of symmetry operations\n            expand_latt (int, optional): the SHELX LATT number to expand\n                this list of symmetry operations\n\n        Returns:\n            SpaceGroup: the matching `SpaceGroup` for the provided symmetry\n                operations and LATT\n\n        \"\"\"\n        if expand_latt is not None:\n            if not -8 &lt; expand_latt &lt; 8:\n                raise ValueError(\"expand_latt must be between [-7, 7]\")\n            symops = expanded_symmetry_list(symops, expand_latt)\n        encoded = tuple(sorted(s.integer_code for s in symops))\n        if encoded not in SG_FROM_SYMOPS:\n            raise ValueError(\n                \"Could not find matching spacegroup for \"\n                \"the following symops:\\n{}\".format(\n                    \"\\n\".join(str(s) for s in sorted(symops))\n                )\n            )\n        else:\n            sgdata = SG_FROM_SYMOPS[encoded]\n            return SpaceGroup(sgdata.number, choice=sgdata.choice)\n\n    @classmethod\n    def from_symbol(cls, symbol):\n        symbol = symbol.replace(\" \", \"\")\n        sgdata = SG_FROM_SYMBOL.get(symbol, None)\n        special_cases = {\n            \"P21/a\": \"P12_1/a1\",\n            \"P21/n\": \"P12_1/n1\",\n        }\n        symbol = special_cases.get(symbol, symbol)\n        if sgdata is None:\n            for number, groups in SG_FROM_NUMBER.items():\n                if int(number) &gt; 14:\n                    continue\n                for g in groups:\n                    intl = g.international.split(\"=\")[-1]\n                    if symbol == intl:\n                        sgdata = g\n                        break\n                    elif symbol == intl.replace(\"_\", \"\"):\n                        sgdata = g\n                        break\n                if sgdata is not None:\n                    break\n            else:\n                raise ValueError(f\"Could not find matching space group for '{symbol}'\")\n\n        return SpaceGroup(sgdata.number, choice=sgdata.choice)\n</code></pre>"},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.cif_section","title":"<code>cif_section</code>  <code>property</code>","text":"<p>Representation of the SpaceGroup in CIF files</p>"},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.crystal_system","title":"<code>crystal_system</code>  <code>property</code>","text":"<p>The crystal system of the space group e.g. triclinic, monoclinic etc.</p>"},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.latt","title":"<code>latt</code>  <code>property</code>","text":"<p>The SHELX LATT number associated with this space group. Returns a negative if there is no inversion.</p> <p>Options are <pre><code>1: P,\n2: I,\n3: rhombohedral obverse on hexagonal axes,\n4: F,\n5: A,\n6: B,\n7: C\n</code></pre></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; P1 = SpaceGroup(1)\n&gt;&gt;&gt; P21c = SpaceGroup(14)\n&gt;&gt;&gt; I41 = SpaceGroup(14)\n&gt;&gt;&gt; R3bar = SpaceGroup(148)\n&gt;&gt;&gt; P1.latt\n-1\n&gt;&gt;&gt; P21c.latt\n1\n&gt;&gt;&gt; R3bar.latt\n3\n</code></pre> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the SHELX LATT number of this space group</p>"},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.lattice_type","title":"<code>lattice_type</code>  <code>property</code>","text":"<p>the lattice type of this space group e.g. rhombohedral, hexagonal etc.</p>"},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.laue_class","title":"<code>laue_class</code>  <code>property</code>","text":"<p>the Laue class of the point group associated with this space group</p>"},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.pg","title":"<code>pg</code>  <code>property</code>","text":"<p>alias for <code>self.point_group</code></p>"},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.point_group","title":"<code>point_group</code>  <code>property</code>","text":"<p>the point group of this space group</p>"},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.sym","title":"<code>sym</code>  <code>property</code>","text":"<p>alias for <code>self.symbol</code></p>"},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.symbol_unicode","title":"<code>symbol_unicode</code>  <code>property</code>","text":"<p>the space group symbol with unicode subscripts</p>"},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.symops","title":"<code>symops</code>  <code>property</code>","text":"<p>alias for <code>self.symmetry_operations</code></p>"},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.apply_all_symops","title":"<code>apply_all_symops(coordinates)</code>","text":"<p>For a given set of coordinates, apply all symmetry operations in this space group, yielding a set subject to only translational symmetry (i.e. a unit cell). Assumes the input coordinates are fractional.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>ndarray</code> <p>(N, 3) set of fractional coordinates</p> required <p>Returns:</p> Type Description <p>Tuple[np.ndarray, np.ndarray]: a (MxN) array of generator symop integers and an (MxN, 3) array of coordinates where M is the number of symmetry operations in this space group.</p> Source code in <code>chmpy/crystal/space_group.py</code> <pre><code>def apply_all_symops(self, coordinates: np.ndarray):\n    \"\"\"\n    For a given set of coordinates, apply all symmetry\n    operations in this space group, yielding a set subject\n    to only translational symmetry (i.e. a unit cell).\n    Assumes the input coordinates are fractional.\n\n    Args:\n        coordinates (np.ndarray): (N, 3) set of fractional coordinates\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: a (MxN) array of generator symop integers\n            and an (MxN, 3) array of coordinates where M is the number of symmetry\n            operations in this space group.\n    \"\"\"\n    nsites = len(coordinates)\n    transformed = np.empty((nsites * len(self), 3))\n    generator_symop = np.empty(nsites * len(self), dtype=np.int32)\n\n    # make sure we do the unit symop first\n    unity = 0\n    for i, s in enumerate(self.symmetry_operations):\n        if s.integer_code == 16484:\n            unity = i\n            break\n    transformed[0:nsites] = coordinates\n    generator_symop[0:nsites] = 16484\n    other_symops = (\n        self.symmetry_operations[:unity] + self.symmetry_operations[unity + 1 :]\n    )\n    for i, s in enumerate(other_symops, start=1):\n        transformed[i * nsites : (i + 1) * nsites] = s(coordinates)\n        generator_symop[i * nsites : (i + 1) * nsites] = s.integer_code\n    return generator_symop, transformed\n</code></pre>"},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.from_symmetry_operations","title":"<code>from_symmetry_operations(symops, expand_latt=None)</code>  <code>classmethod</code>","text":"<p>Find a matching spacegroup for a given set of symmetry operations, optionally treating them as a reduced set of symmetry operations and expanding them based on the lattice type.</p> <p>Parameters:</p> Name Type Description Default <code>symops</code> <code>List[SymmetryOperation]</code> <p>a reduced or full list of symmetry operations</p> required <code>expand_latt</code> <code>int</code> <p>the SHELX LATT number to expand this list of symmetry operations</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SpaceGroup</code> <p>the matching <code>SpaceGroup</code> for the provided symmetry operations and LATT</p> Source code in <code>chmpy/crystal/space_group.py</code> <pre><code>@classmethod\ndef from_symmetry_operations(cls, symops, expand_latt=None):\n    \"\"\"\n    Find a matching spacegroup for a given set of symmetry\n    operations, optionally treating them as a reduced set of\n    symmetry operations and expanding them based on the lattice\n    type.\n\n    Args:\n        symops (List[SymmetryOperation]): a reduced or full list\n            of symmetry operations\n        expand_latt (int, optional): the SHELX LATT number to expand\n            this list of symmetry operations\n\n    Returns:\n        SpaceGroup: the matching `SpaceGroup` for the provided symmetry\n            operations and LATT\n\n    \"\"\"\n    if expand_latt is not None:\n        if not -8 &lt; expand_latt &lt; 8:\n            raise ValueError(\"expand_latt must be between [-7, 7]\")\n        symops = expanded_symmetry_list(symops, expand_latt)\n    encoded = tuple(sorted(s.integer_code for s in symops))\n    if encoded not in SG_FROM_SYMOPS:\n        raise ValueError(\n            \"Could not find matching spacegroup for \"\n            \"the following symops:\\n{}\".format(\n                \"\\n\".join(str(s) for s in sorted(symops))\n            )\n        )\n    else:\n        sgdata = SG_FROM_SYMOPS[encoded]\n        return SpaceGroup(sgdata.number, choice=sgdata.choice)\n</code></pre>"},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.has_hexagonal_rhombohedral_choices","title":"<code>has_hexagonal_rhombohedral_choices()</code>","text":"<p>returns true if this space group could be</p> Source code in <code>chmpy/crystal/space_group.py</code> <pre><code>def has_hexagonal_rhombohedral_choices(self) -&gt; bool:\n    \"returns true if this space group could be\"\n    \"represented as hexagonal or rhombohedral\"\n    return self.international_tables_number in (146, 148, 155, 160, 161, 166, 167)\n</code></pre>"},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.ordered_symmetry_operations","title":"<code>ordered_symmetry_operations()</code>","text":"<p>The symmetry operations of this space group in order (with identiy first)</p> Source code in <code>chmpy/crystal/space_group.py</code> <pre><code>def ordered_symmetry_operations(self):\n    \"The symmetry operations of this space group in order (with identiy first)\"\n    # make sure we do the unit symop first\n    unity = 0\n    for i, s in enumerate(self.symmetry_operations):\n        if s.is_identity():\n            unity = i\n            break\n    else:\n        raise ValueError(\n            \"Could not find identity symmetry_operation -- invalide space group\"\n        )\n    other_symops = (\n        self.symmetry_operations[:unity] + self.symmetry_operations[unity + 1 :]\n    )\n    return [self.symmetry_operations[unity]] + other_symops\n</code></pre>"},{"location":"reference/chmpy/crystal/space_group/#chmpy.crystal.space_group.SpaceGroup.reduced_symmetry_operations","title":"<code>reduced_symmetry_operations()</code>","text":"<p>returns a reduced list of symmetry operations</p> Source code in <code>chmpy/crystal/space_group.py</code> <pre><code>def reduced_symmetry_operations(self):\n    \"returns a reduced list of symmetry operations\"\n    return reduced_symmetry_list(self.symmetry_operations, self.latt)\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/","title":"symmetry_operation","text":""},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation","title":"<code>SymmetryOperation</code>","text":"<p>Class to represent a crystallographic symmetry operation, composed of a rotation and a translation.</p> <p>Attributes:</p> Name Type Description <code>rotation</code> <code>ndarray</code> <p>(3, 3) rotation matrix in fractional coordinates</p> <code>translation</code> <code>ndarray</code> <p>(3) translation vector in fractional coordinates</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>class SymmetryOperation:\n    \"\"\"\n    Class to represent a crystallographic symmetry operation,\n    composed of a rotation and a translation.\n\n    Attributes:\n        rotation (np.ndarray): (3, 3) rotation matrix in fractional coordinates\n        translation (np.ndarray): (3) translation vector in fractional coordinates\n    \"\"\"\n\n    rotation: np.ndarray\n    translation: np.ndarray\n\n    def __init__(self, rotation, translation):\n        \"\"\"\n        Construct a new symmetry operation from a rotation matrix and\n        a translation vector\n\n        Arguments:\n            rotation (np.ndarray): (3, 3) rotation matrix\n            translation (np.ndarray): (3) translation vector\n\n        Returns:\n            SymmetryOperation: a new SymmetryOperation\n        \"\"\"\n        self.rotation = rotation\n        self.translation = translation % 1\n\n    @property\n    def seitz_matrix(self) -&gt; np.ndarray:\n        \"The Seitz matrix form of this SymmetryOperation\"\n        s = np.eye(4, dtype=np.float64)\n        s[:3, :3] = self.rotation\n        s[:3, 3] = self.translation\n        return s\n\n    @property\n    def integer_code(self) -&gt; int:\n        \"Represent this SymmetryOperation as a packed integer\"\n        if not hasattr(self, \"_integer_code\"):\n            self._integer_code = encode_symm_int(self.rotation, self.translation)\n        return self._integer_code\n\n    @property\n    def cif_form(self) -&gt; str:\n        \"Represent this SymmetryOperation in string form e.g. '+x,+y,+z'\"\n        return str(self)\n\n    def inverted(self):\n        \"\"\" \"\n        A copy of this symmetry operation under inversion\n\n        Returns:\n            SymmetryOperation: an inverted copy of this symmetry operation\n        \"\"\"\n        return SymmetryOperation(-self.rotation, -self.translation)\n\n    def __add__(self, value: np.ndarray):\n        \"\"\"\n        Add a vector to this symmetry operation's translation vector.\n\n        Returns:\n            SymmetryOperation: a copy of this symmetry operation under\n                additional translation\"\n        \"\"\"\n        return SymmetryOperation(self.rotation, self.translation + value)\n\n    def __sub__(self, value: np.ndarray):\n        \"\"\"\n        Subtract a vector from this symmetry operation's translation.\n\n        Returns:\n            SymmetryOperation: a copy of this symmetry operation under\n                additional translation\"\n        \"\"\"\n        return SymmetryOperation(self.rotation, self.translation - value)\n\n    def apply(self, coordinates: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Apply this symmetry operation to a set of fractional coordinates.\n\n        Args:\n            coordinates (np.ndarray): (N,3) or (N,4) array of fractional\n                coordinates or homogeneous fractional coordinates.\n\n        Returns:\n            np.ndarray: (N, 3) array of transformed coordinates\n        \"\"\"\n        if coordinates.shape[1] == 4:\n            return np.dot(coordinates, self.seitz_matrix.T)\n        else:\n            return np.dot(coordinates, self.rotation.T) + self.translation\n\n    def __str__(self):\n        if not hasattr(self, \"_string_code\"):\n            self._string_code = encode_symm_str(self.rotation, self.translation)\n        return self._string_code\n\n    def __lt__(self, other):\n        return self.integer_code &lt; other.integer_code\n\n    def __eq__(self, other):\n        return self.integer_code == other.integer_code\n\n    def __hash__(self):\n        return int(self.integer_code)\n\n    def __repr__(self):\n        return f\"&lt;{self.__class__.__name__}: {self}&gt;\"\n\n    def __call__(self, coordinates):\n        return self.apply(coordinates)\n\n    @classmethod\n    def from_integer_code(cls, code: int):\n        \"\"\"\n        Alternative constructor from an integer-encoded\n        symmetry operation e.g. 16484\n\n        See also  the `encode_symm_int`, `decode_symm_int` methods.\n\n        Args:\n            code (int): integer-encoded symmetry operation\n\n        Returns:\n            SymmetryOperation: a new symmetry operation from the provided integer code\n        \"\"\"\n\n        rot, trans = decode_symm_int(code)\n        s = SymmetryOperation(rot, trans)\n        s._integer_code = code\n        return s\n\n    @classmethod\n    def from_string_code(cls, code: str):\n        \"\"\"\n        Alternative constructor from a string encoded\n        symmetry operation e.g. '+x,+y,+z'.\n\n        See also the `encode_symm_str`, `decode_symm_str` methods.\n\n        Args:\n            code (str): string-encoded symmetry operation\n\n        Returns:\n            SymmetryOperation: a new symmetry operation from the provided string code\n        \"\"\"\n        rot, trans = decode_symm_str(code)\n        s = SymmetryOperation(rot, trans)\n        s._string_code = code\n        return s\n\n    def is_identity(self) -&gt; bool:\n        \"Returns true if this is the identity symmetry operation '+x,+y,+z'\"\n        return self.integer_code == 16484\n\n    @classmethod\n    def identity(cls):\n        \"Alternative constructor for the the identity symop i.e. x,y,z\"\n        return cls.from_integer_code(16484)\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.cif_form","title":"<code>cif_form</code>  <code>property</code>","text":"<p>Represent this SymmetryOperation in string form e.g. '+x,+y,+z'</p>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.integer_code","title":"<code>integer_code</code>  <code>property</code>","text":"<p>Represent this SymmetryOperation as a packed integer</p>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.seitz_matrix","title":"<code>seitz_matrix</code>  <code>property</code>","text":"<p>The Seitz matrix form of this SymmetryOperation</p>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.__add__","title":"<code>__add__(value)</code>","text":"<p>Add a vector to this symmetry operation's translation vector.</p> <p>Returns:</p> Name Type Description <code>SymmetryOperation</code> <p>a copy of this symmetry operation under additional translation\"</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>def __add__(self, value: np.ndarray):\n    \"\"\"\n    Add a vector to this symmetry operation's translation vector.\n\n    Returns:\n        SymmetryOperation: a copy of this symmetry operation under\n            additional translation\"\n    \"\"\"\n    return SymmetryOperation(self.rotation, self.translation + value)\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.__init__","title":"<code>__init__(rotation, translation)</code>","text":"<p>Construct a new symmetry operation from a rotation matrix and a translation vector</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>ndarray</code> <p>(3, 3) rotation matrix</p> required <code>translation</code> <code>ndarray</code> <p>(3) translation vector</p> required <p>Returns:</p> Name Type Description <code>SymmetryOperation</code> <p>a new SymmetryOperation</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>def __init__(self, rotation, translation):\n    \"\"\"\n    Construct a new symmetry operation from a rotation matrix and\n    a translation vector\n\n    Arguments:\n        rotation (np.ndarray): (3, 3) rotation matrix\n        translation (np.ndarray): (3) translation vector\n\n    Returns:\n        SymmetryOperation: a new SymmetryOperation\n    \"\"\"\n    self.rotation = rotation\n    self.translation = translation % 1\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.__sub__","title":"<code>__sub__(value)</code>","text":"<p>Subtract a vector from this symmetry operation's translation.</p> <p>Returns:</p> Name Type Description <code>SymmetryOperation</code> <p>a copy of this symmetry operation under additional translation\"</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>def __sub__(self, value: np.ndarray):\n    \"\"\"\n    Subtract a vector from this symmetry operation's translation.\n\n    Returns:\n        SymmetryOperation: a copy of this symmetry operation under\n            additional translation\"\n    \"\"\"\n    return SymmetryOperation(self.rotation, self.translation - value)\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.apply","title":"<code>apply(coordinates)</code>","text":"<p>Apply this symmetry operation to a set of fractional coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>ndarray</code> <p>(N,3) or (N,4) array of fractional coordinates or homogeneous fractional coordinates.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: (N, 3) array of transformed coordinates</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>def apply(self, coordinates: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Apply this symmetry operation to a set of fractional coordinates.\n\n    Args:\n        coordinates (np.ndarray): (N,3) or (N,4) array of fractional\n            coordinates or homogeneous fractional coordinates.\n\n    Returns:\n        np.ndarray: (N, 3) array of transformed coordinates\n    \"\"\"\n    if coordinates.shape[1] == 4:\n        return np.dot(coordinates, self.seitz_matrix.T)\n    else:\n        return np.dot(coordinates, self.rotation.T) + self.translation\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.from_integer_code","title":"<code>from_integer_code(code)</code>  <code>classmethod</code>","text":"<p>Alternative constructor from an integer-encoded symmetry operation e.g. 16484</p> <p>See also  the <code>encode_symm_int</code>, <code>decode_symm_int</code> methods.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>int</code> <p>integer-encoded symmetry operation</p> required <p>Returns:</p> Name Type Description <code>SymmetryOperation</code> <p>a new symmetry operation from the provided integer code</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>@classmethod\ndef from_integer_code(cls, code: int):\n    \"\"\"\n    Alternative constructor from an integer-encoded\n    symmetry operation e.g. 16484\n\n    See also  the `encode_symm_int`, `decode_symm_int` methods.\n\n    Args:\n        code (int): integer-encoded symmetry operation\n\n    Returns:\n        SymmetryOperation: a new symmetry operation from the provided integer code\n    \"\"\"\n\n    rot, trans = decode_symm_int(code)\n    s = SymmetryOperation(rot, trans)\n    s._integer_code = code\n    return s\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.from_string_code","title":"<code>from_string_code(code)</code>  <code>classmethod</code>","text":"<p>Alternative constructor from a string encoded symmetry operation e.g. '+x,+y,+z'.</p> <p>See also the <code>encode_symm_str</code>, <code>decode_symm_str</code> methods.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>string-encoded symmetry operation</p> required <p>Returns:</p> Name Type Description <code>SymmetryOperation</code> <p>a new symmetry operation from the provided string code</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>@classmethod\ndef from_string_code(cls, code: str):\n    \"\"\"\n    Alternative constructor from a string encoded\n    symmetry operation e.g. '+x,+y,+z'.\n\n    See also the `encode_symm_str`, `decode_symm_str` methods.\n\n    Args:\n        code (str): string-encoded symmetry operation\n\n    Returns:\n        SymmetryOperation: a new symmetry operation from the provided string code\n    \"\"\"\n    rot, trans = decode_symm_str(code)\n    s = SymmetryOperation(rot, trans)\n    s._string_code = code\n    return s\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.identity","title":"<code>identity()</code>  <code>classmethod</code>","text":"<p>Alternative constructor for the the identity symop i.e. x,y,z</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>@classmethod\ndef identity(cls):\n    \"Alternative constructor for the the identity symop i.e. x,y,z\"\n    return cls.from_integer_code(16484)\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.inverted","title":"<code>inverted()</code>","text":"<p>\" A copy of this symmetry operation under inversion</p> <p>Returns:</p> Name Type Description <code>SymmetryOperation</code> <p>an inverted copy of this symmetry operation</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>def inverted(self):\n    \"\"\" \"\n    A copy of this symmetry operation under inversion\n\n    Returns:\n        SymmetryOperation: an inverted copy of this symmetry operation\n    \"\"\"\n    return SymmetryOperation(-self.rotation, -self.translation)\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.SymmetryOperation.is_identity","title":"<code>is_identity()</code>","text":"<p>Returns true if this is the identity symmetry operation '+x,+y,+z'</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>def is_identity(self) -&gt; bool:\n    \"Returns true if this is the identity symmetry operation '+x,+y,+z'\"\n    return self.integer_code == 16484\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.decode_symm_int","title":"<code>decode_symm_int(coded_integer)</code>","text":"<p>Decode an integer encoded symmetry operation.</p> <p>A space group operation is compressed using ternary numerical system for rotation and duodecimal system for translation. This is achieved because each element of rotation matrix can have only one of {-1,0,1}, and the translation can have one of {0,2,3,4,6,8,9,10} divided by 12.  Therefore 3^9 * 12^3 = 34012224 different values can map space group operations. In principle, octal numerical system can be used for translation, but duodecimal system is more convenient.</p> <p>encode_symm_str(*decode_symm_int(16484)) '+x,+y,+z'</p> <p>Parameters:</p> Name Type Description Default <code>coded_integer</code> <code>int</code> <p>integer encoding a symmetry operation</p> required <p>Returns:</p> Type Description <p>Tuple[np.ndarray, np.ndarray]: (3,3) rotation matrix, (3) translation vector</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>def decode_symm_int(coded_integer):\n    \"\"\"\n    Decode an integer encoded symmetry operation.\n\n    A space group operation is compressed using ternary numerical system for\n    rotation and duodecimal system for translation. This is achieved because\n    each element of rotation matrix can have only one of {-1,0,1}, and the\n    translation can have one of {0,2,3,4,6,8,9,10} divided by 12.  Therefore\n    3^9 * 12^3 = 34012224 different values can map space group operations. In\n    principle, octal numerical system can be used for translation, but\n    duodecimal system is more convenient.\n\n    &gt;&gt;&gt; encode_symm_str(*decode_symm_int(16484))\n    '+x,+y,+z'\n\n    Args:\n        coded_integer (int): integer encoding a symmetry operation\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: (3,3) rotation matrix, (3) translation vector\n    \"\"\"\n    r = coded_integer % 19683  # 19683 = 3**9\n    shift = 6561  # 6561 = 3**8\n    rotation = np.empty((3, 3), dtype=np.float64)\n    translation = np.empty(3, dtype=np.float64)\n    for i in (0, 1, 2):\n        for j in (0, 1, 2):\n            # we need integer division here\n            rotation[i, j] = (r % (shift * 3)) // shift - 1\n            shift //= 3\n\n    t = coded_integer // 19683\n    shift = 144\n    for i in (0, 1, 2):\n        # we need integer division here by shift\n        translation[i] = ((t % (shift * 12)) // shift) / 12\n        shift //= 12\n    return rotation, translation\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.decode_symm_str","title":"<code>decode_symm_str(s)</code>","text":"<p>Decode a symmetry operation represented in the string form e.g. '1/2 + x, y, -z -0.25' into a rotation matrix and translation vector.</p> <p>encode_symm_str(decode_symm_str(\"x,y,z\")) '+x,+y,+z' encode_symm_str(decode_symm_str(\"1/2 - x,y-0.3333333,z\")) '1/2-x,2/3+y,+z'</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>the encoded symmetry operation string</p> required <p>Returns:</p> Type Description <p>Tuple[np.ndarray, np.ndarray]: a (3,3) rotation matrix and a (3) translation vector</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>def decode_symm_str(s):\n    \"\"\"\n    Decode a symmetry operation represented in the string\n    form e.g. '1/2 + x, y, -z -0.25' into a rotation matrix\n    and translation vector.\n\n    &gt;&gt;&gt; encode_symm_str(*decode_symm_str(\"x,y,z\"))\n    '+x,+y,+z'\n    &gt;&gt;&gt; encode_symm_str(*decode_symm_str(\"1/2 - x,y-0.3333333,z\"))\n    '1/2-x,2/3+y,+z'\n\n    Args:\n        s (str): the encoded symmetry operation string\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: a (3,3) rotation matrix and a (3)\n            translation vector\n    \"\"\"\n    rotation = np.zeros((3, 3), dtype=np.float64)\n    translation = np.zeros((3,), dtype=np.float64)\n    tokens = s.lower().replace(\" \", \"\").split(\",\")\n    for i, row in enumerate(tokens):\n        fac = 1\n        row = row.strip()\n        symbols = re.findall(SYMM_STR_SYMBOL_REGEX, row)\n        for symbol in symbols:\n            if \"x\" in symbol:\n                idx = 0\n                fac = -1 if \"-x\" in symbol else 1\n                rotation[i, idx] = fac\n            elif \"y\" in symbol:\n                idx = 1\n                fac = -1 if \"-y\" in symbol else 1\n                rotation[i, idx] = fac\n            elif \"z\" in symbol:\n                idx = 2\n                fac = -1 if \"-z\" in symbol else 1\n                rotation[i, idx] = fac\n            else:\n                if \"/\" in symbol:\n                    numerator, denominator = symbol.split(\"/\")\n                    translation[i] = Fraction(\n                        Fraction(numerator), Fraction(denominator)\n                    )\n                else:\n                    translation[i] += float(Fraction(symbol))\n    translation = translation % 1\n    return rotation, translation\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.encode_symm_int","title":"<code>encode_symm_int(rotation, translation)</code>","text":"<p>Encode an integer encoded symmetry from a rotation matrix and translation vector.</p> <p>A space group operation is compressed using ternary numerical system for rotation and duodecimal system for translation. This is achieved because each element of rotation matrix can have only one of {-1,0,1}, and the translation can have one of {0,2,3,4,6,8,9,10} divided by 12.  Therefore 3^9 * 12^3 = 34012224 different values can map space group operations. In principle, octal numerical system can be used for translation, but duodecimal system is more convenient.</p> <p>encode_symm_int(((1, 0, 0), (0, 1, 0), (0, 0, 1)), (0, 0, 0)) 16484 encode_symm_int(((1, 0, 0), (0, 1, 0), (0, 1, 1)), (0, 0.5, 0)) 1433663</p> <p>Args:     rotation (array_like): (3,3) matrix of -1, 0, or 1s encoding         the rotation component of the symmetry operation     translation (array_like): (3) vector of rational numbers encoding         the translation component of the symmetry operation</p> <p>Returns:</p> Name Type Description <code>int</code> <p>the encoded symmetry operation</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>def encode_symm_int(rotation, translation):\n    \"\"\"\n    Encode an integer encoded symmetry from a rotation matrix and translation\n    vector.\n\n    A space group operation is compressed using ternary numerical system for\n    rotation and duodecimal system for translation. This is achieved because\n    each element of rotation matrix can have only one of {-1,0,1}, and the\n    translation can have one of {0,2,3,4,6,8,9,10} divided by 12.  Therefore\n    3^9 * 12^3 = 34012224 different values can map space group operations. In\n    principle, octal numerical system can be used for translation, but\n    duodecimal system is more convenient.\n\n    &gt;&gt;&gt; encode_symm_int(((1, 0, 0), (0, 1, 0), (0, 0, 1)), (0, 0, 0))\n    16484\n    &gt;&gt;&gt; encode_symm_int(((1, 0, 0), (0, 1, 0), (0, 1, 1)), (0, 0.5, 0))\n    1433663\n\n     Args:\n        rotation (array_like): (3,3) matrix of -1, 0, or 1s encoding\n            the rotation component of the symmetry operation\n        translation (array_like): (3) vector of rational numbers encoding\n            the translation component of the symmetry operation\n\n    Returns:\n        int: the encoded symmetry operation\n    \"\"\"\n\n    r = 0\n    shift = 1\n    # encode rotation component\n    rotation = np.round(np.array(rotation)).astype(int) + 1\n    for i in (2, 1, 0):\n        for j in (2, 1, 0):\n            r += rotation[i, j] * shift\n            shift *= 3\n    t = 0\n    shift = 1\n    translation = np.round(np.array(translation) * 12).astype(int)\n    for i in (2, 1, 0):\n        t += translation[i] * shift\n        shift *= 12\n    return r + t * 19683\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.encode_symm_str","title":"<code>encode_symm_str(rotation, translation)</code>","text":"<p>Encode a rotation matrix (of -1, 0, 1s) and (rational) translation vector into string form e.g. 1/2-x,z-1/3,-y-1/6</p> <p>encode_symm_str(((-1, 0, 0), (0, 0, 1), (0, 1, 0)), (0, 0.5, 1 / 3)) '-x,1/2+z,1/3+y' encode_symm_str(((1, 1, 1), (1, 0, 1), (0, 1, 0)), (0, 0.5, 1 / 3)) '+x+y+z,1/2+x+z,1/3+y'</p> <p>Parameters:</p> Name Type Description Default <code>rotation</code> <code>array_like</code> <p>(3,3) matrix of -1, 0, or 1s encoding the rotation component of the symmetry operation</p> required <code>translation</code> <code>array_like</code> <p>(3) vector of rational numbers encoding the translation component of the symmetry operation</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>the encoded symmetry operation</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>def encode_symm_str(rotation, translation):\n    \"\"\"\n    Encode a rotation matrix (of -1, 0, 1s) and (rational) translation vector\n    into string form e.g. 1/2-x,z-1/3,-y-1/6\n\n    &gt;&gt;&gt; encode_symm_str(((-1, 0, 0), (0, 0, 1), (0, 1, 0)), (0, 0.5, 1 / 3))\n    '-x,1/2+z,1/3+y'\n    &gt;&gt;&gt; encode_symm_str(((1, 1, 1), (1, 0, 1), (0, 1, 0)), (0, 0.5, 1 / 3))\n    '+x+y+z,1/2+x+z,1/3+y'\n\n    Args:\n        rotation (array_like): (3,3) matrix of -1, 0, or 1s encoding\n            the rotation component of the symmetry operation\n        translation (array_like): (3) vector of rational numbers encoding\n            the translation component of the symmetry operation\n\n    Returns:\n        str: the encoded symmetry operation\n    \"\"\"\n    symbols = \"xyz\"\n    res = []\n    for i in (0, 1, 2):\n        t = Fraction(translation[i]).limit_denominator(12)\n        v = \"\"\n        if t != 0:\n            v += str(t)\n        for j in range(0, 3):\n            c = rotation[i][j]\n            if c != 0:\n                s = \"-\" if c &lt; 0 else \"+\"\n                v += s + symbols[j]\n        res.append(v)\n    res = \",\".join(res)\n    return res\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.expanded_symmetry_list","title":"<code>expanded_symmetry_list(reduced_symops, lattice_type)</code>","text":"<p>Create an expanded list of symmetry operations from the minimum specification given a certain lattice type.</p> <p>Parameters:</p> Name Type Description Default <code>reduced_symops</code> <code>List[SymmetryOperation]</code> <p>reduced list of symmetry operations</p> required <code>lattice_type</code> <code>int</code> <p>integer encoded lattice type with SHELX conventions, i.e. <pre><code>1: P,\n2: I,\n3: rhombohedral obverse on hexagonal axes,\n4: F,\n5: A,\n6: B,\n7: C\n</code></pre></p> required <p>Returns:     List[SymmetryOperation]: an expanded list of symmetry operations         given lattice type</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>def expanded_symmetry_list(reduced_symops, lattice_type):\n    \"\"\"\n    Create an expanded list of symmetry operations from the minimum\n    specification given a certain lattice type.\n\n    Args:\n        reduced_symops (List[SymmetryOperation]): reduced list of symmetry operations\n        lattice_type (int): integer encoded lattice type with SHELX conventions, i.e.\n            ```\n            1: P,\n            2: I,\n            3: rhombohedral obverse on hexagonal axes,\n            4: F,\n            5: A,\n            6: B,\n            7: C\n            ```\n    Returns:\n        List[SymmetryOperation]: an expanded list of symmetry operations\n            given lattice type\n    \"\"\"\n    lattice_type_value = abs(lattice_type)\n    translations = LATTICE_TYPE_TRANSLATIONS[lattice_type_value]\n\n    identity = SymmetryOperation.identity()\n    if identity not in reduced_symops:\n        LOG.debug(\"Appending identity symop %s to reduced_symops\")\n        reduced_symops.append(identity)\n    LOG.debug(\"Reduced symmetry list contains %d symops\", len(reduced_symops))\n\n    full_symops = []\n\n    for symop in reduced_symops:\n        full_symops.append(symop)\n        for t in translations:\n            full_symops.append(symop + t)\n\n    if lattice_type &gt; 0:\n        full_symops += [x.inverted() for x in full_symops]\n\n    LOG.debug(\"Expanded symmetry list contains %d symops\", len(full_symops))\n    return full_symops\n</code></pre>"},{"location":"reference/chmpy/crystal/symmetry_operation/#chmpy.crystal.symmetry_operation.reduced_symmetry_list","title":"<code>reduced_symmetry_list(full_symops, lattice_type)</code>","text":"<p>Reduce an expanded list of symmetry operations to the minimum specification given a certain lattice type.</p> <p>Parameters:</p> Name Type Description Default <code>full_symops</code> <code>List[SymmetryOperation]</code> <p>list of symmetry operations</p> required <code>lattice_type</code> <code>int</code> <p>integer encoded lattice type with SHELX conventions, i.e. <pre><code>1: P,\n2: I,\n3: rhombohedral obverse on hexagonal axes,\n4: F,\n5: A,\n6: B,\n7: C\n</code></pre></p> required <p>Returns:     List[SymmetryOperation]: minimal list of symmetry operations given lattice type</p> Source code in <code>chmpy/crystal/symmetry_operation.py</code> <pre><code>def reduced_symmetry_list(full_symops, lattice_type):\n    \"\"\"\n    Reduce an expanded list of symmetry operations to the minimum\n    specification given a certain lattice type.\n\n    Args:\n        full_symops (List[SymmetryOperation]): list of symmetry operations\n        lattice_type (int): integer encoded lattice type with SHELX conventions, i.e.\n            ```\n            1: P,\n            2: I,\n            3: rhombohedral obverse on hexagonal axes,\n            4: F,\n            5: A,\n            6: B,\n            7: C\n            ```\n    Returns:\n        List[SymmetryOperation]: minimal list of symmetry operations given lattice type\n    \"\"\"\n    lattice_type_value = abs(lattice_type)\n    translations = LATTICE_TYPE_TRANSLATIONS[lattice_type_value]\n\n    reduced_symops = [SymmetryOperation.identity()]\n    symops_to_process = list(full_symops)\n\n    inversion = lattice_type &gt; 0\n\n    while symops_to_process:\n        next_symop = symops_to_process.pop(0)\n        if next_symop in reduced_symops:\n            continue\n        if inversion and next_symop.inverted() in reduced_symops:\n            continue\n        for t in translations:\n            x = next_symop + t\n            if inversion and x.inverted() in reduced_symops:\n                break\n            if x in reduced_symops:\n                break\n        else:\n            reduced_symops.append(next_symop)\n\n    LOG.debug(\"Reduced symmetry list contains %d symops\", len(reduced_symops))\n    return reduced_symops\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/","title":"unit_cell","text":""},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell","title":"<code>UnitCell</code>","text":"<p>Storage class for the lattice vectors of a crystal i.e. its unit cell.</p> <p>Attributes:</p> Name Type Description <code>direct</code> <code>ndarray</code> <p>the direct matrix of this unit cell i.e. the lattice vectors</p> <code>reciprocal_lattice</code> <code>ndarray</code> <p>the reciprocal matrix of this unit cell i.e. the reciprocal lattice vectors</p> <code>inverse</code> <code>ndarray</code> <p>the inverse matrix of this unit cell i.e. the transpose of <code>reciprocal_lattice</code></p> <code>lattice</code> <code>ndarray</code> <p>an alias for <code>direct</code></p> Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>class UnitCell:\n    \"\"\"\n    Storage class for the lattice vectors of a crystal i.e. its unit cell.\n\n    Attributes:\n        direct (np.ndarray): the direct matrix of this unit cell\n            i.e. the lattice vectors\n        reciprocal_lattice (np.ndarray): the reciprocal matrix of\n            this unit cell i.e. the reciprocal lattice vectors\n        inverse (np.ndarray): the inverse matrix of this unit\n            cell i.e. the transpose of `reciprocal_lattice`\n        lattice (np.ndarray): an alias for `direct`\n    \"\"\"\n\n    def __init__(self, vectors):\n        \"\"\"\n        Create a UnitCell object from a list of lattice vectors or\n        a row major direct matrix. Unless otherwise specified, length\n        units are Angstroms, and angular units are radians.\n\n        Args:\n            vectors (array_like): (3, 3) array of lattice vectors, row major\n                i.e. vectors[0, :] is lattice vector A etc.\n        \"\"\"\n        self.set_vectors(vectors)\n\n    @property\n    def lattice(self) -&gt; np.ndarray:\n        \"The direct matrix of this unit cell i.e. vectors of the lattice\"\n        return self.direct\n\n    @property\n    def reciprocal_lattice(self) -&gt; np.ndarray:\n        \"The reciprocal matrix of this unit cell i.e. vectors of the reciprocal lattice\"\n        return self.inverse.T\n\n    @property\n    def direct_homogeneous(self) -&gt; np.ndarray:\n        \"The direct matrix in homogeneous coordinates\"\n        T = np.eye(4)\n        T[:3, :3] = self.direct\n        return T\n\n    def to_cartesian(self, coords: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform coordinates from fractional space (a, b, c)\n        to Cartesian space (x, y, z). The x-direction will be aligned\n        along lattice vector A.\n\n        Args:\n            coords (array_like): (N, 3) array of fractional coordinates\n\n        Returns:\n            np.ndarray: (N, 3) array of Cartesian coordinates\n        \"\"\"\n        return np.dot(coords, self.direct)\n\n    def to_fractional(self, coords: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform coordinates from Cartesian space (x, y, z)\n        to fractional space (a, b, c). The x-direction will is assumed\n        be aligned along lattice vector A.\n\n        Args:\n            coords (array_like): an (N, 3) array of Cartesian coordinates\n\n        Returns:\n            np.ndarray: (N, 3) array of fractional coordinates\n        \"\"\"\n        return np.dot(coords, self.inverse)\n\n    def to_reciprocal(self, coords: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Transform coordinates from fractional space (x, y, z)\n        to reciprocal space (a*, b*, c*). The x-direction will is assumed\n        be aligned along lattice vector a*.\n\n        Args:\n            coords (array_like): an (N, 3) array of fractional coordinates\n\n        Returns:\n            np.ndarray: (N, 3) array of reciprocalcoordinates\n        \"\"\"\n        return np.dot(coords, self.inverse.T)\n\n    def set_lengths_and_angles(self, lengths, angles):\n        \"\"\"\n        Modify this unit cell by setting the lattice vectors\n        according to lengths a, b, c and angles alpha, beta, gamma of\n        a parallelipiped.\n\n        Args:\n            lengths (array_like): array of (a, b, c), the unit cell side\n                lengths in Angstroms.\n            angles (array_like): array of (alpha, beta, gamma), the unit\n                cell angles lengths in radians.\n        \"\"\"\n        self.lengths = lengths\n        self.angles = angles\n        a, b, c = self.lengths\n        ca, cb, cg = np.cos(self.angles)\n        sg = np.sin(self.angles[2])\n        v = self.volume()\n        self.direct = np.array(\n            (\n                (a, 0, 0),\n                (b * cg, b * sg, 0),\n                (c * cb, c * (ca - cb * cg) / sg, v / (a * b * sg)),\n            )\n        )\n        self.inverse = np.array(\n            (\n                (1.0 / a, 0.0, 0.0),\n                (-cg / (a * sg), 1 / (b * sg), 0),\n                (\n                    b * c * (ca * cg - cb) / v / sg,\n                    a * c * (cb * cg - ca) / v / sg,\n                    a * b * sg / v,\n                ),\n            )\n        )\n        self._set_cell_type()\n\n    def set_vectors(self, vectors):\n        \"\"\"\n        Modify this unit cell by setting the lattice vectors\n        according to those provided. This is performed by setting the\n        lattice parameters (lengths and angles) based on the provided vectors,\n        such that it results in a consistent basis without directly\n        matrix inverse (and typically losing precision), and\n        as the SHELX file/CIF output will be relying on these\n        lengths/angles anyway, it is important to have these consistent.\n\n\n        Args:\n            vectors (array_like): (3, 3) array of lattice vectors,\n                row major i.e. vectors[0, :] is lattice vector A etc.\n        \"\"\"\n        self.direct = vectors\n        params = zeros(6)\n        a, b, c = np.linalg.norm(self.direct, axis=1)\n        u_a = vectors[0, :] / a\n        u_b = vectors[1, :] / b\n        u_c = vectors[2, :] / c\n        alpha = np.arccos(np.clip(np.vdot(u_b, u_c), -1, 1))\n        beta = np.arccos(np.clip(np.vdot(u_c, u_a), -1, 1))\n        gamma = np.arccos(np.clip(np.vdot(u_a, u_b), -1, 1))\n        params[3:] = np.degrees([alpha, beta, gamma])\n        self.lengths = [a, b, c]\n        self.angles = [alpha, beta, gamma]\n        self.inverse = np.linalg.inv(self.direct)\n        self._set_cell_type()\n\n    def _set_cell_type(self):\n        if self.is_cubic:\n            self.cell_type_index = 6\n            self.cell_type = \"cubic\"\n            self.unique_parameters = (self.a,)\n            self.unique_parameters_deg = self.unique_parameters\n        elif self.is_rhombohedral:\n            self.cell_type_index = 4\n            self.cell_type = \"rhombohedral\"\n            self.unique_parameters = self.a, self.alpha\n            self.unique_parameters_deg = (self.a, np.degrees(self.alpha))\n        elif self.is_hexagonal:\n            self.cell_type_index = 5\n            self.cell_type = \"hexagonal\"\n            self.unique_parameters = self.a, self.c\n            self.unique_parameters_deg = self.unique_parameters\n        elif self.is_tetragonal:\n            self.cell_type_index = 3\n            self.cell_type = \"tetragonal\"\n            self.unique_parameters = self.a, self.c\n            self.unique_parameters_deg = self.unique_parameters\n        elif self.is_orthorhombic:\n            self.cell_type_index = 2\n            self.cell_type = \"orthorhombic\"\n            self.unique_parameters = self.a, self.b, self.c\n            self.unique_parameters_deg = self.unique_parameters\n        elif self.is_monoclinic:\n            self.cell_type_index = 1\n            self.cell_type = \"monoclinic\"\n            self.unique_parameters = self.a, self.b, self.c, self.beta\n            self.unique_parameters_deg = (self.a, self.b, np.degrees(self.beta))\n        else:\n            self.cell_type_index = 0\n            self.cell_type = \"triclinic\"\n            self.unique_parameters = (\n                self.a,\n                self.b,\n                self.c,\n                self.alpha,\n                self.beta,\n                self.gamma,\n            )\n            self.unique_parameters_deg = (\n                self.a,\n                self.b,\n                self.c,\n                np.degrees(self.alpha),\n                np.degrees(self.beta),\n                np.degrees(self.gamma),\n            )\n\n    def volume(self) -&gt; float:\n        \"\"\"The volume of the unit cell, in cubic Angstroms\"\"\"\n        a, b, c = self.lengths\n        ca, cb, cg = np.cos(self.angles)\n        return a * b * c * np.sqrt(1 - ca * ca - cb * cb - cg * cg + 2 * ca * cb * cg)\n\n    @property\n    def abc_equal(self) -&gt; bool:\n        \"are the lengths a, b, c all equal?\"\n        return close(np.array(self.lengths) - self.lengths[0], zeros(3))\n\n    @property\n    def abc_different(self) -&gt; bool:\n        \"are all of the lengths a, b, c different?\"\n        return not (\n            close(self.a, self.b) or close(self.a, self.c) or close(self.b, self.c)\n        )\n\n    @property\n    def orthogonal(self) -&gt; bool:\n        \"returns true if the lattice vectors are orthogonal\"\n        return close(np.abs(self.angles) - np.pi / 2, zeros(3))\n\n    @property\n    def angles_different(self) -&gt; bool:\n        \"are all of the angles alpha, beta, gamma different?\"\n        return not (\n            close(self.alpha, self.beta)\n            or close(self.alpha, self.gamma)\n            or close(self.beta, self.gamma)\n        )\n\n    @property\n    def is_triclinic(self) -&gt; bool:\n        \"\"\"Returns true if and lengths are different\"\"\"\n        return self.abc_different and self.angles_different\n\n    @property\n    def is_monoclinic(self) -&gt; bool:\n        \"\"\"Returns true if angles alpha and gamma are equal\"\"\"\n        return close(self.alpha, self.gamma) and self.abc_different\n\n    @property\n    def is_cubic(self) -&gt; bool:\n        \"\"\"Returns true if all lengths are equal and all angles are 90 degrees\"\"\"\n        return self.abc_equal and self.orthogonal\n\n    @property\n    def is_orthorhombic(self) -&gt; bool:\n        \"\"\"Returns true if all angles are 90 degrees\"\"\"\n        return self.orthogonal and self.abc_different\n\n    @property\n    def is_tetragonal(self) -&gt; bool:\n        \"\"\"Returns true if a, b are equal and all angles are 90 degrees\"\"\"\n        return close(self.a, self.b) and (not close(self.a, self.c)) and self.orthogonal\n\n    @property\n    def is_rhombohedral(self) -&gt; bool:\n        \"\"\"Returns true if all lengths are equal and all angles are equal\"\"\"\n        return (\n            self.abc_equal\n            and close(np.array(self.angles) - self.angles[0], zeros(3))\n            and (not close(self.alpha, np.pi / 2))\n        )\n\n    @property\n    def is_hexagonal(self) -&gt; bool:\n        \"Returns true if lengths a == b, a != c,\"\n        \"alpha and beta == 90 and gamma == 120\"\n        return (\n            close(self.a, self.b)\n            and (not close(self.a, self.c))\n            and close(self.angles[:2], np.pi / 2)\n            and close(self.gamma, 2 * np.pi / 3)\n        )\n\n    @property\n    def a(self) -&gt; float:\n        \"Length of lattice vector a\"\n        return self.lengths[0]\n\n    @property\n    def v_a(self) -&gt; np.ndarray:\n        \"lattice vector a\"\n        return self.direct[0]\n\n    @property\n    def v_a_star(self) -&gt; np.ndarray:\n        \"reciprocal lattice vector a*\"\n        return self.inverse[:, 0]\n\n    @property\n    def a_star(self) -&gt; float:\n        \"length of reciprocal lattice vector a*\"\n        return self.b * self.c * np.sin(self.alpha) / self.volume()\n\n    @property\n    def alpha(self) -&gt; float:\n        \"Angle between lattice vectors b and c\"\n        return self.angles[0]\n\n    @property\n    def alpha_star(self) -&gt; float:\n        \"Angle between reciprocal lattice vectors b* and c*\"\n        return np.arccos(\n            (np.cos(self.beta) * np.cos(self.gamma) - np.cos(self.alpha))\n            / (np.sin(self.beta) * np.sin(self.gamma))\n        )\n\n    @property\n    def b(self) -&gt; float:\n        \"Length of lattice vector b\"\n        return self.lengths[1]\n\n    @property\n    def v_b(self) -&gt; np.ndarray:\n        \"lattice vector a\"\n        return self.direct[1]\n\n    @property\n    def v_b_star(self) -&gt; np.ndarray:\n        \"reciprocal lattice vector b*\"\n        return self.inverse[:, 1]\n\n    @property\n    def b_star(self) -&gt; float:\n        \"length of reciprocal lattice vector b*\"\n        return self.a * self.c * np.sin(self.beta) / self.volume()\n\n    @property\n    def beta(self) -&gt; float:\n        \"Angle between lattice vectors a and c\"\n        return self.angles[1]\n\n    @property\n    def beta_star(self) -&gt; float:\n        \"Angle between reciprocal lattice vectors a* and c*\"\n        return np.arccos(\n            (np.cos(self.alpha) * np.cos(self.gamma) - np.cos(self.beta))\n            / (np.sin(self.alpha) * np.sin(self.gamma))\n        )\n\n    @property\n    def c(self) -&gt; float:\n        \"Length of lattice vector c\"\n        return self.lengths[2]\n\n    @property\n    def v_c(self) -&gt; np.ndarray:\n        \"lattice vector a\"\n        return self.direct[2]\n\n    @property\n    def v_c_star(self) -&gt; np.ndarray:\n        \"reciprocal lattice vector c*\"\n        return self.inverse[:, 2]\n\n    @property\n    def c_star(self) -&gt; float:\n        \"length of reciprocal lattice vector c*\"\n        return self.a * self.b * np.sin(self.gamma) / self.volume()\n\n    @property\n    def gamma(self) -&gt; float:\n        \"Angle between lattice vectors a and b\"\n        return self.angles[2]\n\n    @property\n    def gamma_star(self) -&gt; float:\n        \"Angle between reciprocal lattice vectors a* and c*\"\n        return np.arccos(\n            (np.cos(self.alpha) * np.cos(self.beta) - np.cos(self.gamma))\n            / (np.sin(self.alpha) * np.sin(self.beta))\n        )\n\n    @property\n    def alpha_deg(self) -&gt; float:\n        \"Angle between lattice vectors b and c in degrees\"\n        return np.degrees(self.angles[0])\n\n    @property\n    def beta_deg(self) -&gt; float:\n        \"Angle between lattice vectors a and c in degrees\"\n        return np.degrees(self.angles[1])\n\n    @property\n    def gamma_deg(self) -&gt; float:\n        \"Angle between lattice vectors a and b in degrees\"\n        return np.degrees(self.angles[2])\n\n    @property\n    def parameters(self) -&gt; np.ndarray:\n        \"single vector of lattice side lengths and angles in degrees\"\n        atol = 1e-6\n        l = np.array(self.lengths)\n        deg = np.degrees(self.angles)\n        len_diffs = np.abs(l[:, np.newaxis] - l[np.newaxis, :]) &lt; atol\n        ang_diffs = np.abs(deg[:, np.newaxis] - deg[np.newaxis, :]) &lt; atol\n        for i in range(3):\n            l[len_diffs[i]] = l[i]\n            deg[ang_diffs[i]] = deg[i]\n        return np.hstack((l, deg))\n\n    @classmethod\n    def from_lengths_and_angles(cls, lengths, angles, unit=\"radians\"):\n        \"\"\"\n        Construct a new UnitCell from the provided lengths and angles.\n\n        Args:\n            lengths (array_like): Lattice side lengths (a, b, c) in Angstroms.\n            angles (array_like): Lattice angles (alpha, beta, gamma)\n                in provided units (default radians)\n            unit (str, optional): Unit for angles i.e. 'radians' or\n                'degrees' (default radians).\n\n        Returns:\n            UnitCell: A new unit cell object representing the provided lattice.\n        \"\"\"\n        uc = cls(np.eye(3))\n        if unit == \"radians\":\n            if np.any(np.abs(angles) &gt; np.pi):\n                LOG.warn(\n                    \"Large angle in UnitCell.from_lengths_and_angles, \"\n                    \"are you sure your angles are not in degrees?\"\n                )\n            uc.set_lengths_and_angles(lengths, angles)\n        else:\n            uc.set_lengths_and_angles(lengths, np.radians(angles))\n        return uc\n\n    @classmethod\n    def cubic(cls, length):\n        \"\"\"\n        Construct a new cubic UnitCell from the provided side length.\n\n        Args:\n            length (float): Lattice side length a in Angstroms.\n\n        Returns:\n            UnitCell: A new unit cell object representing the provided lattice.\n        \"\"\"\n        return cls(np.eye(3) * length)\n\n    @classmethod\n    def from_unique_parameters(cls, params, cell_type=\"triclinic\", **kwargs):\n        \"\"\"\n        Construct a new unit cell from the unique parameters and\n        the specified cell type.\n\n        Args:\n            params (Tuple): tuple of floats of unique parameters\n            cell_type (str, optional): the desired cell type\n        \"\"\"\n        return getattr(cls, cell_type)(*params)\n\n    @classmethod\n    def triclinic(cls, *params, **kwargs):\n        \"\"\"\n        Construct a new UnitCell from the provided side lengths and angles.\n\n        Args:\n            params (array_like): Lattice side lengths and angles\n                (a, b, c, alpha, beta, gamma)\n\n        Returns:\n            UnitCell: A new unit cell object representing the provided lattice.\n        \"\"\"\n\n        assert len(params) == 6, \"Requre three lengths and angles for Triclinic cell\"\n        return cls.from_lengths_and_angles(params[:3], params[3:], **kwargs)\n\n    @classmethod\n    def monoclinic(cls, *params, **kwargs):\n        \"\"\"\n        Construct a new UnitCell from the provided side lengths and angle.\n\n        Args:\n            params (array_like): Lattice side lengths and angles (a, b, c, beta)\n\n        Returns:\n            UnitCell: A new unit cell object representing the provided lattice.\n        \"\"\"\n\n        assert len(params) == 4, (\n            \"Requre three lengths and one angle for Monoclinic cell\"\n        )\n        unit = kwargs.get(\"unit\", \"radians\")\n        if unit != \"radians\":\n            alpha, gamma = 90, 90\n        else:\n            alpha, gamma = np.pi / 2, np.pi / 2\n        return cls.from_lengths_and_angles(\n            params[:3], (alpha, params[3], gamma), **kwargs\n        )\n\n    @classmethod\n    def tetragonal(cls, *params, **kwargs):\n        \"\"\"\n        Construct a new UnitCell from the provided side lengths and angles.\n\n        Args:\n            params (array_like): Lattice side lengths (a, c)\n\n        Returns:\n            UnitCell: A new unit cell object representing the provided lattice.\n        \"\"\"\n        assert len(params) == 2, \"Requre 2 lengths for Tetragonal cell\"\n        unit = kwargs.get(\"unit\", \"radians\")\n        if unit != \"radians\":\n            angles = [90] * 3\n        else:\n            angles = [np.pi / 2] * 3\n        return cls.from_lengths_and_angles(\n            (params[0], params[0], params[1]), angles, **kwargs\n        )\n\n    @classmethod\n    def hexagonal(cls, *params, **kwargs):\n        \"\"\"\n        Construct a new UnitCell from the provided side lengths and angles.\n\n        Args:\n            params (array_like): Lattice side lengths (a, c)\n\n        Returns:\n            UnitCell: A new unit cell object representing the provided lattice.\n        \"\"\"\n        assert len(params) == 2, \"Requre 2 lengths for Hexagonal cell\"\n        unit = kwargs.pop(\"unit\", \"radians\")\n        unit = \"radians\"\n        angles = [np.pi / 2, np.pi / 2, 2 * np.pi / 3]\n        return cls.from_lengths_and_angles(\n            (params[0], params[0], params[1]), angles, unit=unit, **kwargs\n        )\n\n    @classmethod\n    def rhombohedral(cls, *params, **kwargs):\n        \"\"\"\n        Construct a new UnitCell from the provided side lengths and angles.\n\n        Args:\n            params (array_like): Lattice side length a and angle alpha c\n\n        Returns:\n            UnitCell: A new unit cell object representing the provided lattice.\n        \"\"\"\n        assert len(params) == 2, \"Requre 1 length and 1 angle for Rhombohedral cell\"\n        return cls.from_lengths_and_angles([params[0]] * 3, [params[1]] * 3, **kwargs)\n\n    @classmethod\n    def orthorhombic(cls, *lengths, **kwargs):\n        \"\"\"\n        Construct a new orthorhombic UnitCell from the provided side lengths.\n\n        Args:\n            lengths (array_like): Lattice side lengths (a, b, c) in Angstroms.\n\n        Returns:\n            UnitCell: A new unit cell object representing the provided lattice.\n        \"\"\"\n\n        assert len(lengths) == 3, \"Requre three lengths for Orthorhombic cell\"\n        return cls(np.diag(lengths))\n\n    def as_rhombohedral(\n        self, T=((-1 / 3, 1 / 3, 1 / 3), (2 / 3, 1 / 3, 1 / 3), (-1 / 3, -2 / 3, 1 / 3))\n    ):\n        if not (self.is_hexagonal):\n            raise ValueError(\"Only hexagonal cells can be converted to rhombohedral\")\n        T = np.array(T)\n        return UnitCell(np.dot(T, self.direct))\n\n    def as_hexagonal(self, T=((-1, 1, 0), (1, 0, -1), (1, 1, 1))):\n        if not self.is_rhombohedral:\n            raise ValueError(\"Only rhombohedral cells can be converted to hexagonal\")\n        # Crystal17 convention =  ((1, -1,  0), (0, 1, -1), (1, 1, 1))\n        T = np.array(T)\n        return UnitCell(np.dot(T, self.direct))\n\n    def to_mesh(self):\n        from trimesh import Trimesh\n\n        verts = np.array(\n            [\n                np.zeros(3),\n                self.v_c,\n                self.v_b,\n                self.v_b + self.v_c,\n                self.v_a,\n                self.v_a + self.v_c,\n                self.v_a + self.v_b,\n                self.v_a + self.v_b + self.v_c,\n            ]\n        )\n\n        faces = np.array(\n            [\n                [1, 3, 0],\n                [4, 1, 0],\n                [0, 3, 2],\n                [2, 4, 0],\n                [1, 7, 3],\n                [5, 1, 4],\n                [5, 7, 1],\n                [3, 7, 2],\n                [6, 4, 2],\n                [2, 7, 6],\n                [6, 5, 4],\n                [7, 5, 6],\n            ]\n        )\n        return Trimesh(vertices=verts, faces=faces)\n\n    def __repr__(self):\n        cell = self.cell_type\n        unique = self.unique_parameters\n        s = \"&lt;{{}}: {{}} ({})&gt;\".format(\",\".join(\"{:.3f}\" for p in unique))\n        return s.format(self.__class__.__name__, cell, *unique)\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.a","title":"<code>a</code>  <code>property</code>","text":"<p>Length of lattice vector a</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.a_star","title":"<code>a_star</code>  <code>property</code>","text":"<p>length of reciprocal lattice vector a*</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.abc_different","title":"<code>abc_different</code>  <code>property</code>","text":"<p>are all of the lengths a, b, c different?</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.abc_equal","title":"<code>abc_equal</code>  <code>property</code>","text":"<p>are the lengths a, b, c all equal?</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.alpha","title":"<code>alpha</code>  <code>property</code>","text":"<p>Angle between lattice vectors b and c</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.alpha_deg","title":"<code>alpha_deg</code>  <code>property</code>","text":"<p>Angle between lattice vectors b and c in degrees</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.alpha_star","title":"<code>alpha_star</code>  <code>property</code>","text":"<p>Angle between reciprocal lattice vectors b and c</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.angles_different","title":"<code>angles_different</code>  <code>property</code>","text":"<p>are all of the angles alpha, beta, gamma different?</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.b","title":"<code>b</code>  <code>property</code>","text":"<p>Length of lattice vector b</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.b_star","title":"<code>b_star</code>  <code>property</code>","text":"<p>length of reciprocal lattice vector b*</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.beta","title":"<code>beta</code>  <code>property</code>","text":"<p>Angle between lattice vectors a and c</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.beta_deg","title":"<code>beta_deg</code>  <code>property</code>","text":"<p>Angle between lattice vectors a and c in degrees</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.beta_star","title":"<code>beta_star</code>  <code>property</code>","text":"<p>Angle between reciprocal lattice vectors a and c</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.c","title":"<code>c</code>  <code>property</code>","text":"<p>Length of lattice vector c</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.c_star","title":"<code>c_star</code>  <code>property</code>","text":"<p>length of reciprocal lattice vector c*</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.direct_homogeneous","title":"<code>direct_homogeneous</code>  <code>property</code>","text":"<p>The direct matrix in homogeneous coordinates</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.gamma","title":"<code>gamma</code>  <code>property</code>","text":"<p>Angle between lattice vectors a and b</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.gamma_deg","title":"<code>gamma_deg</code>  <code>property</code>","text":"<p>Angle between lattice vectors a and b in degrees</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.gamma_star","title":"<code>gamma_star</code>  <code>property</code>","text":"<p>Angle between reciprocal lattice vectors a and c</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.is_cubic","title":"<code>is_cubic</code>  <code>property</code>","text":"<p>Returns true if all lengths are equal and all angles are 90 degrees</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.is_hexagonal","title":"<code>is_hexagonal</code>  <code>property</code>","text":"<p>Returns true if lengths a == b, a != c,</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.is_monoclinic","title":"<code>is_monoclinic</code>  <code>property</code>","text":"<p>Returns true if angles alpha and gamma are equal</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.is_orthorhombic","title":"<code>is_orthorhombic</code>  <code>property</code>","text":"<p>Returns true if all angles are 90 degrees</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.is_rhombohedral","title":"<code>is_rhombohedral</code>  <code>property</code>","text":"<p>Returns true if all lengths are equal and all angles are equal</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.is_tetragonal","title":"<code>is_tetragonal</code>  <code>property</code>","text":"<p>Returns true if a, b are equal and all angles are 90 degrees</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.is_triclinic","title":"<code>is_triclinic</code>  <code>property</code>","text":"<p>Returns true if and lengths are different</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.lattice","title":"<code>lattice</code>  <code>property</code>","text":"<p>The direct matrix of this unit cell i.e. vectors of the lattice</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.orthogonal","title":"<code>orthogonal</code>  <code>property</code>","text":"<p>returns true if the lattice vectors are orthogonal</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.parameters","title":"<code>parameters</code>  <code>property</code>","text":"<p>single vector of lattice side lengths and angles in degrees</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.reciprocal_lattice","title":"<code>reciprocal_lattice</code>  <code>property</code>","text":"<p>The reciprocal matrix of this unit cell i.e. vectors of the reciprocal lattice</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.v_a","title":"<code>v_a</code>  <code>property</code>","text":"<p>lattice vector a</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.v_a_star","title":"<code>v_a_star</code>  <code>property</code>","text":"<p>reciprocal lattice vector a*</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.v_b","title":"<code>v_b</code>  <code>property</code>","text":"<p>lattice vector a</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.v_b_star","title":"<code>v_b_star</code>  <code>property</code>","text":"<p>reciprocal lattice vector b*</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.v_c","title":"<code>v_c</code>  <code>property</code>","text":"<p>lattice vector a</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.v_c_star","title":"<code>v_c_star</code>  <code>property</code>","text":"<p>reciprocal lattice vector c*</p>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.__init__","title":"<code>__init__(vectors)</code>","text":"<p>Create a UnitCell object from a list of lattice vectors or a row major direct matrix. Unless otherwise specified, length units are Angstroms, and angular units are radians.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>array_like</code> <p>(3, 3) array of lattice vectors, row major i.e. vectors[0, :] is lattice vector A etc.</p> required Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>def __init__(self, vectors):\n    \"\"\"\n    Create a UnitCell object from a list of lattice vectors or\n    a row major direct matrix. Unless otherwise specified, length\n    units are Angstroms, and angular units are radians.\n\n    Args:\n        vectors (array_like): (3, 3) array of lattice vectors, row major\n            i.e. vectors[0, :] is lattice vector A etc.\n    \"\"\"\n    self.set_vectors(vectors)\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.cubic","title":"<code>cubic(length)</code>  <code>classmethod</code>","text":"<p>Construct a new cubic UnitCell from the provided side length.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>float</code> <p>Lattice side length a in Angstroms.</p> required <p>Returns:</p> Name Type Description <code>UnitCell</code> <p>A new unit cell object representing the provided lattice.</p> Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>@classmethod\ndef cubic(cls, length):\n    \"\"\"\n    Construct a new cubic UnitCell from the provided side length.\n\n    Args:\n        length (float): Lattice side length a in Angstroms.\n\n    Returns:\n        UnitCell: A new unit cell object representing the provided lattice.\n    \"\"\"\n    return cls(np.eye(3) * length)\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.from_lengths_and_angles","title":"<code>from_lengths_and_angles(lengths, angles, unit='radians')</code>  <code>classmethod</code>","text":"<p>Construct a new UnitCell from the provided lengths and angles.</p> <p>Parameters:</p> Name Type Description Default <code>lengths</code> <code>array_like</code> <p>Lattice side lengths (a, b, c) in Angstroms.</p> required <code>angles</code> <code>array_like</code> <p>Lattice angles (alpha, beta, gamma) in provided units (default radians)</p> required <code>unit</code> <code>str</code> <p>Unit for angles i.e. 'radians' or 'degrees' (default radians).</p> <code>'radians'</code> <p>Returns:</p> Name Type Description <code>UnitCell</code> <p>A new unit cell object representing the provided lattice.</p> Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>@classmethod\ndef from_lengths_and_angles(cls, lengths, angles, unit=\"radians\"):\n    \"\"\"\n    Construct a new UnitCell from the provided lengths and angles.\n\n    Args:\n        lengths (array_like): Lattice side lengths (a, b, c) in Angstroms.\n        angles (array_like): Lattice angles (alpha, beta, gamma)\n            in provided units (default radians)\n        unit (str, optional): Unit for angles i.e. 'radians' or\n            'degrees' (default radians).\n\n    Returns:\n        UnitCell: A new unit cell object representing the provided lattice.\n    \"\"\"\n    uc = cls(np.eye(3))\n    if unit == \"radians\":\n        if np.any(np.abs(angles) &gt; np.pi):\n            LOG.warn(\n                \"Large angle in UnitCell.from_lengths_and_angles, \"\n                \"are you sure your angles are not in degrees?\"\n            )\n        uc.set_lengths_and_angles(lengths, angles)\n    else:\n        uc.set_lengths_and_angles(lengths, np.radians(angles))\n    return uc\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.from_unique_parameters","title":"<code>from_unique_parameters(params, cell_type='triclinic', **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a new unit cell from the unique parameters and the specified cell type.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>Tuple</code> <p>tuple of floats of unique parameters</p> required <code>cell_type</code> <code>str</code> <p>the desired cell type</p> <code>'triclinic'</code> Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>@classmethod\ndef from_unique_parameters(cls, params, cell_type=\"triclinic\", **kwargs):\n    \"\"\"\n    Construct a new unit cell from the unique parameters and\n    the specified cell type.\n\n    Args:\n        params (Tuple): tuple of floats of unique parameters\n        cell_type (str, optional): the desired cell type\n    \"\"\"\n    return getattr(cls, cell_type)(*params)\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.hexagonal","title":"<code>hexagonal(*params, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a new UnitCell from the provided side lengths and angles.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>array_like</code> <p>Lattice side lengths (a, c)</p> <code>()</code> <p>Returns:</p> Name Type Description <code>UnitCell</code> <p>A new unit cell object representing the provided lattice.</p> Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>@classmethod\ndef hexagonal(cls, *params, **kwargs):\n    \"\"\"\n    Construct a new UnitCell from the provided side lengths and angles.\n\n    Args:\n        params (array_like): Lattice side lengths (a, c)\n\n    Returns:\n        UnitCell: A new unit cell object representing the provided lattice.\n    \"\"\"\n    assert len(params) == 2, \"Requre 2 lengths for Hexagonal cell\"\n    unit = kwargs.pop(\"unit\", \"radians\")\n    unit = \"radians\"\n    angles = [np.pi / 2, np.pi / 2, 2 * np.pi / 3]\n    return cls.from_lengths_and_angles(\n        (params[0], params[0], params[1]), angles, unit=unit, **kwargs\n    )\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.monoclinic","title":"<code>monoclinic(*params, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a new UnitCell from the provided side lengths and angle.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>array_like</code> <p>Lattice side lengths and angles (a, b, c, beta)</p> <code>()</code> <p>Returns:</p> Name Type Description <code>UnitCell</code> <p>A new unit cell object representing the provided lattice.</p> Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>@classmethod\ndef monoclinic(cls, *params, **kwargs):\n    \"\"\"\n    Construct a new UnitCell from the provided side lengths and angle.\n\n    Args:\n        params (array_like): Lattice side lengths and angles (a, b, c, beta)\n\n    Returns:\n        UnitCell: A new unit cell object representing the provided lattice.\n    \"\"\"\n\n    assert len(params) == 4, (\n        \"Requre three lengths and one angle for Monoclinic cell\"\n    )\n    unit = kwargs.get(\"unit\", \"radians\")\n    if unit != \"radians\":\n        alpha, gamma = 90, 90\n    else:\n        alpha, gamma = np.pi / 2, np.pi / 2\n    return cls.from_lengths_and_angles(\n        params[:3], (alpha, params[3], gamma), **kwargs\n    )\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.orthorhombic","title":"<code>orthorhombic(*lengths, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a new orthorhombic UnitCell from the provided side lengths.</p> <p>Parameters:</p> Name Type Description Default <code>lengths</code> <code>array_like</code> <p>Lattice side lengths (a, b, c) in Angstroms.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>UnitCell</code> <p>A new unit cell object representing the provided lattice.</p> Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>@classmethod\ndef orthorhombic(cls, *lengths, **kwargs):\n    \"\"\"\n    Construct a new orthorhombic UnitCell from the provided side lengths.\n\n    Args:\n        lengths (array_like): Lattice side lengths (a, b, c) in Angstroms.\n\n    Returns:\n        UnitCell: A new unit cell object representing the provided lattice.\n    \"\"\"\n\n    assert len(lengths) == 3, \"Requre three lengths for Orthorhombic cell\"\n    return cls(np.diag(lengths))\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.rhombohedral","title":"<code>rhombohedral(*params, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a new UnitCell from the provided side lengths and angles.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>array_like</code> <p>Lattice side length a and angle alpha c</p> <code>()</code> <p>Returns:</p> Name Type Description <code>UnitCell</code> <p>A new unit cell object representing the provided lattice.</p> Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>@classmethod\ndef rhombohedral(cls, *params, **kwargs):\n    \"\"\"\n    Construct a new UnitCell from the provided side lengths and angles.\n\n    Args:\n        params (array_like): Lattice side length a and angle alpha c\n\n    Returns:\n        UnitCell: A new unit cell object representing the provided lattice.\n    \"\"\"\n    assert len(params) == 2, \"Requre 1 length and 1 angle for Rhombohedral cell\"\n    return cls.from_lengths_and_angles([params[0]] * 3, [params[1]] * 3, **kwargs)\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.set_lengths_and_angles","title":"<code>set_lengths_and_angles(lengths, angles)</code>","text":"<p>Modify this unit cell by setting the lattice vectors according to lengths a, b, c and angles alpha, beta, gamma of a parallelipiped.</p> <p>Parameters:</p> Name Type Description Default <code>lengths</code> <code>array_like</code> <p>array of (a, b, c), the unit cell side lengths in Angstroms.</p> required <code>angles</code> <code>array_like</code> <p>array of (alpha, beta, gamma), the unit cell angles lengths in radians.</p> required Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>def set_lengths_and_angles(self, lengths, angles):\n    \"\"\"\n    Modify this unit cell by setting the lattice vectors\n    according to lengths a, b, c and angles alpha, beta, gamma of\n    a parallelipiped.\n\n    Args:\n        lengths (array_like): array of (a, b, c), the unit cell side\n            lengths in Angstroms.\n        angles (array_like): array of (alpha, beta, gamma), the unit\n            cell angles lengths in radians.\n    \"\"\"\n    self.lengths = lengths\n    self.angles = angles\n    a, b, c = self.lengths\n    ca, cb, cg = np.cos(self.angles)\n    sg = np.sin(self.angles[2])\n    v = self.volume()\n    self.direct = np.array(\n        (\n            (a, 0, 0),\n            (b * cg, b * sg, 0),\n            (c * cb, c * (ca - cb * cg) / sg, v / (a * b * sg)),\n        )\n    )\n    self.inverse = np.array(\n        (\n            (1.0 / a, 0.0, 0.0),\n            (-cg / (a * sg), 1 / (b * sg), 0),\n            (\n                b * c * (ca * cg - cb) / v / sg,\n                a * c * (cb * cg - ca) / v / sg,\n                a * b * sg / v,\n            ),\n        )\n    )\n    self._set_cell_type()\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.set_vectors","title":"<code>set_vectors(vectors)</code>","text":"<p>Modify this unit cell by setting the lattice vectors according to those provided. This is performed by setting the lattice parameters (lengths and angles) based on the provided vectors, such that it results in a consistent basis without directly matrix inverse (and typically losing precision), and as the SHELX file/CIF output will be relying on these lengths/angles anyway, it is important to have these consistent.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>array_like</code> <p>(3, 3) array of lattice vectors, row major i.e. vectors[0, :] is lattice vector A etc.</p> required Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>def set_vectors(self, vectors):\n    \"\"\"\n    Modify this unit cell by setting the lattice vectors\n    according to those provided. This is performed by setting the\n    lattice parameters (lengths and angles) based on the provided vectors,\n    such that it results in a consistent basis without directly\n    matrix inverse (and typically losing precision), and\n    as the SHELX file/CIF output will be relying on these\n    lengths/angles anyway, it is important to have these consistent.\n\n\n    Args:\n        vectors (array_like): (3, 3) array of lattice vectors,\n            row major i.e. vectors[0, :] is lattice vector A etc.\n    \"\"\"\n    self.direct = vectors\n    params = zeros(6)\n    a, b, c = np.linalg.norm(self.direct, axis=1)\n    u_a = vectors[0, :] / a\n    u_b = vectors[1, :] / b\n    u_c = vectors[2, :] / c\n    alpha = np.arccos(np.clip(np.vdot(u_b, u_c), -1, 1))\n    beta = np.arccos(np.clip(np.vdot(u_c, u_a), -1, 1))\n    gamma = np.arccos(np.clip(np.vdot(u_a, u_b), -1, 1))\n    params[3:] = np.degrees([alpha, beta, gamma])\n    self.lengths = [a, b, c]\n    self.angles = [alpha, beta, gamma]\n    self.inverse = np.linalg.inv(self.direct)\n    self._set_cell_type()\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.tetragonal","title":"<code>tetragonal(*params, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a new UnitCell from the provided side lengths and angles.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>array_like</code> <p>Lattice side lengths (a, c)</p> <code>()</code> <p>Returns:</p> Name Type Description <code>UnitCell</code> <p>A new unit cell object representing the provided lattice.</p> Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>@classmethod\ndef tetragonal(cls, *params, **kwargs):\n    \"\"\"\n    Construct a new UnitCell from the provided side lengths and angles.\n\n    Args:\n        params (array_like): Lattice side lengths (a, c)\n\n    Returns:\n        UnitCell: A new unit cell object representing the provided lattice.\n    \"\"\"\n    assert len(params) == 2, \"Requre 2 lengths for Tetragonal cell\"\n    unit = kwargs.get(\"unit\", \"radians\")\n    if unit != \"radians\":\n        angles = [90] * 3\n    else:\n        angles = [np.pi / 2] * 3\n    return cls.from_lengths_and_angles(\n        (params[0], params[0], params[1]), angles, **kwargs\n    )\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.to_cartesian","title":"<code>to_cartesian(coords)</code>","text":"<p>Transform coordinates from fractional space (a, b, c) to Cartesian space (x, y, z). The x-direction will be aligned along lattice vector A.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>array_like</code> <p>(N, 3) array of fractional coordinates</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: (N, 3) array of Cartesian coordinates</p> Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>def to_cartesian(self, coords: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform coordinates from fractional space (a, b, c)\n    to Cartesian space (x, y, z). The x-direction will be aligned\n    along lattice vector A.\n\n    Args:\n        coords (array_like): (N, 3) array of fractional coordinates\n\n    Returns:\n        np.ndarray: (N, 3) array of Cartesian coordinates\n    \"\"\"\n    return np.dot(coords, self.direct)\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.to_fractional","title":"<code>to_fractional(coords)</code>","text":"<p>Transform coordinates from Cartesian space (x, y, z) to fractional space (a, b, c). The x-direction will is assumed be aligned along lattice vector A.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>array_like</code> <p>an (N, 3) array of Cartesian coordinates</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: (N, 3) array of fractional coordinates</p> Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>def to_fractional(self, coords: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform coordinates from Cartesian space (x, y, z)\n    to fractional space (a, b, c). The x-direction will is assumed\n    be aligned along lattice vector A.\n\n    Args:\n        coords (array_like): an (N, 3) array of Cartesian coordinates\n\n    Returns:\n        np.ndarray: (N, 3) array of fractional coordinates\n    \"\"\"\n    return np.dot(coords, self.inverse)\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.to_reciprocal","title":"<code>to_reciprocal(coords)</code>","text":"<p>Transform coordinates from fractional space (x, y, z) to reciprocal space (a, b, c). The x-direction will is assumed be aligned along lattice vector a.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>array_like</code> <p>an (N, 3) array of fractional coordinates</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: (N, 3) array of reciprocalcoordinates</p> Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>def to_reciprocal(self, coords: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Transform coordinates from fractional space (x, y, z)\n    to reciprocal space (a*, b*, c*). The x-direction will is assumed\n    be aligned along lattice vector a*.\n\n    Args:\n        coords (array_like): an (N, 3) array of fractional coordinates\n\n    Returns:\n        np.ndarray: (N, 3) array of reciprocalcoordinates\n    \"\"\"\n    return np.dot(coords, self.inverse.T)\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.triclinic","title":"<code>triclinic(*params, **kwargs)</code>  <code>classmethod</code>","text":"<p>Construct a new UnitCell from the provided side lengths and angles.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>array_like</code> <p>Lattice side lengths and angles (a, b, c, alpha, beta, gamma)</p> <code>()</code> <p>Returns:</p> Name Type Description <code>UnitCell</code> <p>A new unit cell object representing the provided lattice.</p> Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>@classmethod\ndef triclinic(cls, *params, **kwargs):\n    \"\"\"\n    Construct a new UnitCell from the provided side lengths and angles.\n\n    Args:\n        params (array_like): Lattice side lengths and angles\n            (a, b, c, alpha, beta, gamma)\n\n    Returns:\n        UnitCell: A new unit cell object representing the provided lattice.\n    \"\"\"\n\n    assert len(params) == 6, \"Requre three lengths and angles for Triclinic cell\"\n    return cls.from_lengths_and_angles(params[:3], params[3:], **kwargs)\n</code></pre>"},{"location":"reference/chmpy/crystal/unit_cell/#chmpy.crystal.unit_cell.UnitCell.volume","title":"<code>volume()</code>","text":"<p>The volume of the unit cell, in cubic Angstroms</p> Source code in <code>chmpy/crystal/unit_cell.py</code> <pre><code>def volume(self) -&gt; float:\n    \"\"\"The volume of the unit cell, in cubic Angstroms\"\"\"\n    a, b, c = self.lengths\n    ca, cb, cg = np.cos(self.angles)\n    return a * b * c * np.sqrt(1 - ca * ca - cb * cb - cg * cg + 2 * ca * cb * cg)\n</code></pre>"},{"location":"reference/chmpy/crystal/wulff/","title":"wulff","text":""},{"location":"reference/chmpy/crystal/wulff/#chmpy.crystal.wulff.perpendicular_vector","title":"<code>perpendicular_vector(p, q, r)</code>","text":"<p>a unit vector perpendicular to the triangle p q r</p> Source code in <code>chmpy/crystal/wulff.py</code> <pre><code>def perpendicular_vector(p, q, r):\n    \"a unit vector perpendicular to the triangle p q r\"\n    perp_vector = np.cross(q - p, r - p)\n    dp = np.dot(perp_vector, p)\n    if dp &gt; 0:\n        return perp_vector / np.linalg.norm(perp_vector)\n    else:\n        return -perp_vector / np.linalg.norm(perp_vector)\n</code></pre>"},{"location":"reference/chmpy/crystal/wulff/#chmpy.crystal.wulff.winding_order_ccw","title":"<code>winding_order_ccw(points)</code>","text":"<p>return the indices to reorder the provided 2D points into CCW order</p> Source code in <code>chmpy/crystal/wulff.py</code> <pre><code>def winding_order_ccw(points):\n    \"return the indices to reorder the provided 2D points into CCW order\"\n    centroid = points[0]\n    directions = points[1:] - centroid\n    directions /= np.linalg.norm(directions, axis=1)[:, np.newaxis]\n    idxs = list(range(1, points.shape[0]))\n    return [0] + sorted(\n        idxs, key=lambda x: np.arctan2(directions[x - 1, 1], directions[x - 1, 0])\n    )\n</code></pre>"},{"location":"reference/chmpy/descriptors/symmetry_function_ani1/","title":"symmetry_function_ani1","text":""},{"location":"reference/chmpy/descriptors/symmetry_function_ani1/#chmpy.descriptors.symmetry_function_ani1.SymmetryFunctionsANI1","title":"<code>SymmetryFunctionsANI1</code>","text":"<p>Atomic environment symmetry functions, based on the ANI-1 descriptors [1]</p>"},{"location":"reference/chmpy/descriptors/symmetry_function_ani1/#chmpy.descriptors.symmetry_function_ani1.SymmetryFunctionsANI1--references","title":"References","text":"<p>[1] J.S. Smith et al. Chem. Sci., 2017, 8, 3192-3203     https://dx.doi.org/10.1039/C6SC05720A</p> Source code in <code>chmpy/descriptors/symmetry_function_ani1.py</code> <pre><code>class SymmetryFunctionsANI1:\n    \"\"\"Atomic environment symmetry functions, based on the ANI-1\n    descriptors [1]\n\n    References\n    ----------\n    [1] J.S. Smith et al. Chem. Sci., 2017, 8, 3192-3203\n        https://dx.doi.org/10.1039/C6SC05720A\n    \"\"\"\n\n    def __init__(self, labels, n_radial, n_angular, n_theta):\n        self.labels = labels\n        self.unique_atoms = np.unique(labels).tolist()\n        self.pairs = [\n            tuple(sorted(x))\n            for x in combinations_with_replacement(self.unique_atoms, 2)\n        ]\n        self.radial = np.zeros(\n            (self.n_atoms, self.n_atom_types * n_radial), dtype=np.float64\n        )\n        self.angular = np.zeros(\n            (self.n_atoms, self.n_pairs * n_angular * n_theta), dtype=np.float64\n        )\n        self.nangular = n_angular * n_theta\n        self.nradial = n_radial\n\n    @property\n    def n_atoms(self):\n        return len(self.labels)\n\n    @property\n    def n_atom_types(self):\n        return len(self.unique_atoms)\n\n    @property\n    def n_pairs(self):\n        return len(self.pairs)\n\n    def set_radial(self, i, arr):\n        self.radial[i, :] = arr[:]\n\n    def set_angular(self, i, arr):\n        self.angular[i, :] = arr[:]\n\n    def get_angular(self, i, pair):\n        idx = self.pairs.index(tuple(sorted(pair)))\n        l, u = idx * self.nangular, (idx + 1) * self.nangular\n        return self.angular[i, l:u]\n\n    def get_radial(self, i, atom):\n        idx = self.unique_atoms.index(atom)\n        l, u = idx * self.nradial, (idx + 1) * self.nradial\n        return self.radial[i, l:u]\n\n    def as_flat_matrix(self):\n        return np.hstack((self.radial, self.angular))\n\n    def __repr__(self):\n        return f\"&lt;SymmetryFunctionsANI1: natom={self.n_atoms}&gt;\"\n\n    @classmethod\n    def from_crystal(cls, crys, **kwargs):\n        if len(crys.asym_mols()) &gt; 1:\n            raise NotImplementedError(\"Only implemented for Z'=1 crystals\")\n        args = SYMF_DEFAULT_PARAMETERS.copy()\n        args.update(kwargs)\n\n        assert len(args[\"angular_rs\"]) == len(args[\"theta\"]), (\n            \"Angular R_s and Theta lists must be the same length.\"\n        )\n\n        # Generate a finite cluster of molecules to the largest cutoff given\n        # This is done by centroid-centroid distances and so should be sufficient\n        nearest_atoms = atoms_in_radius(\n            crys, max((args[\"radial_cutoff\"], args[\"angular_cutoff\"]))\n        )\n\n        # Get xyz data\n        mol = crys.asym_mols()[0]\n        cm_xyz = mol.positions.copy()\n        labels = [e.symbol for e in mol.elements]\n\n        if not args[\"separate_radial\"]:\n            raise NotImplementedError\n        if not args[\"separate_angular\"]:\n            raise NotImplementedError\n\n        symf = cls(\n            labels, len(args[\"radial_rs\"]), len(args[\"angular_rs\"]), len(args[\"theta\"])\n        )\n\n        for idx, cm_atom_xyz in enumerate(cm_xyz):\n            symf.set_radial(\n                idx,\n                calc_radial_function(\n                    cm_xyz,\n                    nearest_atoms,\n                    cm_atom_xyz,\n                    args[\"radial_cutoff\"],\n                    args[\"radial_rs\"],\n                    args[\"radial_eta\"],\n                    args[\"only_intermolecular\"],\n                    args[\"separate_radial\"],\n                ),\n            )\n            symf.set_angular(\n                idx,\n                calc_angular_function(\n                    cm_xyz,\n                    nearest_atoms,\n                    cm_atom_xyz,\n                    args[\"angular_cutoff\"],\n                    args[\"angular_rs\"],\n                    args[\"theta\"],\n                    args[\"angular_eta\"],\n                    args[\"zeta\"],\n                    args[\"only_intermolecular\"],\n                    args[\"separate_angular\"],\n                ),\n            )\n        return symf\n</code></pre>"},{"location":"reference/chmpy/descriptors/symmetry_function_ani1/#chmpy.descriptors.symmetry_function_ani1.calc_angular_function","title":"<code>calc_angular_function(cm_xyz, nearest_atoms, cm_atom_xyz, cutoff, r_s_lst, theta_lst, eta, zeta, only_intermolecular=False, separate_angular=True)</code>","text":"<p>Angular function (eq (4) of Smith et al. (2017)) For a given atom returns a list of angular functions of length r_s (and theta - they must be the same length)</p> list of xyz of all atoms in a finite cluster larger than cutoff <p>not in the central molecule</p> <p>cm_atom_xyz : xyz of a given atom in the central molecule cutoff : float, max L1 distance where atom contributions are included r_s : list of hyperparameters controlling position of each gaussian theta: list of hyperparameters contrlling the angular position of each gaussian eta : float, hyperparameter controlling width of each gaussian zeta : float, hyperparameter controlling the width of each gaussian</p> Source code in <code>chmpy/descriptors/symmetry_function_ani1.py</code> <pre><code>def calc_angular_function(\n    cm_xyz,\n    nearest_atoms,\n    cm_atom_xyz,\n    cutoff,\n    r_s_lst,\n    theta_lst,\n    eta,\n    zeta,\n    only_intermolecular=False,\n    separate_angular=True,\n):\n    \"\"\"\n    Angular function (eq (4) of Smith et al. (2017))\n    For a given atom returns a list of angular functions of length r_s\n    (and theta - they must be the same length)\n\n    mol_xyz : list of xyz of all atoms in a finite cluster larger than cutoff\n        not in the central molecule\n    cm_atom_xyz : xyz of a given atom in the central molecule\n    cutoff : float, max L1 distance where atom contributions are included\n    r_s : list of hyperparameters controlling position of each gaussian\n    theta: list of hyperparameters contrlling the angular position of each gaussian\n    eta : float, hyperparameter controlling width of each gaussian\n    zeta : float, hyperparameter controlling the width of each gaussian\n    \"\"\"\n\n    front_factor = 2 ** (1 - zeta)\n\n    els, pos = nearest_atoms.neighbours(cm_atom_xyz, cutoff)\n    centered = pos - cm_atom_xyz\n    distances = np.linalg.norm(centered, axis=1)\n\n    if np.min(distances) &gt; 0.001:\n        raise Exception(\n            \"\"\"\n        Central Atom is probabaly not at (0, 0, 0). This means that atoms in\n        the original molecule cannot be found in the cluster (ball).\n        Check line 37 if \"direct\" should be replaced by \"direct.T\"\n        \"\"\"\n        )\n\n    center_atom = distances &lt; 1e-3\n\n    distances.shape[0]\n\n    fc = 0.5 * np.cos(distances * np.pi / cutoff) + 0.5\n    fc[center_atom] = 0\n    distances[center_atom] = 1\n\n    if only_intermolecular:\n        for cm_atom_xyz in cm_xyz:\n            fc[(np.linalg.norm(pos - cm_atom_xyz, axis=1) &lt; 1e-3)] = 0\n\n    normed = centered[:] / distances[:, np.newaxis]\n    angles = np.arccos(np.clip(np.matmul(normed, normed.T), -1, 1))\n    angle_diff = (1 + np.cos(angles[:, :, np.newaxis] - np.array(theta_lst))) ** zeta\n    r1r2 = 0.5 * (distances[:, np.newaxis] + distances)\n    r1r2 = np.exp(-eta * (r1r2[:, :, np.newaxis] - r_s_lst) ** 2)\n\n    fjfk = np.outer(fc, fc)\n\n    # Diagonal terms correspond to the angle of an atom with itself.\n    # Pushed them to zero by the following line\n\n    fjfk = np.triu(fjfk, k=1)\n\n    pairs_in_cluster = np.outer(els, els)\n    unique_atoms = np.unique(els)\n    atoms_pairs = np.triu(np.outer(unique_atoms, unique_atoms))\n\n    if separate_angular is True:\n        G2_list = []\n        for pair in atoms_pairs[atoms_pairs != 0]:\n            fjfk_temp = np.copy(fjfk)\n            fjfk_temp[pairs_in_cluster != pair] = 0\n            G2 = front_factor * np.einsum(\"ij,ijk,ijl-&gt;kl\", fjfk_temp, r1r2, angle_diff)\n            G2_list.append(G2)\n\n        return np.ravel(G2_list)\n\n    G2 = front_factor * np.einsum(\"ij,ijk,ijl-&gt;kl\", fjfk, r1r2, angle_diff)\n\n    return np.ravel(G2)\n</code></pre>"},{"location":"reference/chmpy/descriptors/symmetry_function_ani1/#chmpy.descriptors.symmetry_function_ani1.calc_radial_function","title":"<code>calc_radial_function(cm_xyz, nearest_atoms, cm_atom_xyz, cutoff, r_s_lst, eta, only_intermolecular=False, separate_radial=True)</code>","text":"<p>Radial function (eq (3) of Smith et al. (2017)) For a given atom returns a list of radial functions of length r_s</p> list of xyz of all atoms in a finite cluster larger than cutoff <p>not in the central molecule</p> <p>cm_atom_xyz : xyz of a given atom in the central molecule cutoff : float, max L1 distance where atom contributions are included r_s : list of hyperparameters controlling position of each gaussian eta : float, hyperparameter controlling width of each gaussian</p> Source code in <code>chmpy/descriptors/symmetry_function_ani1.py</code> <pre><code>def calc_radial_function(\n    cm_xyz,\n    nearest_atoms,\n    cm_atom_xyz,\n    cutoff,\n    r_s_lst,\n    eta,\n    only_intermolecular=False,\n    separate_radial=True,\n):\n    \"\"\"\n    Radial function (eq (3) of Smith et al. (2017))\n    For a given atom returns a list of radial functions of length r_s\n\n    mol_xyz : list of xyz of all atoms in a finite cluster larger than cutoff\n        not in the central molecule\n    cm_atom_xyz : xyz of a given atom in the central molecule\n    cutoff : float, max L1 distance where atom contributions are included\n    r_s : list of hyperparameters controlling position of each gaussian\n    eta : float, hyperparameter controlling width of each gaussian\n    \"\"\"\n    els, pos = nearest_atoms.neighbours(cm_atom_xyz, cutoff)\n    centered = pos - cm_atom_xyz\n\n    distances = np.linalg.norm(centered, axis=1)\n    center_atom = distances &lt; 1e-3\n    fc = 0.5 * np.cos(distances * np.pi / cutoff) + 0.5\n    fc[center_atom] = 0\n\n    if only_intermolecular:\n        for cm_atom_xyz in cm_xyz:\n            fc[(np.linalg.norm(pos - cm_atom_xyz, axis=1) &lt; 1e-3)] = 0\n\n    g = np.square(distances[:, np.newaxis] - r_s_lst)\n\n    unique_atoms = np.unique(els)\n\n    if separate_radial:\n        G1_list = []\n        for atom in unique_atoms:\n            fc_temp = np.copy(fc)\n            fc_temp[els != atom] = 0\n            G1_list.append(fc_temp.dot(np.exp(g * -eta)))\n        G1_list = np.array(G1_list)\n        return np.ravel(G1_list)\n\n    G1 = fc.dot(np.exp(g * -eta))\n\n    return np.ravel(G1)\n</code></pre>"},{"location":"reference/chmpy/exe/exe/","title":"exe","text":""},{"location":"reference/chmpy/exe/exe/#chmpy.exe.exe.AbstractExecutable","title":"<code>AbstractExecutable</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class of an Executable</p> Source code in <code>chmpy/exe/exe.py</code> <pre><code>class AbstractExecutable(ABC):\n    \"\"\"Abstract base class of an Executable\"\"\"\n\n    _name = \"job\"\n    _has_dependencies = False\n    _working_directory = None\n    _stdout = \"\"\n    _stderr = \"\"\n    _timeout = 86400.0  # timeout in seconds\n    _result = None\n    _output_file = None\n    _executable_location = None\n\n    @property\n    def executable(self):\n        return self._executable_location\n\n    @executable.setter\n    def executable(self, value):\n        os.access(value)\n        self._executable_location = os.path.abspath(value)\n\n    @property\n    def working_directory(self):\n        \"\"\"Return the current working directory for this job\"\"\"\n        return self._working_directory\n\n    @working_directory.setter\n    def working_directory(self, dirname):\n        \"\"\" \"Set the working directory for this job\"\"\"\n        assert dir_exists_or_is_creatable(dirname), (\n            f\"{dirname} either cannot be found or is not createable\"\n        )\n        self._working_directory = dirname\n\n    @abc.abstractmethod\n    def result(self):\n        \"\"\"Return the result of this calculation\"\"\"\n        raise NotImplementedError\n\n    @property\n    def stdout(self):\n        \"\"\"Return the output to stdout for this job\"\"\"\n        return self._stdout\n\n    @property\n    def has_dependencies(self):\n        \"\"\"Does this job require some work before it\n        can be run?\"\"\"\n        return self._has_dependencies\n\n    @abc.abstractmethod\n    def resolve_dependencies(self):\n        \"\"\"Do whatever needs to be done before running\n        the job (e.g. write input file etc.)\"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def post_process(self):\n        \"\"\"Do whatever needs to be done after the job.\"\"\"\n        raise NotImplementedError\n\n    @property\n    def name(self):\n        \"\"\"The name of the job as a string.\"\"\"\n        return self._name\n\n    @name.setter\n    def name(self, name):\n        \"\"\"Change the name of the job.\"\"\"\n        self._name = name\n\n    @property\n    def timeout(self):\n        return self._timeout\n\n    @timeout.setter\n    def timeout(self, value):\n        self._timeout = float(value)\n\n    @property\n    def output_file(self):\n        if not self._output_file:\n            self._output_file = tempfile.mkstemp(prefix=\"cspy-\", suffix=\".txt\")\n        return self._output_file\n\n    @output_file.setter\n    def output_file(self, value):\n        if value:\n            assert path_exists_or_is_creatable(value)\n            self._output_file = value\n\n    def _run_raw(self, *args, **kwargs):\n        \"\"\"Run the calculation, may throw exceptions\"\"\"\n        self.resolve_dependencies()\n        self.returncode = 130\n        with Path(self.output_file).open(\"w+\") as of:\n            cmd_list = [self.executable] + list(args)\n            command = run_subprocess(\n                cmd_list,\n                stdout=of,\n                timeout=self.timeout,\n                cwd=self.working_directory,\n                **kwargs,\n            )\n        self.returncode = command.returncode\n        self._check_returncode(cmd_list)\n        self.post_process()\n\n    def _run_raw_stdin(self, *args, **kwargs):\n        \"\"\"Run the calculation, may throw exceptions\"\"\"\n        self.resolve_dependencies()\n        self.returncode = 130\n        with Path(self.input_file).open() as inp:\n            with Path(self.output_file).open(\"w+\") as of:\n                cmd_list = [self.executable] + list(args)\n                command = run_subprocess(\n                    cmd_list,\n                    stdout=of,\n                    stdin=inp,\n                    timeout=self.timeout,\n                    cwd=self.working_directory,\n                    **kwargs,\n                )\n        self.returncode = command.returncode\n        self._check_returncode(cmd_list)\n        self.post_process()\n\n    def _check_returncode(self, cmd_list):\n        if self.returncode != 0:\n            raise ReturnCodeError(\n                \"Command '{}' exited with return code {}\".format(\n                    \" \".join(str(x) for x in cmd_list), self.returncode\n                )\n            )\n\n    @abc.abstractmethod\n    def run(self, *args, **kwargs):\n        raise NotImplementedError\n\n    def __str__(self):\n        return f\"{self.__class__.__name__}: {self.name}\"\n\n    def __repr__(self):\n        return str(self)\n</code></pre>"},{"location":"reference/chmpy/exe/exe/#chmpy.exe.exe.AbstractExecutable.has_dependencies","title":"<code>has_dependencies</code>  <code>property</code>","text":"<p>Does this job require some work before it can be run?</p>"},{"location":"reference/chmpy/exe/exe/#chmpy.exe.exe.AbstractExecutable.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":"<p>The name of the job as a string.</p>"},{"location":"reference/chmpy/exe/exe/#chmpy.exe.exe.AbstractExecutable.stdout","title":"<code>stdout</code>  <code>property</code>","text":"<p>Return the output to stdout for this job</p>"},{"location":"reference/chmpy/exe/exe/#chmpy.exe.exe.AbstractExecutable.working_directory","title":"<code>working_directory</code>  <code>property</code> <code>writable</code>","text":"<p>Return the current working directory for this job</p>"},{"location":"reference/chmpy/exe/exe/#chmpy.exe.exe.AbstractExecutable.post_process","title":"<code>post_process()</code>  <code>abstractmethod</code>","text":"<p>Do whatever needs to be done after the job.</p> Source code in <code>chmpy/exe/exe.py</code> <pre><code>@abc.abstractmethod\ndef post_process(self):\n    \"\"\"Do whatever needs to be done after the job.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/chmpy/exe/exe/#chmpy.exe.exe.AbstractExecutable.resolve_dependencies","title":"<code>resolve_dependencies()</code>  <code>abstractmethod</code>","text":"<p>Do whatever needs to be done before running the job (e.g. write input file etc.)</p> Source code in <code>chmpy/exe/exe.py</code> <pre><code>@abc.abstractmethod\ndef resolve_dependencies(self):\n    \"\"\"Do whatever needs to be done before running\n    the job (e.g. write input file etc.)\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/chmpy/exe/exe/#chmpy.exe.exe.AbstractExecutable.result","title":"<code>result()</code>  <code>abstractmethod</code>","text":"<p>Return the result of this calculation</p> Source code in <code>chmpy/exe/exe.py</code> <pre><code>@abc.abstractmethod\ndef result(self):\n    \"\"\"Return the result of this calculation\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/chmpy/exe/gaussian/","title":"gaussian","text":""},{"location":"reference/chmpy/exe/gaussian/#chmpy.exe.gaussian.Gaussian","title":"<code>Gaussian</code>","text":"<p>               Bases: <code>AbstractExecutable</code></p> Source code in <code>chmpy/exe/gaussian.py</code> <pre><code>class Gaussian(AbstractExecutable):\n    _executable_location = GAUSSIAN_EXEC\n    _JOB_FILE_FMT = \"{}.gjf\"\n    _LOG_FILE_FMT = \"{}.log\"\n\n    def __init__(\n        self,\n        input_file,\n        name=\"job\",\n        run_formchk=None,\n        working_directory=\".\",\n        output_file=None,\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        input_file : str\n            string of gaussian input format\n        output_file : str, optional\n            output_file to store gaussian output in,\n            by default will be returned as the result\n        \"\"\"\n        assert isinstance(input_file, str)\n\n        self.name = name\n        self.working_directory = working_directory\n        self._fchk_filename = None\n        self.input_file_contents = input_file\n        self.output_file = str(self.log_file)\n        if output_file:\n            self.output_file = str(output_file)\n        self.run_formchk = run_formchk\n        if self.run_formchk:\n            self._fchk_filename = self.run_formchk.replace(\".chk\", \".fchk\")\n            self._chk_filename = self.run_formchk\n        self.log_contents = None\n        self.fchk_contents = None\n\n    @property\n    def job_file(self):\n        return Path(self.working_directory, self._JOB_FILE_FMT.format(self.name))\n\n    @property\n    def log_file(self):\n        return Path(self.working_directory, self._LOG_FILE_FMT.format(self.name))\n\n    @property\n    def fchk_file(self):\n        if self._fchk_filename is not None:\n            return Path(self.working_directory, self._fchk_filename)\n\n    @property\n    def chk_file(self):\n        if self._chk_filename is not None:\n            return Path(self.working_directory, self._chk_filename)\n\n    def write_inputs(self):\n        self.job_file.write_text(self.input_file_contents)\n\n    def resolve_dependencies(self):\n        \"\"\"Do whatever needs to be done before running\n        the job (e.g. write input file etc.)\"\"\"\n        self.write_inputs()\n\n    def result(self):\n        return self.log_contents\n\n    def post_process(self):\n        self.log_contents = self.log_file.read_text()\n\n        output_file = Path(self.output_file)\n        if not output_file.exists():\n            output_file.write_text(self.log_contents)\n\n        if self.run_formchk:\n            self._run_formchk()\n            assert self.fchk_file.exists(), f\"{self.fchk_file} not found\"\n            self.fchk_contents = self.fchk_file.read_text()\n\n    def _run_formchk(self):\n        \"\"\"Run formchk, may throw exceptions\"\"\"\n        cmd_list = [FORMCHK_EXEC, str(self.chk_file), str(self.fchk_file)]\n        with open(\"/dev/null\", \"w+\") as of:\n            command = run_subprocess(cmd_list, stdout=of, timeout=self.timeout)\n            result = command.returncode\n        if result != 0:\n            raise ReturnCodeError(\n                \"Command '{}' exited with return code {}\".format(\n                    \" \".join(cmd_list), result\n                )\n            )\n        return result\n\n    def run(self, *args, **kwargs):\n        self._run_raw(self.job_file)\n</code></pre>"},{"location":"reference/chmpy/exe/gaussian/#chmpy.exe.gaussian.Gaussian.__init__","title":"<code>__init__(input_file, name='job', run_formchk=None, working_directory='.', output_file=None)</code>","text":""},{"location":"reference/chmpy/exe/gaussian/#chmpy.exe.gaussian.Gaussian.__init__--parameters","title":"Parameters","text":"<p>input_file : str     string of gaussian input format output_file : str, optional     output_file to store gaussian output in,     by default will be returned as the result</p> Source code in <code>chmpy/exe/gaussian.py</code> <pre><code>def __init__(\n    self,\n    input_file,\n    name=\"job\",\n    run_formchk=None,\n    working_directory=\".\",\n    output_file=None,\n):\n    \"\"\"\n    Parameters\n    ----------\n    input_file : str\n        string of gaussian input format\n    output_file : str, optional\n        output_file to store gaussian output in,\n        by default will be returned as the result\n    \"\"\"\n    assert isinstance(input_file, str)\n\n    self.name = name\n    self.working_directory = working_directory\n    self._fchk_filename = None\n    self.input_file_contents = input_file\n    self.output_file = str(self.log_file)\n    if output_file:\n        self.output_file = str(output_file)\n    self.run_formchk = run_formchk\n    if self.run_formchk:\n        self._fchk_filename = self.run_formchk.replace(\".chk\", \".fchk\")\n        self._chk_filename = self.run_formchk\n    self.log_contents = None\n    self.fchk_contents = None\n</code></pre>"},{"location":"reference/chmpy/exe/gaussian/#chmpy.exe.gaussian.Gaussian.resolve_dependencies","title":"<code>resolve_dependencies()</code>","text":"<p>Do whatever needs to be done before running the job (e.g. write input file etc.)</p> Source code in <code>chmpy/exe/gaussian.py</code> <pre><code>def resolve_dependencies(self):\n    \"\"\"Do whatever needs to be done before running\n    the job (e.g. write input file etc.)\"\"\"\n    self.write_inputs()\n</code></pre>"},{"location":"reference/chmpy/exe/gulp/","title":"gulp","text":""},{"location":"reference/chmpy/exe/gulp/#chmpy.exe.gulp.Gulp","title":"<code>Gulp</code>","text":"<p>               Bases: <code>AbstractExecutable</code></p> Source code in <code>chmpy/exe/gulp.py</code> <pre><code>class Gulp(AbstractExecutable):\n    _input_file = \"gulp_job.gin\"\n    _output_file = \"gulp_job.gout\"\n    _drv_file = \"gulp_job.drv\"\n    _res_file = \"gulp_job.res\"\n    _executable_location = GULP_EXEC\n    _timeout = 10086400.0\n\n    def __init__(self, input_contents, *args, working_directory=\".\", **kwargs):\n        self._timeout = kwargs.get(\"timeout\", self._timeout)\n        self.name = kwargs.get(\"name\", \"gulp_job\")\n        self.solvent = kwargs.get(\"solvent\", None)\n        self.threads = kwargs.get(\"threads\", 1)\n        self.input_contents = input_contents\n        self.output_contents = None\n        self.restart_contents = None\n        self.kwargs = kwargs.copy()\n        self.working_directory = working_directory\n        self.arg = Path(self.input_file).with_suffix(\"\")\n        LOG.debug(\"Initializing gulp calculation, timeout = %s\", self.timeout)\n        self.error_contents = None\n\n    @property\n    def input_file(self):\n        return Path(self.working_directory, self._input_file)\n\n    @property\n    def output_file(self):\n        return Path(self.working_directory, self._output_file)\n\n    @property\n    def drv_file(self):\n        return Path(self.working_directory, self._drv_file)\n\n    def resolve_dependencies(self):\n        \"\"\"Do whatever needs to be done before running\n        the job (e.g. write input file etc.)\"\"\"\n        LOG.debug(\"Writing GULP input file to %s\", self.input_file)\n        Path(self.input_file).write_text(\n            self.input_contents + f\"\\noutput drv {self.drv_file}\"\n        )\n\n    def result(self):\n        return self.output_contents\n\n    def post_process(self):\n        self.output_contents = Path(self.output_file).read_text()\n        if self.drv_file.exists():\n            self.drv_contents = self.drv_file.read_text()\n            # Parse the .drv file for structured data\n            from chmpy.fmt.gulp import parse_drv_file\n\n            try:\n                self.drv_data = parse_drv_file(self.drv_file)\n            except Exception as e:\n                LOG.warning(f\"Failed to parse .drv file: {e}\")\n                self.drv_data = None\n        else:\n            self.drv_contents = \"\"\n            self.drv_data = None\n\n    def run(self, *args, **kwargs):\n        LOG.debug(\"Running %s %s\", self._executable_location, self.arg)\n        try:\n            with TemporaryFile() as tmp:\n                env = copy.deepcopy(environ)\n                env.update(\n                    {\n                        \"OMP_NUM_THREADS\": str(self.threads) + \",1\",\n                        \"OMP_MAX_ACTIVE_LEVELS\": \"1\",\n                        \"MKL_NUM_THREADS\": str(self.threads),\n                    }\n                )\n                self._run_raw(self.arg, stderr=tmp, env=env)\n                tmp.seek(0)\n                self.error_contents = tmp.read().decode(\"utf-8\")\n        except ReturnCodeError as e:\n            from shutil import copytree\n\n            from chmpy.util.path import list_directory\n\n            LOG.error(\"GULP execution failed: %s\", e)\n            self.post_process()\n            LOG.error(\"output: %s\", self.output_contents)\n            LOG.error(\"Directory contents\\n%s\", list_directory(self.working_directory))\n            copytree(self.working_directory, \"failed_job\")\n            raise e\n\n    def cleanup(self):\n        \"\"\"Clean up temporary files created during GULP calculation.\"\"\"\n        files_to_clean = [\n            self.input_file,\n            self.output_file,\n            self.drv_file,\n            Path(self.working_directory) / self._res_file,\n        ]\n\n        for file_path in files_to_clean:\n            if file_path.exists():\n                try:\n                    file_path.unlink()\n                    LOG.debug(f\"Cleaned up: {file_path}\")\n                except Exception as e:\n                    LOG.warning(f\"Failed to clean up {file_path}: {e}\")\n\n    @property\n    def energy(self) -&gt; float | None:\n        \"\"\"Energy from parsed .drv data.\"\"\"\n        if self.drv_data:\n            return self.drv_data.get(\"energy\")\n        return None\n\n    @property\n    def gradients(self) -&gt; np.ndarray | None:\n        \"\"\"Gradients from parsed .drv data.\"\"\"\n        if self.drv_data:\n            return self.drv_data.get(\"gradients\")\n        return None\n\n    @property\n    def stress_raw(self) -&gt; np.ndarray | None:\n        \"\"\"Raw stress gradients from parsed .drv data.\"\"\"\n        if self.drv_data:\n            return self.drv_data.get(\"stress_raw\")\n        return None\n\n    def calculate_stress(self, volume: float) -&gt; np.ndarray | None:\n        \"\"\"Calculate stress tensor from strain gradients and volume.\"\"\"\n        if self.stress_raw is not None and volume &gt; 0:\n            # Convert strain gradients to stress: stress = (1/V) * dE/d_strain\n            return self.stress_raw / volume\n        return None\n</code></pre>"},{"location":"reference/chmpy/exe/gulp/#chmpy.exe.gulp.Gulp.energy","title":"<code>energy</code>  <code>property</code>","text":"<p>Energy from parsed .drv data.</p>"},{"location":"reference/chmpy/exe/gulp/#chmpy.exe.gulp.Gulp.gradients","title":"<code>gradients</code>  <code>property</code>","text":"<p>Gradients from parsed .drv data.</p>"},{"location":"reference/chmpy/exe/gulp/#chmpy.exe.gulp.Gulp.stress_raw","title":"<code>stress_raw</code>  <code>property</code>","text":"<p>Raw stress gradients from parsed .drv data.</p>"},{"location":"reference/chmpy/exe/gulp/#chmpy.exe.gulp.Gulp.calculate_stress","title":"<code>calculate_stress(volume)</code>","text":"<p>Calculate stress tensor from strain gradients and volume.</p> Source code in <code>chmpy/exe/gulp.py</code> <pre><code>def calculate_stress(self, volume: float) -&gt; np.ndarray | None:\n    \"\"\"Calculate stress tensor from strain gradients and volume.\"\"\"\n    if self.stress_raw is not None and volume &gt; 0:\n        # Convert strain gradients to stress: stress = (1/V) * dE/d_strain\n        return self.stress_raw / volume\n    return None\n</code></pre>"},{"location":"reference/chmpy/exe/gulp/#chmpy.exe.gulp.Gulp.cleanup","title":"<code>cleanup()</code>","text":"<p>Clean up temporary files created during GULP calculation.</p> Source code in <code>chmpy/exe/gulp.py</code> <pre><code>def cleanup(self):\n    \"\"\"Clean up temporary files created during GULP calculation.\"\"\"\n    files_to_clean = [\n        self.input_file,\n        self.output_file,\n        self.drv_file,\n        Path(self.working_directory) / self._res_file,\n    ]\n\n    for file_path in files_to_clean:\n        if file_path.exists():\n            try:\n                file_path.unlink()\n                LOG.debug(f\"Cleaned up: {file_path}\")\n            except Exception as e:\n                LOG.warning(f\"Failed to clean up {file_path}: {e}\")\n</code></pre>"},{"location":"reference/chmpy/exe/gulp/#chmpy.exe.gulp.Gulp.resolve_dependencies","title":"<code>resolve_dependencies()</code>","text":"<p>Do whatever needs to be done before running the job (e.g. write input file etc.)</p> Source code in <code>chmpy/exe/gulp.py</code> <pre><code>def resolve_dependencies(self):\n    \"\"\"Do whatever needs to be done before running\n    the job (e.g. write input file etc.)\"\"\"\n    LOG.debug(\"Writing GULP input file to %s\", self.input_file)\n    Path(self.input_file).write_text(\n        self.input_contents + f\"\\noutput drv {self.drv_file}\"\n    )\n</code></pre>"},{"location":"reference/chmpy/exe/raspa/","title":"raspa","text":""},{"location":"reference/chmpy/exe/raspa/#chmpy.exe.raspa.Raspa","title":"<code>Raspa</code>","text":"<p>               Bases: <code>AbstractExecutable</code></p> Source code in <code>chmpy/exe/raspa.py</code> <pre><code>class Raspa(AbstractExecutable):\n    _simulation_file = \"simulation.json\"\n    _force_field_file = \"force_field.json\"\n    _output_file = \"raspa_output.txt\"\n    _executable_location = RASPA_EXEC\n    _timeout = 10086400.0\n\n    def __init__(\n        self,\n        simulation_json,\n        force_field_json=None,\n        framework_file=None,\n        component_files=None,\n        *args,\n        working_directory=\".\",\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize a RASPA3 simulation.\n\n        Args:\n            simulation_json: Simulation configuration as dict or JSON string\n            force_field_json: Force field configuration as dict or JSON string\n            framework_file: Path to framework file (CIF)\n            component_files: Dict mapping component names to their definition files\n                             e.g. {\"CO2\": \"path/to/CO2.json\"}\n            working_directory: Directory to run the simulation in\n            kwargs: Additional arguments\n                - timeout: Maximum execution time in seconds\n                - name: Job name\n                - threads: Number of threads to use\n        \"\"\"\n        self._timeout = kwargs.get(\"timeout\", self._timeout)\n        self.name = kwargs.get(\"name\", \"raspa_job\")\n        self.threads = kwargs.get(\"threads\", 1)\n\n        # Store inputs\n        self.simulation_json = simulation_json\n        self.force_field_json = force_field_json\n        self.framework_file = framework_file\n        self.component_files = component_files or {}\n\n        # Store outputs\n        self.output_contents = None\n        self.error_contents = None\n\n        # Setup\n        self.kwargs = kwargs.copy()\n        self.working_directory = working_directory\n        LOG.debug(\"Initializing RASPA3 calculation, timeout = %s\", self.timeout)\n\n        # Framework and component information\n        self._framework_name = None\n        self._component_names = []\n\n        # Extract framework and component names from simulation JSON\n        if isinstance(simulation_json, dict):\n            sim_data = simulation_json\n        else:\n            try:\n                sim_data = json.loads(simulation_json)\n            except (json.JSONDecodeError, TypeError):\n                sim_data = {}\n\n        # Extract framework name and component names if present\n        if \"Systems\" in sim_data and len(sim_data[\"Systems\"]) &gt; 0:\n            if \"Name\" in sim_data[\"Systems\"][0]:\n                self._framework_name = sim_data[\"Systems\"][0][\"Name\"]\n\n        if \"Components\" in sim_data:\n            for component in sim_data[\"Components\"]:\n                if \"Name\" in component:\n                    self._component_names.append(component[\"Name\"])\n\n    @property\n    def simulation_file(self):\n        return Path(self.working_directory, self._simulation_file)\n\n    @property\n    def force_field_file(self):\n        return Path(self.working_directory, self._force_field_file)\n\n    @property\n    def output_file(self):\n        return Path(self.working_directory, self._output_file)\n\n    def _get_framework_path(self):\n        \"\"\"Get the path to save the framework file\"\"\"\n        if self._framework_name:\n            return Path(self.working_directory, f\"{self._framework_name}.cif\")\n        elif self.framework_file:\n            # Use the original filename if no name specified\n            return Path(self.working_directory, Path(self.framework_file).name)\n        return None\n\n    def _get_component_path(self, component_name):\n        \"\"\"Get the path to save a component file\"\"\"\n        return Path(self.working_directory, f\"{component_name}.json\")\n\n    def resolve_dependencies(self):\n        \"\"\"Write all necessary files before running the job\"\"\"\n        LOG.debug(\"Writing RASPA3 simulation files to %s\", self.working_directory)\n\n        # Write simulation.json\n        if isinstance(self.simulation_json, dict):\n            simulation_content = json.dumps(self.simulation_json, indent=2)\n        else:\n            simulation_content = self.simulation_json\n\n        Path(self.simulation_file).write_text(simulation_content)\n\n        # Write force_field.json if provided\n        if self.force_field_json:\n            if isinstance(self.force_field_json, dict):\n                force_field_content = json.dumps(self.force_field_json, indent=2)\n            else:\n                force_field_content = self.force_field_json\n\n            Path(self.force_field_file).write_text(force_field_content)\n\n        # Copy framework file if provided\n        if self.framework_file:\n            framework_dest = self._get_framework_path()\n            if framework_dest:\n                # Handle both file paths and content strings\n                if (\n                    isinstance(self.framework_file, str | Path)\n                    and Path(self.framework_file).exists()\n                ):\n                    shutil.copy2(self.framework_file, framework_dest)\n                else:\n                    # Assume it's the content as string\n                    Path(framework_dest).write_text(self.framework_file)\n\n        # Copy component files if provided\n        for component_name, component_file in self.component_files.items():\n            component_dest = self._get_component_path(component_name)\n\n            # Handle both file paths and content (dict or string)\n            if isinstance(component_file, dict):\n                component_content = json.dumps(component_file, indent=2)\n                Path(component_dest).write_text(component_content)\n            elif (\n                isinstance(component_file, str | Path) and Path(component_file).exists()\n            ):\n                shutil.copy2(component_file, component_dest)\n            else:\n                # Assume it's the content as string\n                Path(component_dest).write_text(component_file)\n\n    def result(self):\n        \"\"\"Return the output contents\"\"\"\n        return self.output_contents\n\n    def post_process(self):\n        \"\"\"Process output after the job completes\"\"\"\n        # Find and read output files\n        output_dir = Path(self.working_directory, \"output\")\n        if output_dir.exists() and output_dir.is_dir():\n            # Find the most recent .txt output file\n            output_files = list(output_dir.glob(\"*.txt\"))\n            if output_files:\n                latest_output = max(output_files, key=lambda p: p.stat().st_mtime)\n                self.output_contents = latest_output.read_text()\n                return\n\n        # If no output files found, check for standard output redirect\n        if Path(self.output_file).exists():\n            self.output_contents = Path(self.output_file).read_text()\n        else:\n            LOG.warning(\"No output files found after RASPA3 execution\")\n            self.output_contents = \"\"\n\n    def run(self, *args, **kwargs):\n        \"\"\"Run RASPA3 with the simulation file\"\"\"\n        LOG.debug(\"Running %s in %s\", self._executable_location, self.working_directory)\n        try:\n            with TemporaryFile() as tmp:\n                env = copy.deepcopy(environ)\n                env.update(\n                    {\n                        \"OMP_NUM_THREADS\": str(self.threads) + \",1\",\n                        \"OMP_MAX_ACTIVE_LEVELS\": \"1\",\n                        \"MKL_NUM_THREADS\": str(self.threads),\n                    }\n                )\n                # RASPA3 is run without arguments - it automatically looks for simulation.json\n                self._run_raw(stderr=tmp, env=env)\n                tmp.seek(0)\n                self.error_contents = tmp.read().decode(\"utf-8\")\n        except ReturnCodeError as e:\n            from shutil import copytree\n\n            from chmpy.util.path import list_directory\n\n            LOG.error(\"RASPA3 execution failed: %s\", e)\n            self.post_process()\n            LOG.error(\"output: %s\", self.output_contents)\n            LOG.error(\"Directory contents\\n%s\", list_directory(self.working_directory))\n            copytree(self.working_directory, \"failed_job\")\n            raise e\n</code></pre>"},{"location":"reference/chmpy/exe/raspa/#chmpy.exe.raspa.Raspa.__init__","title":"<code>__init__(simulation_json, force_field_json=None, framework_file=None, component_files=None, *args, working_directory='.', **kwargs)</code>","text":"<p>Initialize a RASPA3 simulation.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_json</code> <p>Simulation configuration as dict or JSON string</p> required <code>force_field_json</code> <p>Force field configuration as dict or JSON string</p> <code>None</code> <code>framework_file</code> <p>Path to framework file (CIF)</p> <code>None</code> <code>component_files</code> <p>Dict mapping component names to their definition files              e.g. {\"CO2\": \"path/to/CO2.json\"}</p> <code>None</code> <code>working_directory</code> <p>Directory to run the simulation in</p> <code>'.'</code> <code>kwargs</code> <p>Additional arguments - timeout: Maximum execution time in seconds - name: Job name - threads: Number of threads to use</p> <code>{}</code> Source code in <code>chmpy/exe/raspa.py</code> <pre><code>def __init__(\n    self,\n    simulation_json,\n    force_field_json=None,\n    framework_file=None,\n    component_files=None,\n    *args,\n    working_directory=\".\",\n    **kwargs,\n):\n    \"\"\"\n    Initialize a RASPA3 simulation.\n\n    Args:\n        simulation_json: Simulation configuration as dict or JSON string\n        force_field_json: Force field configuration as dict or JSON string\n        framework_file: Path to framework file (CIF)\n        component_files: Dict mapping component names to their definition files\n                         e.g. {\"CO2\": \"path/to/CO2.json\"}\n        working_directory: Directory to run the simulation in\n        kwargs: Additional arguments\n            - timeout: Maximum execution time in seconds\n            - name: Job name\n            - threads: Number of threads to use\n    \"\"\"\n    self._timeout = kwargs.get(\"timeout\", self._timeout)\n    self.name = kwargs.get(\"name\", \"raspa_job\")\n    self.threads = kwargs.get(\"threads\", 1)\n\n    # Store inputs\n    self.simulation_json = simulation_json\n    self.force_field_json = force_field_json\n    self.framework_file = framework_file\n    self.component_files = component_files or {}\n\n    # Store outputs\n    self.output_contents = None\n    self.error_contents = None\n\n    # Setup\n    self.kwargs = kwargs.copy()\n    self.working_directory = working_directory\n    LOG.debug(\"Initializing RASPA3 calculation, timeout = %s\", self.timeout)\n\n    # Framework and component information\n    self._framework_name = None\n    self._component_names = []\n\n    # Extract framework and component names from simulation JSON\n    if isinstance(simulation_json, dict):\n        sim_data = simulation_json\n    else:\n        try:\n            sim_data = json.loads(simulation_json)\n        except (json.JSONDecodeError, TypeError):\n            sim_data = {}\n\n    # Extract framework name and component names if present\n    if \"Systems\" in sim_data and len(sim_data[\"Systems\"]) &gt; 0:\n        if \"Name\" in sim_data[\"Systems\"][0]:\n            self._framework_name = sim_data[\"Systems\"][0][\"Name\"]\n\n    if \"Components\" in sim_data:\n        for component in sim_data[\"Components\"]:\n            if \"Name\" in component:\n                self._component_names.append(component[\"Name\"])\n</code></pre>"},{"location":"reference/chmpy/exe/raspa/#chmpy.exe.raspa.Raspa.post_process","title":"<code>post_process()</code>","text":"<p>Process output after the job completes</p> Source code in <code>chmpy/exe/raspa.py</code> <pre><code>def post_process(self):\n    \"\"\"Process output after the job completes\"\"\"\n    # Find and read output files\n    output_dir = Path(self.working_directory, \"output\")\n    if output_dir.exists() and output_dir.is_dir():\n        # Find the most recent .txt output file\n        output_files = list(output_dir.glob(\"*.txt\"))\n        if output_files:\n            latest_output = max(output_files, key=lambda p: p.stat().st_mtime)\n            self.output_contents = latest_output.read_text()\n            return\n\n    # If no output files found, check for standard output redirect\n    if Path(self.output_file).exists():\n        self.output_contents = Path(self.output_file).read_text()\n    else:\n        LOG.warning(\"No output files found after RASPA3 execution\")\n        self.output_contents = \"\"\n</code></pre>"},{"location":"reference/chmpy/exe/raspa/#chmpy.exe.raspa.Raspa.resolve_dependencies","title":"<code>resolve_dependencies()</code>","text":"<p>Write all necessary files before running the job</p> Source code in <code>chmpy/exe/raspa.py</code> <pre><code>def resolve_dependencies(self):\n    \"\"\"Write all necessary files before running the job\"\"\"\n    LOG.debug(\"Writing RASPA3 simulation files to %s\", self.working_directory)\n\n    # Write simulation.json\n    if isinstance(self.simulation_json, dict):\n        simulation_content = json.dumps(self.simulation_json, indent=2)\n    else:\n        simulation_content = self.simulation_json\n\n    Path(self.simulation_file).write_text(simulation_content)\n\n    # Write force_field.json if provided\n    if self.force_field_json:\n        if isinstance(self.force_field_json, dict):\n            force_field_content = json.dumps(self.force_field_json, indent=2)\n        else:\n            force_field_content = self.force_field_json\n\n        Path(self.force_field_file).write_text(force_field_content)\n\n    # Copy framework file if provided\n    if self.framework_file:\n        framework_dest = self._get_framework_path()\n        if framework_dest:\n            # Handle both file paths and content strings\n            if (\n                isinstance(self.framework_file, str | Path)\n                and Path(self.framework_file).exists()\n            ):\n                shutil.copy2(self.framework_file, framework_dest)\n            else:\n                # Assume it's the content as string\n                Path(framework_dest).write_text(self.framework_file)\n\n    # Copy component files if provided\n    for component_name, component_file in self.component_files.items():\n        component_dest = self._get_component_path(component_name)\n\n        # Handle both file paths and content (dict or string)\n        if isinstance(component_file, dict):\n            component_content = json.dumps(component_file, indent=2)\n            Path(component_dest).write_text(component_content)\n        elif (\n            isinstance(component_file, str | Path) and Path(component_file).exists()\n        ):\n            shutil.copy2(component_file, component_dest)\n        else:\n            # Assume it's the content as string\n            Path(component_dest).write_text(component_file)\n</code></pre>"},{"location":"reference/chmpy/exe/raspa/#chmpy.exe.raspa.Raspa.result","title":"<code>result()</code>","text":"<p>Return the output contents</p> Source code in <code>chmpy/exe/raspa.py</code> <pre><code>def result(self):\n    \"\"\"Return the output contents\"\"\"\n    return self.output_contents\n</code></pre>"},{"location":"reference/chmpy/exe/raspa/#chmpy.exe.raspa.Raspa.run","title":"<code>run(*args, **kwargs)</code>","text":"<p>Run RASPA3 with the simulation file</p> Source code in <code>chmpy/exe/raspa.py</code> <pre><code>def run(self, *args, **kwargs):\n    \"\"\"Run RASPA3 with the simulation file\"\"\"\n    LOG.debug(\"Running %s in %s\", self._executable_location, self.working_directory)\n    try:\n        with TemporaryFile() as tmp:\n            env = copy.deepcopy(environ)\n            env.update(\n                {\n                    \"OMP_NUM_THREADS\": str(self.threads) + \",1\",\n                    \"OMP_MAX_ACTIVE_LEVELS\": \"1\",\n                    \"MKL_NUM_THREADS\": str(self.threads),\n                }\n            )\n            # RASPA3 is run without arguments - it automatically looks for simulation.json\n            self._run_raw(stderr=tmp, env=env)\n            tmp.seek(0)\n            self.error_contents = tmp.read().decode(\"utf-8\")\n    except ReturnCodeError as e:\n        from shutil import copytree\n\n        from chmpy.util.path import list_directory\n\n        LOG.error(\"RASPA3 execution failed: %s\", e)\n        self.post_process()\n        LOG.error(\"output: %s\", self.output_contents)\n        LOG.error(\"Directory contents\\n%s\", list_directory(self.working_directory))\n        copytree(self.working_directory, \"failed_job\")\n        raise e\n</code></pre>"},{"location":"reference/chmpy/exe/tonto/","title":"tonto","text":""},{"location":"reference/chmpy/exe/tonto/#chmpy.exe.tonto.Tonto","title":"<code>Tonto</code>","text":"<p>               Bases: <code>AbstractExecutable</code></p> Source code in <code>chmpy/exe/tonto.py</code> <pre><code>class Tonto(AbstractExecutable):\n    _executable_location = TONTO_EXEC\n    _STDIN = \"stdin\"\n    _STDOUT = \"stdout\"\n    _STDERR = \"stderr\"\n\n    def __init__(\n        self,\n        input_file,\n        name=\"tonto_job\",\n        working_directory=\".\",\n        output_file=None,\n        extra_inputs=(),\n        extra_outputs=(),\n    ):\n        \"\"\"\n        Parameters\n        ----------\n        input_file : str\n            string of tonto input format\n        output_file : str, optional\n            output_file to store tonto output in,\n            by default will be returned as the result\n        \"\"\"\n        assert isinstance(input_file, str)\n\n        self.name = name\n        self.working_directory = working_directory\n        self.input_file_contents = input_file\n        self.output_file = str(self.stdout_file)\n        if output_file:\n            self.output_file = str(output_file)\n        self.stdin_contents = None\n        self.stdout_contents = None\n        self.stderr_contents = None\n        self.extra_inputs = extra_inputs\n        self.extra_outputs = extra_outputs\n        self.basis_set_directory = \"\"\n\n    @property\n    def stdin_file(self):\n        return Path(self.working_directory, self._STDIN)\n\n    @property\n    def stdout_file(self):\n        return Path(self.working_directory, self._STDOUT)\n\n    @property\n    def stderr_file(self):\n        return Path(self.working_directory, self._STDERR)\n\n    def read_stderr(self):\n        if self.stderr_file.exists():\n            return self.stderr_file.read_text()\n        return \"\"\n\n    def read_stdout(self):\n        if self.stdout_file.exists():\n            return self.stdout_file.read_text()\n        return \"\"\n\n    def write_inputs(self):\n        self.stdin_file.write_text(self.input_file_contents)\n\n    def resolve_dependencies(self):\n        \"\"\"Do whatever needs to be done before running\n        the job (e.g. write input file etc.)\"\"\"\n        self.write_inputs()\n\n    def result(self):\n        return self.stdout_contents\n\n    def post_process(self):\n        self.stdout_contents = self.read_stdout()\n        self.stderr_contents = self.read_stderr()\n\n        if self.stdin_file.exists():\n            self.stdin_file.unlink()\n        if self.stderr_file.exists():\n            self.stderr_file.unlink()\n        if self.stdout_file.exists():\n            self.stdout_file.unlink()\n\n        output_file = Path(self.output_file)\n        if not output_file.exists():\n            output_file.write_text(self.stdout_contents)\n\n    def run(self, *args, **kwargs):\n        from copy import deepcopy\n        from os import environ\n\n        env = deepcopy(environ)\n        env.update(\n            {\n                \"TONTO_BASIS_SET_DIRECTORY\": str(self.basis_set_directory),\n            }\n        )\n        self._run_raw()\n</code></pre>"},{"location":"reference/chmpy/exe/tonto/#chmpy.exe.tonto.Tonto.__init__","title":"<code>__init__(input_file, name='tonto_job', working_directory='.', output_file=None, extra_inputs=(), extra_outputs=())</code>","text":""},{"location":"reference/chmpy/exe/tonto/#chmpy.exe.tonto.Tonto.__init__--parameters","title":"Parameters","text":"<p>input_file : str     string of tonto input format output_file : str, optional     output_file to store tonto output in,     by default will be returned as the result</p> Source code in <code>chmpy/exe/tonto.py</code> <pre><code>def __init__(\n    self,\n    input_file,\n    name=\"tonto_job\",\n    working_directory=\".\",\n    output_file=None,\n    extra_inputs=(),\n    extra_outputs=(),\n):\n    \"\"\"\n    Parameters\n    ----------\n    input_file : str\n        string of tonto input format\n    output_file : str, optional\n        output_file to store tonto output in,\n        by default will be returned as the result\n    \"\"\"\n    assert isinstance(input_file, str)\n\n    self.name = name\n    self.working_directory = working_directory\n    self.input_file_contents = input_file\n    self.output_file = str(self.stdout_file)\n    if output_file:\n        self.output_file = str(output_file)\n    self.stdin_contents = None\n    self.stdout_contents = None\n    self.stderr_contents = None\n    self.extra_inputs = extra_inputs\n    self.extra_outputs = extra_outputs\n    self.basis_set_directory = \"\"\n</code></pre>"},{"location":"reference/chmpy/exe/tonto/#chmpy.exe.tonto.Tonto.resolve_dependencies","title":"<code>resolve_dependencies()</code>","text":"<p>Do whatever needs to be done before running the job (e.g. write input file etc.)</p> Source code in <code>chmpy/exe/tonto.py</code> <pre><code>def resolve_dependencies(self):\n    \"\"\"Do whatever needs to be done before running\n    the job (e.g. write input file etc.)\"\"\"\n    self.write_inputs()\n</code></pre>"},{"location":"reference/chmpy/exe/xtb/","title":"xtb","text":""},{"location":"reference/chmpy/exe/xtb/#chmpy.exe.xtb.Xtb","title":"<code>Xtb</code>","text":"<p>               Bases: <code>AbstractExecutable</code></p> Source code in <code>chmpy/exe/xtb.py</code> <pre><code>class Xtb(AbstractExecutable):\n    _input_file = \"xtb.coord\"\n    _charge_file = \".CHRG\"\n    _partial_charge_file = \"charges\"\n    _uhf_file = \".UHF\"\n    _output_file = \"xtbopt.stdout\"\n    _executable_location = XTB_EXEC\n    _timeout = 1800.0\n\n    def __init__(self, input_contents, *args, working_directory=\".\", **kwargs):\n        self._timeout = kwargs.get(\"timeout\", self._timeout)\n        self.name = kwargs.get(\"name\", \"coord\")\n        self.gfn = kwargs.get(\"gfn\", 0)\n        self.opt = kwargs.get(\"opt\", True)\n        self.solvent = kwargs.get(\"solvent\", None)\n        self.stacksize = kwargs.get(\"stacksize\", \"2GB\")\n        self.threads = kwargs.get(\"threads\", 1)\n        self.input_contents = input_contents\n        self.output_contents = None\n        self.opt_log_contents = None\n        self.opt_coord_contents = None\n        self.kwargs = kwargs.copy()\n        self.esp = None\n        self.working_directory = working_directory\n        self.args = [self.input_file, f\"--gfn{self.gfn}\"]\n        if self.solvent is not None:\n            self.args += [\"--gbsa\", self.solvent]\n        LOG.debug(\n            \"Initializing GFN%s-xTB calculation opt: %s, timeout: %ss\",\n            self.gfn,\n            self.opt,\n            self.timeout,\n        )\n        self.error_contents = None\n        if self.opt:\n            self.args.append(\"--opt\")\n\n    @property\n    def input_file(self):\n        return join(self.working_directory, self._input_file)\n\n    @property\n    def charge_file(self):\n        return join(self.working_directory, self._charge_file)\n\n    @property\n    def partial_charge_file(self):\n        return join(self.working_directory, self._partial_charge_file)\n\n    @property\n    def uhf_file(self):\n        return join(self.working_directory, self._charge_file)\n\n    @property\n    def output_file(self):\n        return join(self.working_directory, self._output_file)\n\n    @property\n    def esp_file(self):\n        return join(self.working_directory, \"xtb_esp.dat\")\n\n    def resolve_dependencies(self):\n        \"\"\"Do whatever needs to be done before running\n        the job (e.g. write input file etc.)\"\"\"\n        LOG.debug(\"Writing input file to %s\", self.input_file)\n        with open(self.input_file, \"w\") as f:\n            f.write(self.input_contents)\n\n    def result(self):\n        return self.output_contents\n\n    def post_process(self):\n        with open(self.output_file) as f:\n            self.output_contents = f.read()\n\n        opt_files = {\n            \"opt_log\": join(self.working_directory, \"xtbopt.log\"),\n            \"opt_coord\": join(self.working_directory, \"xtbopt.coord\"),\n            \"trajectory\": join(self.working_directory, \"xtbopt.trj\"),\n            \"chg\": self.charge_file,\n            \"uhf\": self.uhf_file,\n        }\n        for k, loc in opt_files.items():\n            if exists(loc):\n                LOG.debug(\"Reading %s: %s\", k, loc)\n                setattr(self, k + \"_contents\", Path(loc).read_text())\n        if exists(self.esp_file):\n            self.esp = np.loadtxt(self.esp_file)\n\n        if exists(self.partial_charge_file):\n            self.partial_charges = np.loadtxt(self.partial_charge_file)\n\n    def run(self, *args, **kwargs):\n        LOG.debug(\"Running `xtb %s`\", \" \".join(self.args))\n        try:\n            with TemporaryFile() as tmp:\n                env = copy.deepcopy(environ)\n                env.update(\n                    {\n                        \"OMP_NUM_THREADS\": str(self.threads) + \",1\",\n                        \"OMP_STACKSIZE\": str(self.stacksize),\n                        \"OMP_MAX_ACTIVE_LEVELS\": \"1\",\n                        \"MKL_NUM_THREADS\": str(self.threads),\n                    }\n                )\n                self._run_raw(*self.args, stderr=tmp, env=env)\n                tmp.seek(0)\n                self.error_contents = tmp.read().decode(\"utf-8\")\n        except ReturnCodeError as e:\n            from shutil import copytree\n\n            from chmpy.util.path import list_directory\n\n            LOG.error(\"XTB failed: %s\", e)\n            self.post_process()\n            LOG.error(\"output: %s\", self.output_contents)\n            LOG.error(\"Directory contents\\n%s\", list_directory(self.working_directory))\n            copytree(self.working_directory, \"failed_job\")\n            raise e\n</code></pre>"},{"location":"reference/chmpy/exe/xtb/#chmpy.exe.xtb.Xtb.resolve_dependencies","title":"<code>resolve_dependencies()</code>","text":"<p>Do whatever needs to be done before running the job (e.g. write input file etc.)</p> Source code in <code>chmpy/exe/xtb.py</code> <pre><code>def resolve_dependencies(self):\n    \"\"\"Do whatever needs to be done before running\n    the job (e.g. write input file etc.)\"\"\"\n    LOG.debug(\"Writing input file to %s\", self.input_file)\n    with open(self.input_file, \"w\") as f:\n        f.write(self.input_contents)\n</code></pre>"},{"location":"reference/chmpy/ext/ase/","title":"ase","text":""},{"location":"reference/chmpy/ext/ase/#chmpy.ext.ase.ase_to_crystal","title":"<code>ase_to_crystal(atoms, **kwargs)</code>","text":"<p>Convert an ASE Atoms object to a Crystal object. Assumes it is in P1</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <p>ASE Atoms object representing the crystal structure</p> required <p>Returns:</p> Name Type Description <code>Crystal</code> <p>Crystal object with unit_cell, space_group, and asymmetric_unit</p> Source code in <code>chmpy/ext/ase.py</code> <pre><code>def ase_to_crystal(atoms, **kwargs):\n    \"\"\"\n    Convert an ASE Atoms object to a Crystal object. Assumes it is in P1\n\n    Args:\n        atoms: ASE Atoms object representing the crystal structure\n\n    Returns:\n        Crystal: Crystal object with unit_cell, space_group, and asymmetric_unit\n    \"\"\"\n    try:\n        import ase  # noqa: F401\n    except ImportError as e:\n        raise ImportError(\"ASE library is required\") from e\n\n    if not atoms.pbc.all():\n        raise ValueError(\"Atoms object must have 3D periodic boundary conditions\")\n\n    cell_matrix = atoms.get_cell()\n    unit_cell = UnitCell(cell_matrix)\n\n    sg = SpaceGroup(1)\n\n    atomic_numbers = atoms.get_atomic_numbers()\n    positions_cart = atoms.get_positions()\n\n    positions_frac = unit_cell.to_fractional(positions_cart)\n    elements = [Element.from_atomic_number(num) for num in atomic_numbers]\n\n    labels = atoms.arrays.get(\"labels\", None)\n    occupancy = atoms.arrays.get(\"occupancy\", None)\n\n    asymmetric_unit = AsymmetricUnit(\n        elements=elements,\n        positions=positions_frac,\n        labels=labels,\n        occupation=occupancy,\n    )\n\n    crystal = Crystal(\n        unit_cell=unit_cell, space_group=sg, asymmetric_unit=asymmetric_unit\n    )\n\n    return crystal\n</code></pre>"},{"location":"reference/chmpy/ext/ase/#chmpy.ext.ase.ase_to_molecule","title":"<code>ase_to_molecule(atoms, **kwargs)</code>","text":"<p>Convert an ASE Atoms object to a Molecule object.</p> <p>Parameters:</p> Name Type Description Default <code>atoms</code> <p>ASE Atoms object representing the molecule</p> required <p>Returns:</p> Name Type Description <code>Molecule</code> <p>Molecule object atoms and position information</p> Source code in <code>chmpy/ext/ase.py</code> <pre><code>def ase_to_molecule(atoms, **kwargs):\n    \"\"\"\n    Convert an ASE Atoms object to a Molecule object.\n\n    Args:\n        atoms: ASE Atoms object representing the molecule\n\n    Returns:\n        Molecule: Molecule object atoms and position information\n    \"\"\"\n    try:\n        import ase  # noqa: F401\n    except ImportError as e:\n        raise ImportError(\"ASE library is required\") from e\n\n    if atoms.pbc.any():\n        raise ValueError(\"Atoms object must not have periodic boundary conditions\")\n\n    return Molecule.from_arrays(atoms.get_atomic_numbers(), atoms.get_positions())\n</code></pre>"},{"location":"reference/chmpy/ext/ase/#chmpy.ext.ase.crystal_to_ase","title":"<code>crystal_to_ase(crystal, **kwargs)</code>","text":"<p>Convert a Crystal object to an ASE Atoms object.</p> <p>Parameters:</p> Name Type Description Default <code>crystal</code> <p>Crystal object with unit_cell, space_group, and asymmetric_unit</p> required <p>Returns:</p> Type Description <p>ase.Atoms: ASE Atoms object representing the crystal structure</p> Source code in <code>chmpy/ext/ase.py</code> <pre><code>def crystal_to_ase(crystal, **kwargs):\n    \"\"\"\n    Convert a Crystal object to an ASE Atoms object.\n\n    Args:\n        crystal: Crystal object with unit_cell, space_group, and asymmetric_unit\n\n    Returns:\n        ase.Atoms: ASE Atoms object representing the crystal structure\n    \"\"\"\n    try:\n        from ase import Atoms\n    except ImportError as e:\n        raise ImportError(\"ASE library is required.\") from e\n\n    uc_atoms = crystal.unit_cell_atoms()\n\n    atomic_numbers = uc_atoms[\"element\"]\n    positions = uc_atoms[\"frac_pos\"]\n\n    cell = crystal.unit_cell.parameters\n\n    atoms = Atoms(\n        numbers=atomic_numbers,\n        scaled_positions=positions,\n        cell=cell,\n        pbc=True,\n    )\n\n    if \"occupation\" in uc_atoms:\n        atoms.arrays[\"occupancy\"] = uc_atoms[\"occupation\"]\n\n    if \"label\" in uc_atoms:\n        atoms.arrays[\"labels\"] = uc_atoms[\"label\"]\n\n    atoms.arrays[\"asym_atom\"] = uc_atoms[\"asym_atom\"]\n    atoms.arrays[\"symop\"] = uc_atoms[\"symop\"]\n\n    atoms.info[\"space_group\"] = crystal.space_group.symbol\n    atoms.info[\"space_group_number\"] = crystal.space_group.international_tables_number\n\n    if hasattr(crystal, \"properties\") and crystal.properties:\n        for key, value in crystal.properties.items():\n            if isinstance(value, int | float | str | bool):\n                atoms.info[f\"crystal_{key}\"] = value\n\n    return atoms\n</code></pre>"},{"location":"reference/chmpy/ext/ase/#chmpy.ext.ase.molecule_to_ase","title":"<code>molecule_to_ase(mol, **kwargs)</code>","text":"<p>Convert a Molecule object to an ASE Atoms object.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <p>a chmpy Molecule object</p> required <p>Returns:</p> Type Description <p>ase.Atoms: ASE Atoms object representing the molecule</p> Source code in <code>chmpy/ext/ase.py</code> <pre><code>def molecule_to_ase(mol, **kwargs):\n    \"\"\"\n    Convert a Molecule object to an ASE Atoms object.\n\n    Args:\n        mol: a chmpy Molecule object\n\n    Returns:\n        ase.Atoms: ASE Atoms object representing the molecule\n    \"\"\"\n    try:\n        from ase import Atoms\n    except ImportError as e:\n        raise ImportError(\"ASE library is required.\") from e\n\n    atoms = Atoms(\n        numbers=mol.atomic_numbers,\n        positions=mol.positions,\n        pbc=False,\n    )\n\n    if hasattr(mol, \"properties\") and mol.properties:\n        for key, value in mol.properties.items():\n            if isinstance(value, int | float | str | bool):\n                atoms.info[f\"molecule_{key}\"] = value\n    return atoms\n</code></pre>"},{"location":"reference/chmpy/ext/charges/","title":"charges","text":""},{"location":"reference/chmpy/ext/charges/#chmpy.ext.charges.EEM","title":"<code>EEM</code>","text":"<p>Class to handle calculation of electronegativity equilibration method charges</p> Source code in <code>chmpy/ext/charges.py</code> <pre><code>class EEM:\n    \"Class to handle calculation of electronegativity equilibration method charges\"\n\n    @staticmethod\n    def calculate_charges(mol):\n        \"\"\"\n        Calculate the partial atomic charges based on the EEM method.\n\n        Args:\n            mol (Molecule): The molecule with atoms where partial charges are desired\n\n        Returns:\n            np.ndarray: the partial charges associated the atoms in `mol`\n        \"\"\"\n        A = []\n        B = []\n        for el in mol.elements:\n            a, b = EEM_PARAMETERS.get(el.symbol, EEM_PARAMETERS[\"*\"])\n            A.append(a)\n            B.append(b)\n        N = len(mol)\n        M = np.zeros((N + 1, N + 1))\n        M[-1, :-1] = 1\n        M[:-1, -1] = -1\n        dists = mol.distance_matrix\n        idx = np.triu_indices(N, k=1)\n        M[idx] = EEM_KAPPA / dists[idx]\n        idx = np.tril_indices(N, k=-1)\n        M[idx] = EEM_KAPPA / dists[idx]\n        np.fill_diagonal(M, B)\n        M[N, N] = 0.0\n        y = np.zeros(N + 1)\n        y[:N] -= A\n        y[N] = mol.charge\n        return np.linalg.solve(M, y)[:N]\n</code></pre>"},{"location":"reference/chmpy/ext/charges/#chmpy.ext.charges.EEM.calculate_charges","title":"<code>calculate_charges(mol)</code>  <code>staticmethod</code>","text":"<p>Calculate the partial atomic charges based on the EEM method.</p> <p>Parameters:</p> Name Type Description Default <code>mol</code> <code>Molecule</code> <p>The molecule with atoms where partial charges are desired</p> required <p>Returns:</p> Type Description <p>np.ndarray: the partial charges associated the atoms in <code>mol</code></p> Source code in <code>chmpy/ext/charges.py</code> <pre><code>@staticmethod\ndef calculate_charges(mol):\n    \"\"\"\n    Calculate the partial atomic charges based on the EEM method.\n\n    Args:\n        mol (Molecule): The molecule with atoms where partial charges are desired\n\n    Returns:\n        np.ndarray: the partial charges associated the atoms in `mol`\n    \"\"\"\n    A = []\n    B = []\n    for el in mol.elements:\n        a, b = EEM_PARAMETERS.get(el.symbol, EEM_PARAMETERS[\"*\"])\n        A.append(a)\n        B.append(b)\n    N = len(mol)\n    M = np.zeros((N + 1, N + 1))\n    M[-1, :-1] = 1\n    M[:-1, -1] = -1\n    dists = mol.distance_matrix\n    idx = np.triu_indices(N, k=1)\n    M[idx] = EEM_KAPPA / dists[idx]\n    idx = np.tril_indices(N, k=-1)\n    M[idx] = EEM_KAPPA / dists[idx]\n    np.fill_diagonal(M, B)\n    M[N, N] = 0.0\n    y = np.zeros(N + 1)\n    y[:N] -= A\n    y[N] = mol.charge\n    return np.linalg.solve(M, y)[:N]\n</code></pre>"},{"location":"reference/chmpy/ext/cosmo/","title":"cosmo","text":""},{"location":"reference/chmpy/ext/crystal/","title":"crystal","text":""},{"location":"reference/chmpy/ext/cx/","title":"cx","text":""},{"location":"reference/chmpy/ext/elastic_tensor/","title":"elastic_tensor","text":"<p>Heavily inspired by fxcoudert's ELATE, and since it is a modified version of that, this is subject to the same MIT license.</p> <p>See the page, and the source here: <pre><code>    http://progs.coudert.name/elate\n    https://github.com/fxcoudert/elate\n</code></pre></p>"},{"location":"reference/chmpy/ext/elastic_tensor/#chmpy.ext.elastic_tensor.ElasticTensor","title":"<code>ElasticTensor</code>","text":"<p>Class to represent an elastic tensor, along with methods to access it</p> Source code in <code>chmpy/ext/elastic_tensor.py</code> <pre><code>class ElasticTensor:\n    \"\"\"\n    Class to represent an elastic tensor, along with methods to access it\n    \"\"\"\n\n    def __init__(self, mat):\n        mat = np.asarray(mat, dtype=np.float64)\n        if mat.shape != (6, 6):\n            # Is it upper triangular?\n            if list(map(len, mat)) == [6, 5, 4, 3, 2, 1]:\n                mat = [[0] * i + mat[i] for i in range(6)]\n                mat = np.array(mat)\n\n            # Is it lower triangular?\n            if list(map(len, mat)) == [1, 2, 3, 4, 5, 6]:\n                mat = [mat[i] + [0] * (5 - i) for i in range(6)]\n                mat = np.array(mat)\n\n        if mat.shape != (6, 6):\n            raise ValueError(\"should be a square matrix\")\n\n        # Check that is is symmetric, or make it symmetric\n        if np.linalg.norm(np.tril(mat, -1)) == 0:\n            mat = mat + np.triu(mat, 1).transpose()\n        if np.linalg.norm(np.triu(mat, 1)) == 0:\n            mat = mat + np.tril(mat, -1).transpose()\n        if np.linalg.norm(mat - mat.transpose()) &gt; 1e-3:\n            raise ValueError(\"should be symmetric, or triangular\")\n        elif np.linalg.norm(mat - mat.transpose()) &gt; 0:\n            mat = 0.5 * (mat + mat.transpose())\n\n        # Store it\n        self.c_voigt = np.array(mat)\n\n        # Put it in a more useful representation\n        try:\n            self.s_voigt = np.linalg.inv(self.c_voigt)\n        except np.linalg.LinalgError as e:\n            raise ValueError(f\"Error inverting s_voigt: {e}\") from e\n\n        vm = np.array(((0, 5, 4), (5, 1, 3), (4, 3, 2)))\n\n        def sv_coeff(p, q):\n            return 1.0 / ((1 + p // 3) * (1 + q // 3))\n\n        smat = [\n            [\n                [\n                    [\n                        sv_coeff(vm[i, j], vm[k, l]) * self.s_voigt[vm[i, j], vm[k, l]]\n                        for i in range(3)\n                    ]\n                    for j in range(3)\n                ]\n                for k in range(3)\n            ]\n            for l in range(3)\n        ]\n        self.elasticity_tensor = np.array(smat)\n\n    @classmethod\n    def from_string(cls, s):\n        \"\"\"Initialize the elastic tensor from a string\"\"\"\n        if not s:\n            raise ValueError(\"no matrix was provided\")\n\n        if isinstance(s, str):\n            # Remove braces and pipes\n            s = s.replace(\"|\", \" \").replace(\"(\", \" \").replace(\")\", \" \")\n\n            # Remove empty lines\n            lines = [line for line in s.split(\"\\n\") if line.strip()]\n            if len(lines) != 6:\n                raise ValueError(\"should have six rows\")\n\n            # Convert to float\n            try:\n                mat = [[float(x) for x in line.split()] for line in lines]\n            except ValueError as e:\n                raise ValueError(f\"not all entries are numbers: {e}\") from e\n        return cls(mat)\n\n    def youngs_modulus_angular(self, theta, phi):\n        a = angles_to_cartesian(theta, phi)\n        return self.youngs_modulus(a)\n\n    def youngs_modulus(self, a):\n        return 1 / np.einsum(\"ai,aj,ak,al,ijkl-&gt;a\", a, a, a, a, self.elasticity_tensor)\n\n    def linear_compressibility_angular(self, theta, phi):\n        a = angles_to_cartesian(theta, phi)\n        return self.linear_compressibility(a)\n\n    def linear_compressibility(self, a):\n        return 1000 * np.einsum(\"ai,aj,ijkk-&gt;a\", a, a, self.elasticity_tensor)\n\n    def shear_modulus(self, a, b):\n        return 0.25 / np.einsum(\n            \"ai,aj,ak,al,ijkl-&gt;a\", a, b, a, b, self.elasticity_tensor\n        )\n\n    def shear_modulus_angular(self, theta, phi, chi):\n        a = angles_to_cartesian(theta, phi)\n        b = angles_to_cartesian_2(theta, phi, chi)\n        return self.shear_modulus(a, b)\n\n    def poisson_ratio(self, a, b):\n        r1 = np.einsum(\"ai,aj,ak,al,ijkl-&gt;a\", a, a, b, b, self.elasticity_tensor)\n        r2 = np.einsum(\"ai,aj,ak,al,ijkl-&gt;a\", a, a, a, a, self.elasticity_tensor)\n        return -r1 / r2\n\n    def poisson_ratio_angular(self, theta, phi, chi):\n        a = angles_to_cartesian(theta, phi)\n        b = angles_to_cartesian_2(theta, phi, chi)\n        return self.poisson_ratio(a, b)\n\n    def averages(self):\n        A = (self.c_voigt[0, 0] + self.c_voigt[1, 1] + self.c_voigt[2, 2]) / 3\n        B = (self.c_voigt[1, 2] + self.c_voigt[0, 2] + self.c_voigt[0, 1]) / 3\n        C = (self.c_voigt[3, 3] + self.c_voigt[4, 4] + self.c_voigt[5, 5]) / 3\n        a = (self.s_voigt[0, 0] + self.s_voigt[1, 1] + self.s_voigt[2, 2]) / 3\n        b = (self.s_voigt[1, 2] + self.s_voigt[0, 2] + self.s_voigt[0, 1]) / 3\n        c = (self.s_voigt[3, 3] + self.s_voigt[4, 4] + self.s_voigt[5, 5]) / 3\n\n        KV = (A + 2 * B) / 3\n        GV = (A - B + 3 * C) / 5\n\n        KR = 1 / (3 * a + 6 * b)\n        GR = 5 / (4 * a - 4 * b + 3 * c)\n\n        KH = (KV + KR) / 2\n        GH = (GV + GR) / 2\n\n        return {\n            \"bulk_modulus_avg\": {\n                \"voigt\": KV,\n                \"reuss\": KR,\n                \"hill\": KH,\n            },\n            \"shear_modulus_avg\": {\"voigt\": GV, \"reuss\": GR, \"hill\": GH},\n            \"youngs_modulus_avg\": {\n                \"voigt\": 1 / (1 / (3 * GV) + 1 / (9 * KV)),\n                \"reuss\": 1 / (1 / (3 * GR) + 1 / (9 * KR)),\n                \"hill\": 1 / (1 / (3 * GH) + 1 / (9 * KH)),\n                \"spackman\": self.spackman_average(kind=\"youngs_modulus\"),\n            },\n            \"poissons_ratio_avg\": {\n                \"voigt\": (1 - 3 * GV / (3 * KV + GV)) / 2,\n                \"reuss\": (1 - 3 * GR / (3 * KR + GR)) / 2,\n                \"hill\": (1 - 3 * GH / (3 * KH + GH)) / 2,\n            },\n        }\n\n    def plot2d(self, kind=\"youngs_modulus\", axis=\"xy\", npoints=100, **kwargs):\n        import matplotlib.pyplot as plt\n        import seaborn as sns\n\n        u = np.linspace(0, np.pi * 2, npoints)\n        v = np.zeros_like(u)\n        f = getattr(self, kind + \"_angular\")\n        fig, ax = plt.subplots()\n        fig.set_size_inches(kwargs.pop(\"figsize\", (3, 3)))\n        font = \"Arial\"\n        xlims = kwargs.pop(\"xlim\", None)\n        ylims = kwargs.pop(\"ylim\", None)\n        #        ax.set_title(f\"${axis}$-plane\", fontname=font, fontsize=12)\n        ax.set_xlabel(f\"{axis[0]}\", fontsize=12)\n        ax.set_ylabel(f\"{axis[1]}\", fontsize=12, rotation=0)\n        if axis == \"xy\":\n            v[:] = np.pi / 2\n            r = f(v, u)\n            x = r * np.cos(u)\n            y = r * np.sin(u)\n        elif axis == \"xz\":\n            r = f(u, v)\n            y = r * np.cos(u)\n            x = r * np.sin(u)\n        elif axis == \"yz\":\n            v[:] = np.pi / 2\n            r = f(u, v)\n            y = r * np.cos(u)\n            x = r * np.sin(u)\n        if xlims:\n            ax.set_xlim(*xlims)\n        if ylims:\n            ax.set_ylim(*ylims)\n        ax.xaxis.set_major_locator(plt.MaxNLocator(9))\n        ax.yaxis.set_major_locator(plt.MaxNLocator(9))\n        ax.plot(x, y, c=\"k\", **kwargs)\n        sns.despine(ax=ax, offset=0)\n        ax.spines[\"bottom\"].set_position(\"zero\")\n        ax.spines[\"left\"].set_position(\"zero\")\n        if kwargs.get(\"grid\", False):\n            ax.grid(\"minor\", color=\"#BBBBBB\", linewidth=0.5)\n        zero_tick = (len(ax.get_xticks()) - 1) // 2\n        for tick in ax.get_xticklabels():\n            tick.set_fontname(font)\n            tick.set_fontsize(4)\n        for tick in ax.get_yticklabels():\n            tick.set_fontname(font)\n            tick.set_fontsize(4)\n        ax.get_xticklabels()[zero_tick].set_visible(False)\n        ax.get_yticklabels()[zero_tick].set_visible(False)\n        ax.xaxis.set_label_coords(1.05, 0.53)\n        ax.yaxis.set_label_coords(0.49, 1.02)\n        return ax\n\n    def mesh(self, kind=\"youngs_modulus\", subdivisions=3):\n        import trimesh\n\n        f = getattr(self, kind)\n        sphere = trimesh.creation.icosphere(subdivisions=subdivisions)\n        r = f(sphere.vertices)\n        sphere.vertices *= r[:, np.newaxis]\n        return sphere\n\n    def shape_descriptors(self, kind=\"youngs_modulus\", l_max=5, **kwargs):\n        from chmpy.shape.shape_descriptors import make_invariants\n        from chmpy.shape.sht import SHT\n\n        sht = SHT(l_max=l_max)\n        f = getattr(self, kind)\n        points = sht.grid_cartesian\n        vals = f(points)\n        if kwargs.get(\"normalize\", False):\n            vals = vals / self.spackman_average(kind=kind)\n        coeffs = sht.analyse(vals)\n        invariants = make_invariants(l_max, coeffs)\n        if kwargs.get(\"coefficients\", False):\n            return coeffs, invariants\n        return invariants\n\n    def spackman_average(self, kind=\"youngs_modulus\"):\n        mesh = self.mesh(kind=kind)\n        return np.mean(np.linalg.norm(mesh.vertices, axis=1), axis=0)\n\n    def voigt_rotation_matrix_6x6(self, rotation_matrix):\n        \"\"\"\n        Construct the 6x6 rotation matrix for transforming Voigt notation tensors.\n        Follows the standard approach for 4th-order tensor rotation in Voigt notation.\n\n        Args:\n            rotation_matrix (np.ndarray): 3x3 rotation matrix R\n\n        Returns:\n            np.ndarray: 6x6 rotation matrix for Voigt notation\n        \"\"\"\n        R = rotation_matrix\n\n        # Voigt index mapping\n        voigt_to_tensor = [(0, 0), (1, 1), (2, 2), (1, 2), (0, 2), (0, 1)]\n        T = np.zeros((6, 6))\n\n        for i in range(6):\n            for j in range(6):\n                p, q = voigt_to_tensor[i]  # row indices\n                r, s = voigt_to_tensor[j]  # column indices\n\n                # Apply the 4th-order tensor transformation rule:\n                # T_ij = sum over all valid combinations of R_pr * R_qs * R_rt * R_su\n                # where the indices match the tensor transformation pattern\n\n                # For symmetric tensors in Voigt notation, we use:\n                if i &lt; 3:  # diagonal terms (11, 22, 33)\n                    if j &lt; 3:  # diagonal terms\n                        T[i, j] = R[p, r] * R[q, s]\n                    else:  # off-diagonal terms (need factor of 2)\n                        T[i, j] = 2 * R[p, r] * R[q, s]\n                else:  # off-diagonal terms (23, 13, 12)\n                    if j &lt; 3:  # diagonal terms\n                        T[i, j] = R[p, r] * R[q, s]\n                    else:  # off-diagonal terms\n                        T[i, j] = R[p, r] * R[q, s] + R[p, s] * R[q, r]\n\n        return T\n\n    def rotate_voigt_tensor(self, rotation_matrix):\n        \"\"\"\n        Rotate this elastic tensor using a 3x3 rotation matrix.\n        Uses a direct 6x6 transformation matrix construction.\n\n        Args:\n            rotation_matrix (np.ndarray): 3x3 rotation matrix R\n\n        Returns:\n            np.ndarray: Rotated 6x6 elastic tensor in Voigt notation\n        \"\"\"\n        T = self.voigt_rotation_matrix_6x6(rotation_matrix)\n        rotated_tensor = T @ self.c_voigt @ T.T\n        return rotated_tensor\n\n    def reoriented_into_standard_frame(self, vectors):\n        \"\"\"\n        Re-orient this elastic tensor from the provided cartesian frame\n        into a natural standard crystallographic frame for the crystal axes.\n\n        The standard frame uses the conventional crystallographic orientation:\n        - a along x-axis\n        - b in xy-plane\n        - c positioned to satisfy the lattice angles\n\n        Args:\n            vectors (np.ndarray): 3x3 matrix of lattice vectors (row major)\n                from the original coordinate system\n\n        Returns:\n            ElasticTensor: New elastic tensor in the standard frame\n        \"\"\"\n        from chmpy.crystal.unit_cell import UnitCell\n        from chmpy.util.num import kabsch_rotation_matrix\n\n        # Create unit cell from the provided vectors\n        original_uc = UnitCell(vectors)\n\n        # Create standard orientation unit cell with same lattice parameters\n        # This uses the standard crystallographic convention in chmpy\n        standard_uc = UnitCell(np.eye(3))  # temporary\n        standard_uc.set_lengths_and_angles(\n            [original_uc.a, original_uc.b, original_uc.c],\n            [original_uc.alpha, original_uc.beta, original_uc.gamma],\n        )\n\n        rotation_matrix = kabsch_rotation_matrix(original_uc.direct, standard_uc.direct)\n\n        rotated_c_voigt = self.rotate_voigt_tensor(rotation_matrix)\n        return ElasticTensor(rotated_c_voigt)\n\n    def __repr__(self):\n        s = np.array2string(\n            self.c_voigt, precision=4, suppress_small=True, separator=\"  \"\n        )\n        s = s.replace(\"[\", \" \")\n        s = s.replace(\"]\", \" \")\n        return f\"&lt;ElasticTensor:\\n{s}&gt;\"\n</code></pre>"},{"location":"reference/chmpy/ext/elastic_tensor/#chmpy.ext.elastic_tensor.ElasticTensor.from_string","title":"<code>from_string(s)</code>  <code>classmethod</code>","text":"<p>Initialize the elastic tensor from a string</p> Source code in <code>chmpy/ext/elastic_tensor.py</code> <pre><code>@classmethod\ndef from_string(cls, s):\n    \"\"\"Initialize the elastic tensor from a string\"\"\"\n    if not s:\n        raise ValueError(\"no matrix was provided\")\n\n    if isinstance(s, str):\n        # Remove braces and pipes\n        s = s.replace(\"|\", \" \").replace(\"(\", \" \").replace(\")\", \" \")\n\n        # Remove empty lines\n        lines = [line for line in s.split(\"\\n\") if line.strip()]\n        if len(lines) != 6:\n            raise ValueError(\"should have six rows\")\n\n        # Convert to float\n        try:\n            mat = [[float(x) for x in line.split()] for line in lines]\n        except ValueError as e:\n            raise ValueError(f\"not all entries are numbers: {e}\") from e\n    return cls(mat)\n</code></pre>"},{"location":"reference/chmpy/ext/elastic_tensor/#chmpy.ext.elastic_tensor.ElasticTensor.reoriented_into_standard_frame","title":"<code>reoriented_into_standard_frame(vectors)</code>","text":"<p>Re-orient this elastic tensor from the provided cartesian frame into a natural standard crystallographic frame for the crystal axes.</p> <p>The standard frame uses the conventional crystallographic orientation: - a along x-axis - b in xy-plane - c positioned to satisfy the lattice angles</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>ndarray</code> <p>3x3 matrix of lattice vectors (row major) from the original coordinate system</p> required <p>Returns:</p> Name Type Description <code>ElasticTensor</code> <p>New elastic tensor in the standard frame</p> Source code in <code>chmpy/ext/elastic_tensor.py</code> <pre><code>def reoriented_into_standard_frame(self, vectors):\n    \"\"\"\n    Re-orient this elastic tensor from the provided cartesian frame\n    into a natural standard crystallographic frame for the crystal axes.\n\n    The standard frame uses the conventional crystallographic orientation:\n    - a along x-axis\n    - b in xy-plane\n    - c positioned to satisfy the lattice angles\n\n    Args:\n        vectors (np.ndarray): 3x3 matrix of lattice vectors (row major)\n            from the original coordinate system\n\n    Returns:\n        ElasticTensor: New elastic tensor in the standard frame\n    \"\"\"\n    from chmpy.crystal.unit_cell import UnitCell\n    from chmpy.util.num import kabsch_rotation_matrix\n\n    # Create unit cell from the provided vectors\n    original_uc = UnitCell(vectors)\n\n    # Create standard orientation unit cell with same lattice parameters\n    # This uses the standard crystallographic convention in chmpy\n    standard_uc = UnitCell(np.eye(3))  # temporary\n    standard_uc.set_lengths_and_angles(\n        [original_uc.a, original_uc.b, original_uc.c],\n        [original_uc.alpha, original_uc.beta, original_uc.gamma],\n    )\n\n    rotation_matrix = kabsch_rotation_matrix(original_uc.direct, standard_uc.direct)\n\n    rotated_c_voigt = self.rotate_voigt_tensor(rotation_matrix)\n    return ElasticTensor(rotated_c_voigt)\n</code></pre>"},{"location":"reference/chmpy/ext/elastic_tensor/#chmpy.ext.elastic_tensor.ElasticTensor.rotate_voigt_tensor","title":"<code>rotate_voigt_tensor(rotation_matrix)</code>","text":"<p>Rotate this elastic tensor using a 3x3 rotation matrix. Uses a direct 6x6 transformation matrix construction.</p> <p>Parameters:</p> Name Type Description Default <code>rotation_matrix</code> <code>ndarray</code> <p>3x3 rotation matrix R</p> required <p>Returns:</p> Type Description <p>np.ndarray: Rotated 6x6 elastic tensor in Voigt notation</p> Source code in <code>chmpy/ext/elastic_tensor.py</code> <pre><code>def rotate_voigt_tensor(self, rotation_matrix):\n    \"\"\"\n    Rotate this elastic tensor using a 3x3 rotation matrix.\n    Uses a direct 6x6 transformation matrix construction.\n\n    Args:\n        rotation_matrix (np.ndarray): 3x3 rotation matrix R\n\n    Returns:\n        np.ndarray: Rotated 6x6 elastic tensor in Voigt notation\n    \"\"\"\n    T = self.voigt_rotation_matrix_6x6(rotation_matrix)\n    rotated_tensor = T @ self.c_voigt @ T.T\n    return rotated_tensor\n</code></pre>"},{"location":"reference/chmpy/ext/elastic_tensor/#chmpy.ext.elastic_tensor.ElasticTensor.voigt_rotation_matrix_6x6","title":"<code>voigt_rotation_matrix_6x6(rotation_matrix)</code>","text":"<p>Construct the 6x6 rotation matrix for transforming Voigt notation tensors. Follows the standard approach for 4th-order tensor rotation in Voigt notation.</p> <p>Parameters:</p> Name Type Description Default <code>rotation_matrix</code> <code>ndarray</code> <p>3x3 rotation matrix R</p> required <p>Returns:</p> Type Description <p>np.ndarray: 6x6 rotation matrix for Voigt notation</p> Source code in <code>chmpy/ext/elastic_tensor.py</code> <pre><code>def voigt_rotation_matrix_6x6(self, rotation_matrix):\n    \"\"\"\n    Construct the 6x6 rotation matrix for transforming Voigt notation tensors.\n    Follows the standard approach for 4th-order tensor rotation in Voigt notation.\n\n    Args:\n        rotation_matrix (np.ndarray): 3x3 rotation matrix R\n\n    Returns:\n        np.ndarray: 6x6 rotation matrix for Voigt notation\n    \"\"\"\n    R = rotation_matrix\n\n    # Voigt index mapping\n    voigt_to_tensor = [(0, 0), (1, 1), (2, 2), (1, 2), (0, 2), (0, 1)]\n    T = np.zeros((6, 6))\n\n    for i in range(6):\n        for j in range(6):\n            p, q = voigt_to_tensor[i]  # row indices\n            r, s = voigt_to_tensor[j]  # column indices\n\n            # Apply the 4th-order tensor transformation rule:\n            # T_ij = sum over all valid combinations of R_pr * R_qs * R_rt * R_su\n            # where the indices match the tensor transformation pattern\n\n            # For symmetric tensors in Voigt notation, we use:\n            if i &lt; 3:  # diagonal terms (11, 22, 33)\n                if j &lt; 3:  # diagonal terms\n                    T[i, j] = R[p, r] * R[q, s]\n                else:  # off-diagonal terms (need factor of 2)\n                    T[i, j] = 2 * R[p, r] * R[q, s]\n            else:  # off-diagonal terms (23, 13, 12)\n                if j &lt; 3:  # diagonal terms\n                    T[i, j] = R[p, r] * R[q, s]\n                else:  # off-diagonal terms\n                    T[i, j] = R[p, r] * R[q, s] + R[p, s] * R[q, r]\n\n    return T\n</code></pre>"},{"location":"reference/chmpy/ext/excitations/","title":"excitations","text":""},{"location":"reference/chmpy/ext/excitations/#chmpy.ext.excitations.plot_spectra","title":"<code>plot_spectra(energies, osc, bounds=(1, 1500), bins=1000, std=12398.4, kind='gaussian', gamma=12.5, label=None, **kwargs)</code>","text":"<p>Plot the (UV-Vis) spectra.</p> <p>Parameters:</p> Name Type Description Default <code>energies</code> <code>ndarray</code> <p>excitation energies/bands in nm.</p> required <code>osc</code> <code>ndarray</code> <p>oscillator strengths (dimensionless).</p> required Source code in <code>chmpy/ext/excitations.py</code> <pre><code>def plot_spectra(\n    energies,\n    osc,\n    bounds=(1, 1500),\n    bins=1000,\n    std=12398.4,\n    kind=\"gaussian\",\n    gamma=12.5,\n    label=None,\n    **kwargs,\n):\n    \"\"\"Plot the (UV-Vis) spectra.\n\n    Args:\n        energies (np.ndarray): excitation energies/bands in nm.\n        osc (np.ndarray): oscillator strengths (dimensionless).\n\n    \"\"\"\n    import matplotlib.pyplot as plt\n\n    x = np.linspace(bounds[0], bounds[1], bins)\n    total = 0\n    for e, f in zip(energies, osc, strict=False):\n        if kind == \"gaussian\":\n            peak = add_gaussian_curve_contribution(x, e, f, std)\n        else:\n            peak = add_lorentz_curve_contribution(x, e, f, std, gamma)\n        total += peak\n\n    ax = plt.gca()\n    total = total / np.max(total)\n    ax.plot(x, total, label=label, **kwargs)\n    ax.set_xlabel(r\"$\\lambda$ (nm)\")\n    ax.set_ylim(0, 1.1)\n    ax.set_ylabel(r\"Intensity\")\n    return ax\n</code></pre>"},{"location":"reference/chmpy/ext/solvation_parameters/","title":"solvation_parameters","text":""},{"location":"reference/chmpy/ext/traj/","title":"traj","text":""},{"location":"reference/chmpy/ext/vasp/","title":"vasp","text":""},{"location":"reference/chmpy/ff/params/","title":"params","text":"<p>Simple UFF parameter assignment for chmpy Crystal and Molecule objects using EEQ coordination numbers.</p>"},{"location":"reference/chmpy/ff/params/#chmpy.ff.params.assign_fit_lj_type","title":"<code>assign_fit_lj_type(atomic_num, coord_num, bonded_to=None)</code>","text":"<p>Assign fit_lj atom type based on atomic number and coordination.</p> <p>Simplified version that uses coordination numbers when full connectivity is not available.</p> <p>Parameters:</p> Name Type Description Default <code>atomic_num</code> <p>Atomic number</p> required <code>coord_num</code> <p>EEQ coordination number (float)</p> required <code>bonded_to</code> <p>Optional list of atomic numbers this atom is bonded to</p> <code>None</code> <p>Returns:</p> Type Description <p>fit_lj atom type string</p> Source code in <code>chmpy/ff/params.py</code> <pre><code>def assign_fit_lj_type(atomic_num, coord_num, bonded_to=None):\n    \"\"\"\n    Assign fit_lj atom type based on atomic number and coordination.\n\n    Simplified version that uses coordination numbers when full connectivity\n    is not available.\n\n    Args:\n        atomic_num: Atomic number\n        coord_num: EEQ coordination number (float)\n        bonded_to: Optional list of atomic numbers this atom is bonded to\n\n    Returns:\n        fit_lj atom type string\n    \"\"\"\n\n    if atomic_num == 1:  # Hydrogen\n        # H_F1 for C-H, H_F2 for O-H and N-H\n        # Without bonding info, use coordination as proxy\n        # Lower coordination typically means polar H (O-H, N-H)\n        if coord_num &lt; 0.8:\n            return \"H_F2\"\n        else:\n            return \"H_F1\"\n\n    elif atomic_num == 6:  # Carbon\n        return \"C_F1\"\n\n    elif atomic_num == 7:  # Nitrogen\n        return \"N_F1\"\n\n    elif atomic_num == 8:  # Oxygen\n        return \"O_F1\"\n\n    elif atomic_num == 9:  # Fluorine\n        return \"F_F1\"\n\n    elif atomic_num == 16:  # Sulfur\n        return \"S_F1\"\n\n    elif atomic_num == 17:  # Chlorine\n        return \"ClF1\"\n\n    else:\n        # For unsupported elements, return None\n        return None\n</code></pre>"},{"location":"reference/chmpy/ff/params/#chmpy.ff.params.assign_fit_lj_type_from_connectivity","title":"<code>assign_fit_lj_type_from_connectivity(atomic_num, neighbours_list, all_atomic_numbers)</code>","text":"<p>Assign fit_lj atom type based on connectivity, following neighcrys FIT potential rules.</p> <p>This follows the exact logic from neighcrys_axis.py for FIT potential labeling.</p> <p>Parameters:</p> Name Type Description Default <code>atomic_num</code> <p>Atomic number of the atom to label</p> required <code>neighbours_list</code> <p>List of neighbor indices for each atom</p> required <code>all_atomic_numbers</code> <p>Array of atomic numbers for all atoms</p> required <p>Returns:</p> Type Description <p>fit_lj atom type string</p> Source code in <code>chmpy/ff/params.py</code> <pre><code>def assign_fit_lj_type_from_connectivity(\n    atomic_num, neighbours_list, all_atomic_numbers\n):\n    \"\"\"\n    Assign fit_lj atom type based on connectivity, following neighcrys FIT potential rules.\n\n    This follows the exact logic from neighcrys_axis.py for FIT potential labeling.\n\n    Args:\n        atomic_num: Atomic number of the atom to label\n        neighbours_list: List of neighbor indices for each atom\n        all_atomic_numbers: Array of atomic numbers for all atoms\n\n    Returns:\n        fit_lj atom type string\n    \"\"\"\n\n    # Note: This requires full connectivity information, not just coordination number\n    # For now, implementing a simplified version that can work with coordination numbers\n    # A full implementation would need the molecule's bond connectivity\n\n    if atomic_num == 1:  # Hydrogen\n        # Without full connectivity, default to H_F1 for C-H and H_F2 for others\n        # This is a simplification - full implementation would check what H is bonded to\n        return \"H_F1\"  # Most common case\n\n    elif atomic_num == 6:  # Carbon\n        # All carbons map to C_F1 in FIT potential\n        return \"C_F1\"\n\n    elif atomic_num == 7:  # Nitrogen\n        # All nitrogens map to N_F1 in FIT potential\n        return \"N_F1\"\n\n    elif atomic_num == 8:  # Oxygen\n        # All oxygens map to O_F1 in FIT potential (except water which is O_Wa)\n        return \"O_F1\"\n\n    elif atomic_num == 9:  # Fluorine\n        return \"F_F1\"\n\n    elif atomic_num == 16:  # Sulfur\n        return \"S_F1\"\n\n    elif atomic_num == 17:  # Chlorine\n        return \"ClF1\"\n\n    else:\n        # For unsupported elements, return None\n        return None\n</code></pre>"},{"location":"reference/chmpy/ff/params/#chmpy.ff.params.assign_uff_type_from_coordination","title":"<code>assign_uff_type_from_coordination(atomic_num, coord_num)</code>","text":"<p>Assign UFF atom type based on atomic number and EEQ coordination number.</p> <p>Parameters:</p> Name Type Description Default <code>atomic_num</code> <p>Atomic number</p> required <code>coord_num</code> <p>EEQ coordination number (float)</p> required <p>Returns:</p> Type Description <p>UFF atom type string</p> Source code in <code>chmpy/ff/params.py</code> <pre><code>def assign_uff_type_from_coordination(atomic_num, coord_num):\n    \"\"\"\n    Assign UFF atom type based on atomic number and EEQ coordination number.\n\n    Args:\n        atomic_num: Atomic number\n        coord_num: EEQ coordination number (float)\n\n    Returns:\n        UFF atom type string\n    \"\"\"\n\n    if atomic_num == 1:  # Hydrogen\n        return \"H_\"\n\n    elif atomic_num == 6:  # Carbon\n        if coord_num &gt; 3.5:\n            return \"C_3\"  # sp3 (tetrahedral)\n        elif coord_num &gt; 2.5:\n            return \"C_2\"  # sp2 (trigonal)\n        else:\n            return \"C_1\"  # sp (linear)\n\n    elif atomic_num == 7:  # Nitrogen\n        if coord_num &gt; 2.5:\n            return \"N_3\"  # pyramidal\n        elif coord_num &gt; 1.5:\n            return \"N_2\"  # trigonal\n        else:\n            return \"N_1\"  # linear\n\n    elif atomic_num == 8:  # Oxygen\n        if coord_num &gt; 1.5:\n            return \"O_3\"  # bent/tetrahedral\n        else:\n            return \"O_2\"  # linear (C=O)\n\n    elif atomic_num == 16:  # Sulfur\n        if coord_num &gt; 3.5:\n            return \"S_3+6\"\n        elif coord_num &gt; 2.5:\n            return \"S_3+4\"\n        else:\n            return \"S_3+2\"\n\n    elif atomic_num == 15:  # Phosphorus\n        if coord_num &gt; 3.5:\n            return \"P_3+5\"\n        else:\n            return \"P_3+3\"\n\n    # Common elements with fixed types\n    elif atomic_num == 9:\n        return \"F_\"\n    elif atomic_num == 17:\n        return \"Cl\"\n    elif atomic_num == 35:\n        return \"Br\"\n    elif atomic_num == 53:\n        return \"I_\"\n    elif atomic_num == 14:\n        return \"Si3\"\n    elif atomic_num == 5:\n        return \"B_2\"\n    elif atomic_num == 13:\n        return \"Al3\"\n\n    # Common metals\n    elif atomic_num == 12:\n        return \"Mg3+2\"\n    elif atomic_num == 20:\n        return \"Ca6+2\"\n    elif atomic_num == 30:\n        return \"Zn3+2\"\n    elif atomic_num == 26:\n        return \"Fe6+2\" if coord_num &gt; 4.5 else \"Fe3+2\"\n    elif atomic_num == 29:\n        return \"Cu3+1\"\n    elif atomic_num == 28:\n        return \"Ni4+2\"\n    elif atomic_num == 27:\n        return \"Co6+3\"\n    elif atomic_num == 25:\n        return \"Mn6+2\"\n    elif atomic_num == 24:\n        return \"Cr6+3\"\n    elif atomic_num == 22:\n        return \"Ti6+4\"\n    elif atomic_num == 23:\n        return \"V_3+5\"\n    elif atomic_num == 42:\n        return \"Mo6+6\"\n    elif atomic_num == 74:\n        return \"W_6+6\"\n\n    else:\n        # Generic fallback\n        from chmpy.core.element import Element\n\n        symbol = Element.from_atomic_number(atomic_num).symbol\n        return f\"{symbol}3+2\"\n</code></pre>"},{"location":"reference/chmpy/ff/params/#chmpy.ff.params.crystal_lj_params","title":"<code>crystal_lj_params(crystal, force_field='uff')</code>","text":"<p>Get Lennard-Jones parameters for Crystal object.</p> Source code in <code>chmpy/ff/params.py</code> <pre><code>def crystal_lj_params(crystal, force_field=\"uff\"):\n    \"\"\"Get Lennard-Jones parameters for Crystal object.\"\"\"\n    return get_lj_parameters(crystal, force_field)\n</code></pre>"},{"location":"reference/chmpy/ff/params/#chmpy.ff.params.crystal_uff_params","title":"<code>crystal_uff_params(crystal, force_field='uff')</code>","text":"<p>Deprecated: Use crystal_lj_params instead.</p> Source code in <code>chmpy/ff/params.py</code> <pre><code>def crystal_uff_params(crystal, force_field=\"uff\"):\n    \"\"\"Deprecated: Use crystal_lj_params instead.\"\"\"\n    return get_lj_parameters(crystal, force_field)\n</code></pre>"},{"location":"reference/chmpy/ff/params/#chmpy.ff.params.get_lj_parameters","title":"<code>get_lj_parameters(obj, force_field='uff')</code>","text":"<p>Get Lennard-Jones atom types and parameters for Crystal or Molecule object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <p>Crystal or Molecule object</p> required <code>force_field</code> <p>\"uff\", \"uff4mof\", or \"fit_lj\"</p> <code>'uff'</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(atom_types, parameters) atom_types: dict {atom_idx: atom_type} parameters: dict {atom_idx: {\"sigma\": float, \"epsilon\": float}}</p> Source code in <code>chmpy/ff/params.py</code> <pre><code>def get_lj_parameters(obj, force_field=\"uff\"):\n    \"\"\"\n    Get Lennard-Jones atom types and parameters for Crystal or Molecule object.\n\n    Args:\n        obj: Crystal or Molecule object\n        force_field: \"uff\", \"uff4mof\", or \"fit_lj\"\n\n    Returns:\n        tuple: (atom_types, parameters)\n            atom_types: dict {atom_idx: atom_type}\n            parameters: dict {atom_idx: {\"sigma\": float, \"epsilon\": float}}\n    \"\"\"\n\n    # Load parameter database\n    lj_params = load_lj_params()[force_field.lower()]\n\n    # Get atomic numbers and coordination numbers\n    if hasattr(obj, \"unit_cell_atoms\"):  # Crystal\n        uc_atoms = obj.unit_cell_atoms()\n        atomic_nums = uc_atoms[\"element\"]\n        coord_nums = obj.unit_cell_coordination_numbers()\n    elif hasattr(obj, \"atomic_numbers\"):  # Molecule\n        atomic_nums = obj.atomic_numbers\n        coord_nums = obj.coordination_numbers  # Property, not method\n    else:\n        raise ValueError(\"Object must be Crystal or Molecule\")\n\n    atom_types = {}\n    parameters = {}\n\n    for i, (atomic_num, coord_num) in enumerate(\n        zip(atomic_nums, coord_nums, strict=False)\n    ):\n        # Assign atom type based on force field and coordination\n        if force_field.lower() == \"fit_lj\":\n            atom_type = assign_fit_lj_type(atomic_num, coord_num)\n        else:\n            # UFF or UFF4MOF\n            atom_type = assign_uff_type_from_coordination(atomic_num, coord_num)\n\n        atom_types[i] = atom_type\n\n        # Get parameters\n        if atom_type and atom_type in lj_params:\n            sigma, epsilon = lj_params[atom_type]\n            parameters[i] = {\"sigma\": sigma, \"epsilon\": epsilon}\n        else:\n            # Fallback parameters or None for unsupported atoms\n            if atom_type is None:\n                print(f\"Warning: No fit_lj type for atomic number {atomic_num}\")\n                parameters[i] = None\n            else:\n                parameters[i] = {\"sigma\": 3.0, \"epsilon\": 0.1}\n                print(f\"Warning: No parameters found for {atom_type}, using defaults\")\n\n    return atom_types, parameters\n</code></pre>"},{"location":"reference/chmpy/ff/params/#chmpy.ff.params.get_uff_parameters","title":"<code>get_uff_parameters(obj, force_field='uff')</code>","text":"<p>Deprecated: Use get_lj_parameters instead.</p> <p>Get UFF atom types and parameters for Crystal or Molecule object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <p>Crystal or Molecule object</p> required <code>force_field</code> <p>\"uff\" or \"uff4mof\"</p> <code>'uff'</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>(atom_types, parameters) atom_types: dict {atom_idx: uff_type} parameters: dict {atom_idx: {\"sigma\": float, \"epsilon\": float}}</p> Source code in <code>chmpy/ff/params.py</code> <pre><code>def get_uff_parameters(obj, force_field=\"uff\"):\n    \"\"\"\n    Deprecated: Use get_lj_parameters instead.\n\n    Get UFF atom types and parameters for Crystal or Molecule object.\n\n    Args:\n        obj: Crystal or Molecule object\n        force_field: \"uff\" or \"uff4mof\"\n\n    Returns:\n        tuple: (atom_types, parameters)\n            atom_types: dict {atom_idx: uff_type}\n            parameters: dict {atom_idx: {\"sigma\": float, \"epsilon\": float}}\n    \"\"\"\n    return get_lj_parameters(obj, force_field)\n</code></pre>"},{"location":"reference/chmpy/ff/params/#chmpy.ff.params.load_lj_params","title":"<code>load_lj_params()</code>","text":"<p>Load Lennard-Jones parameters from JSON file.</p> Source code in <code>chmpy/ff/params.py</code> <pre><code>def load_lj_params():\n    \"\"\"Load Lennard-Jones parameters from JSON file.\"\"\"\n    params_file = Path(__file__).parent / \"lj_params.json\"\n    with open(params_file) as f:\n        return json.load(f)\n</code></pre>"},{"location":"reference/chmpy/ff/params/#chmpy.ff.params.molecule_lj_params","title":"<code>molecule_lj_params(molecule, force_field='uff')</code>","text":"<p>Get Lennard-Jones parameters for Molecule object.</p> Source code in <code>chmpy/ff/params.py</code> <pre><code>def molecule_lj_params(molecule, force_field=\"uff\"):\n    \"\"\"Get Lennard-Jones parameters for Molecule object.\"\"\"\n    return get_lj_parameters(molecule, force_field)\n</code></pre>"},{"location":"reference/chmpy/ff/params/#chmpy.ff.params.molecule_uff_params","title":"<code>molecule_uff_params(molecule, force_field='uff')</code>","text":"<p>Deprecated: Use molecule_lj_params instead.</p> Source code in <code>chmpy/ff/params.py</code> <pre><code>def molecule_uff_params(molecule, force_field=\"uff\"):\n    \"\"\"Deprecated: Use molecule_lj_params instead.\"\"\"\n    return get_lj_parameters(molecule, force_field)\n</code></pre>"},{"location":"reference/chmpy/ff/params/#chmpy.ff.params.print_lj_summary","title":"<code>print_lj_summary(obj, force_field='uff')</code>","text":"<p>Print a summary of Lennard-Jones atom types and parameters.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <p>Crystal or Molecule object</p> required <code>force_field</code> <p>\"uff\", \"uff4mof\", or \"fit_lj\"</p> <code>'uff'</code> Source code in <code>chmpy/ff/params.py</code> <pre><code>def print_lj_summary(obj, force_field=\"uff\"):\n    \"\"\"\n    Print a summary of Lennard-Jones atom types and parameters.\n\n    Args:\n        obj: Crystal or Molecule object\n        force_field: \"uff\", \"uff4mof\", or \"fit_lj\"\n    \"\"\"\n\n    atom_types, parameters = get_lj_parameters(obj, force_field)\n\n    # Get atomic info\n    if hasattr(obj, \"unit_cell_atoms\"):  # Crystal\n        uc_atoms = obj.unit_cell_atoms()\n        atomic_nums = uc_atoms[\"element\"]\n        coord_nums = obj.unit_cell_coordination_numbers()  # Method for Crystal\n        name = getattr(obj, \"titl\", \"Crystal\")\n    elif hasattr(obj, \"atomic_numbers\"):  # Molecule\n        atomic_nums = obj.atomic_numbers\n        coord_nums = obj.coordination_numbers  # Property for Molecule\n        name = getattr(obj, \"molecular_formula\", \"Molecule\")\n\n    print(f\"\\nLJ Parameters for {name}\")\n    print(f\"Force Field: {force_field.upper()}\")\n    print(\"=\" * 70)\n    print(\n        f\"{'Atom':&gt;4} {'Element':&gt;7} {'Coord':&gt;6} {'Type':&gt;10} {'\u03c3 (\u00c5)':&gt;8} {'\u03b5 (kcal/mol)':&gt;12}\"\n    )\n    print(\"-\" * 70)\n\n    for i, (atomic_num, coord_num) in enumerate(\n        zip(atomic_nums, coord_nums, strict=False)\n    ):\n        atom_type = atom_types[i]\n        params = parameters[i]\n\n        if atom_type and params:\n            print(\n                f\"{i + 1:4d} {atomic_num:7d} {coord_num:6.2f} {atom_type:&gt;10s} {params['sigma']:8.3f} {params['epsilon']:12.6f}\"\n            )\n        else:\n            print(\n                f\"{i + 1:4d} {atomic_num:7d} {coord_num:6.2f} {'N/A':&gt;10s} {'N/A':&gt;8s} {'N/A':&gt;12s}\"\n            )\n\n    # Summary\n    unique_types = {t for t in atom_types.values() if t is not None}\n    print(f\"\\nUnique types: {len(unique_types)}\")\n    print(f\"Types found: {sorted(unique_types)}\")\n</code></pre>"},{"location":"reference/chmpy/ff/params/#chmpy.ff.params.print_uff_summary","title":"<code>print_uff_summary(obj, force_field='uff')</code>","text":"<p>Deprecated: Use print_lj_summary instead.</p> Source code in <code>chmpy/ff/params.py</code> <pre><code>def print_uff_summary(obj, force_field=\"uff\"):\n    \"\"\"Deprecated: Use print_lj_summary instead.\"\"\"\n    return print_lj_summary(obj, force_field)\n</code></pre>"},{"location":"reference/chmpy/fmt/ascii/","title":"ascii","text":""},{"location":"reference/chmpy/fmt/ase/","title":"ase","text":""},{"location":"reference/chmpy/fmt/cif/","title":"cif","text":""},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif","title":"<code>Cif</code>","text":"<p>Class to represent data extracted from a CIF standard file format.</p>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif--parameters","title":"Parameters","text":"<p>cif_data : dict     dictionary of CIF keys and values</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>class Cif:\n    \"\"\"Class to represent data extracted from a CIF\n    standard file format.\n\n    Parameters\n    ----------\n    cif_data : dict\n        dictionary of CIF keys and values\n    \"\"\"\n\n    def __init__(self, cif_data):\n        self.data = cif_data\n        self.line_dispatch = {\n            \"#\": self.parse_comment_line,\n            \"loop_\": self.parse_loop_block,\n        }\n        self.current_data_block_name = \"unknown\"\n        self.content_lines = []\n\n    def is_comment_line(self, line):\n        \"check if the line is a comment i.e. starts with '#'\"\n        return line.strip().startswith(\"#\")\n\n    def is_data_name_line(self, line):\n        \"check if the line is a data_name i.e. starts with a single '_'\"\n        return line.strip().startswith(\"_\")\n\n    def is_empty_line(self, line):\n        \"check if the line is empty/blank\"\n        if line and line.strip():\n            return False\n        return True\n\n    def is_data_line(self, line):\n        \"check if the line contains a value for the currentt key\"\n        if self.is_empty_line(line):\n            return False\n        if self.is_comment_line(line):\n            return False\n        if self.is_data_name_line(line):\n            return False\n        if line.split()[0] in self.line_dispatch:\n            return False\n        return True\n\n    def parse_quoted_block(self, delimiter=\";\"):\n        \"parse an entire quoted block, delimited by delimiter\"\n        LOG.debug(\"Parsing quoted block at line %d\", self.line_index)\n        self.content_lines[self.line_index].strip()\n        i = self.line_index + 1\n        j = i\n        n = 1\n        while \";\" not in self.content_lines[j]:\n            j += 1\n            n += 1\n            if j &gt;= len(self.content_lines) - 1:\n                break\n        else:\n            section = \" \".join(x.strip() for x in self.content_lines[i - 1 : j + 1])\n            self.line_index += n\n            return parse_quote(section)\n        raise ValueError(f\"Unmatch quotation on line {self.line_index + 1}\")\n\n    def parse_data_name(self):\n        \"parse a single data name i.e key for the cif_data dictionary\"\n        tokens = self.content_lines[self.line_index].strip()[1:].split()\n        k = tokens[0]\n        v = None\n        if len(tokens) == 1:\n            next_line = self.content_lines[self.line_index + 1]\n            while next_line.strip().startswith(\"#\"):\n                self.line_index += 1\n                next_line = self.content_lines[self.line_index + 1]\n\n            if \";\" in next_line:\n                self.line_index += 1\n                v = self.parse_quoted_block().strip()\n            else:\n                v = parse_value(next_line)\n                self.line_index += 1\n        else:\n            v = \" \".join(tokens[1:])\n        if v is None:\n            raise ValueError(\n                f\"Error parsing CIF data_name on line {self.line_index}, context = {k}\"\n            )\n        self.current_data_block[k] = parse_value(v)\n        self.line_index += 1\n        LOG.debug(\"Parsed data name: %s = %s\", k, v)\n\n    def parse_loop_block(self):\n        \"parse values contained in a _loop block\"\n        LOG.debug(\"Parsing loop block\")\n        self.line_index += 1\n        line = self.content_lines[self.line_index]\n        keys = []\n        while line.strip().startswith(\"_\"):\n            keys.append(line.strip()[1:])\n            self.line_index += 1\n            line = self.content_lines[self.line_index]\n\n        line = self.content_lines[self.line_index]\n        values = []\n        while self.is_data_line(line):\n            LOG.debug(\"Parsing data line: %s\", line)\n            values.append(line.strip())\n            self.line_index += 1\n            if self.line_index &gt;= len(self.content_lines):\n                LOG.debug(\"Reached end of file parsing loop block\")\n                break\n            line = self.content_lines[self.line_index]\n        for k in keys:\n            self.current_data_block[k] = []\n\n        for value in values:\n            vs = re.findall(VALUES_REGEX, value.strip())\n            for k, v in zip(keys, vs, strict=False):\n                self.current_data_block[k].append(parse_value(v))\n        LOG.debug(\"Parsed loop block\")\n\n    def parse_comment_line(self):\n        \"ignore comment lines\"\n        self.line_index += 1\n\n    def parse_data_block_name(self):\n        \"parse a data block name\"\n        LOG.debug(\"Parsing data block name at line %d\", self.line_index)\n        line = self.content_lines[self.line_index]\n        self.current_data_block_name = line[5:].strip()\n        self.line_index += 1\n        LOG.debug(\"Parsed data block name: %s\", self.current_data_block_name)\n\n    def parse(self, ignore_uncertainty=True):\n        \"parse the entire CIF contents\"\n        if not ignore_uncertainty:\n            raise NotImplementedError(\n                \"Storing uncertainty information has not been implemented\"\n            )\n        self.line_index = 0\n        line_count = len(self.content_lines)\n        while self.line_index &lt; line_count:\n            line = self.content_lines[self.line_index].strip()\n            if line:\n                token = line.split()[0]\n                if token in self.line_dispatch:\n                    self.line_dispatch[token]()\n                elif token.startswith(\"_\"):\n                    self.parse_data_name()\n                elif token.startswith(\"data_\"):\n                    self.parse_data_block_name()\n                else:\n                    LOG.debug(\"Skipping unknown line: %s\", line)\n                    self.line_index += 1\n            else:\n                self.line_index += 1\n        self.line_index = 0\n        return self.data\n\n    @property\n    def current_data_block(self):\n        \"return the current data block, adding the key if necessary\"\n        if self.current_data_block_name not in self.data:\n            self.data[self.current_data_block_name] = {}\n        return self.data[self.current_data_block_name]\n\n    @classmethod\n    def from_file(cls, filename):\n        \"initialize a :obj:`Cif` from a file path\"\n        return cls.from_string(Path(filename).read_text())\n\n    @classmethod\n    def from_string(cls, contents):\n        \"initialize a :obj:`Cif` from string contents\"\n        c = cls({})\n        c.content_lines = contents.split(\"\\n\")\n        c.parse()\n        return c\n\n    def to_string(self):\n        \"represent the data in this :obj`Cif` textually in the CIF format\"\n        lines = []\n        for data_block_name, data_block_data in self.data.items():\n            lines.append(f\"data_{data_block_name}\")\n            vector_data_names = []\n            for data_name, data_value in data_block_data.items():\n                if is_scalar(data_value):\n                    quote = \"\"\n                    if needs_quote(data_value):\n                        quote = \"'\"\n                    lines.append(f\"_{data_name} {quote}{data_value}{quote}\")\n                else:\n                    vector_data_names.append(data_name)\n            from itertools import groupby\n\n            for _name_section, names_top in groupby(\n                vector_data_names, key=lambda x: x.split(\"_\")[0]\n            ):\n                for _section, names in groupby(\n                    names_top, key=lambda x: len(data_block_data[x])\n                ):\n                    lines.append(\"loop_\")\n                    loop_values = []\n                    for name in names:\n                        lines.append(f\"_{name}\")\n                        loop_values.append(data_block_data[name])\n                    for row in zip(*loop_values, strict=False):\n                        lines.append(\" \".join(format_field(x) for x in row))\n\n        lines.append(\"#END\")\n        return \"\\n\".join(lines)\n\n    def to_file(self, filename):\n        \"write this :obj:`Cif` to file\"\n        Path(filename).write_text(self.to_string())\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif.current_data_block","title":"<code>current_data_block</code>  <code>property</code>","text":"<p>return the current data block, adding the key if necessary</p>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif.from_file","title":"<code>from_file(filename)</code>  <code>classmethod</code>","text":"<p>initialize a :obj:<code>Cif</code> from a file path</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>@classmethod\ndef from_file(cls, filename):\n    \"initialize a :obj:`Cif` from a file path\"\n    return cls.from_string(Path(filename).read_text())\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif.from_string","title":"<code>from_string(contents)</code>  <code>classmethod</code>","text":"<p>initialize a :obj:<code>Cif</code> from string contents</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>@classmethod\ndef from_string(cls, contents):\n    \"initialize a :obj:`Cif` from string contents\"\n    c = cls({})\n    c.content_lines = contents.split(\"\\n\")\n    c.parse()\n    return c\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif.is_comment_line","title":"<code>is_comment_line(line)</code>","text":"<p>check if the line is a comment i.e. starts with '#'</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def is_comment_line(self, line):\n    \"check if the line is a comment i.e. starts with '#'\"\n    return line.strip().startswith(\"#\")\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif.is_data_line","title":"<code>is_data_line(line)</code>","text":"<p>check if the line contains a value for the currentt key</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def is_data_line(self, line):\n    \"check if the line contains a value for the currentt key\"\n    if self.is_empty_line(line):\n        return False\n    if self.is_comment_line(line):\n        return False\n    if self.is_data_name_line(line):\n        return False\n    if line.split()[0] in self.line_dispatch:\n        return False\n    return True\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif.is_data_name_line","title":"<code>is_data_name_line(line)</code>","text":"<p>check if the line is a data_name i.e. starts with a single '_'</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def is_data_name_line(self, line):\n    \"check if the line is a data_name i.e. starts with a single '_'\"\n    return line.strip().startswith(\"_\")\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif.is_empty_line","title":"<code>is_empty_line(line)</code>","text":"<p>check if the line is empty/blank</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def is_empty_line(self, line):\n    \"check if the line is empty/blank\"\n    if line and line.strip():\n        return False\n    return True\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif.parse","title":"<code>parse(ignore_uncertainty=True)</code>","text":"<p>parse the entire CIF contents</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def parse(self, ignore_uncertainty=True):\n    \"parse the entire CIF contents\"\n    if not ignore_uncertainty:\n        raise NotImplementedError(\n            \"Storing uncertainty information has not been implemented\"\n        )\n    self.line_index = 0\n    line_count = len(self.content_lines)\n    while self.line_index &lt; line_count:\n        line = self.content_lines[self.line_index].strip()\n        if line:\n            token = line.split()[0]\n            if token in self.line_dispatch:\n                self.line_dispatch[token]()\n            elif token.startswith(\"_\"):\n                self.parse_data_name()\n            elif token.startswith(\"data_\"):\n                self.parse_data_block_name()\n            else:\n                LOG.debug(\"Skipping unknown line: %s\", line)\n                self.line_index += 1\n        else:\n            self.line_index += 1\n    self.line_index = 0\n    return self.data\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif.parse_comment_line","title":"<code>parse_comment_line()</code>","text":"<p>ignore comment lines</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def parse_comment_line(self):\n    \"ignore comment lines\"\n    self.line_index += 1\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif.parse_data_block_name","title":"<code>parse_data_block_name()</code>","text":"<p>parse a data block name</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def parse_data_block_name(self):\n    \"parse a data block name\"\n    LOG.debug(\"Parsing data block name at line %d\", self.line_index)\n    line = self.content_lines[self.line_index]\n    self.current_data_block_name = line[5:].strip()\n    self.line_index += 1\n    LOG.debug(\"Parsed data block name: %s\", self.current_data_block_name)\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif.parse_data_name","title":"<code>parse_data_name()</code>","text":"<p>parse a single data name i.e key for the cif_data dictionary</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def parse_data_name(self):\n    \"parse a single data name i.e key for the cif_data dictionary\"\n    tokens = self.content_lines[self.line_index].strip()[1:].split()\n    k = tokens[0]\n    v = None\n    if len(tokens) == 1:\n        next_line = self.content_lines[self.line_index + 1]\n        while next_line.strip().startswith(\"#\"):\n            self.line_index += 1\n            next_line = self.content_lines[self.line_index + 1]\n\n        if \";\" in next_line:\n            self.line_index += 1\n            v = self.parse_quoted_block().strip()\n        else:\n            v = parse_value(next_line)\n            self.line_index += 1\n    else:\n        v = \" \".join(tokens[1:])\n    if v is None:\n        raise ValueError(\n            f\"Error parsing CIF data_name on line {self.line_index}, context = {k}\"\n        )\n    self.current_data_block[k] = parse_value(v)\n    self.line_index += 1\n    LOG.debug(\"Parsed data name: %s = %s\", k, v)\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif.parse_loop_block","title":"<code>parse_loop_block()</code>","text":"<p>parse values contained in a _loop block</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def parse_loop_block(self):\n    \"parse values contained in a _loop block\"\n    LOG.debug(\"Parsing loop block\")\n    self.line_index += 1\n    line = self.content_lines[self.line_index]\n    keys = []\n    while line.strip().startswith(\"_\"):\n        keys.append(line.strip()[1:])\n        self.line_index += 1\n        line = self.content_lines[self.line_index]\n\n    line = self.content_lines[self.line_index]\n    values = []\n    while self.is_data_line(line):\n        LOG.debug(\"Parsing data line: %s\", line)\n        values.append(line.strip())\n        self.line_index += 1\n        if self.line_index &gt;= len(self.content_lines):\n            LOG.debug(\"Reached end of file parsing loop block\")\n            break\n        line = self.content_lines[self.line_index]\n    for k in keys:\n        self.current_data_block[k] = []\n\n    for value in values:\n        vs = re.findall(VALUES_REGEX, value.strip())\n        for k, v in zip(keys, vs, strict=False):\n            self.current_data_block[k].append(parse_value(v))\n    LOG.debug(\"Parsed loop block\")\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif.parse_quoted_block","title":"<code>parse_quoted_block(delimiter=';')</code>","text":"<p>parse an entire quoted block, delimited by delimiter</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def parse_quoted_block(self, delimiter=\";\"):\n    \"parse an entire quoted block, delimited by delimiter\"\n    LOG.debug(\"Parsing quoted block at line %d\", self.line_index)\n    self.content_lines[self.line_index].strip()\n    i = self.line_index + 1\n    j = i\n    n = 1\n    while \";\" not in self.content_lines[j]:\n        j += 1\n        n += 1\n        if j &gt;= len(self.content_lines) - 1:\n            break\n    else:\n        section = \" \".join(x.strip() for x in self.content_lines[i - 1 : j + 1])\n        self.line_index += n\n        return parse_quote(section)\n    raise ValueError(f\"Unmatch quotation on line {self.line_index + 1}\")\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif.to_file","title":"<code>to_file(filename)</code>","text":"<p>write this :obj:<code>Cif</code> to file</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def to_file(self, filename):\n    \"write this :obj:`Cif` to file\"\n    Path(filename).write_text(self.to_string())\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.Cif.to_string","title":"<code>to_string()</code>","text":"<p>represent the data in this :obj<code>Cif</code> textually in the CIF format</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def to_string(self):\n    \"represent the data in this :obj`Cif` textually in the CIF format\"\n    lines = []\n    for data_block_name, data_block_data in self.data.items():\n        lines.append(f\"data_{data_block_name}\")\n        vector_data_names = []\n        for data_name, data_value in data_block_data.items():\n            if is_scalar(data_value):\n                quote = \"\"\n                if needs_quote(data_value):\n                    quote = \"'\"\n                lines.append(f\"_{data_name} {quote}{data_value}{quote}\")\n            else:\n                vector_data_names.append(data_name)\n        from itertools import groupby\n\n        for _name_section, names_top in groupby(\n            vector_data_names, key=lambda x: x.split(\"_\")[0]\n        ):\n            for _section, names in groupby(\n                names_top, key=lambda x: len(data_block_data[x])\n            ):\n                lines.append(\"loop_\")\n                loop_values = []\n                for name in names:\n                    lines.append(f\"_{name}\")\n                    loop_values.append(data_block_data[name])\n                for row in zip(*loop_values, strict=False):\n                    lines.append(\" \".join(format_field(x) for x in row))\n\n    lines.append(\"#END\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.format_field","title":"<code>format_field(x)</code>","text":"<p>format a field to fixed precision if float otherwise as a string</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def format_field(x):\n    \"format a field to fixed precision if float otherwise as a string\"\n    if isinstance(x, float):\n        return f\"{x:20.12f}\"\n    elif isinstance(x, int):\n        return f\"{x:20d}\"\n    elif isinstance(x, str):\n        if needs_quote(x):\n            return f\"'{x}'\"\n        else:\n            return x\n    else:\n        return str(x)\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.is_scalar","title":"<code>is_scalar(value)</code>","text":"<p>check if the value is a string or has no len dunder method</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def is_scalar(value):\n    \"check if the value is a string or has no __len__ dunder method\"\n    return isinstance(value, str) or (not hasattr(value, \"__len__\"))\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.needs_quote","title":"<code>needs_quote(string)</code>","text":"<p>check if a string needs to be quoted (i.e. it has a space or quotation marks in it</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def needs_quote(string):\n    \"check if a string needs to be quoted (i.e. it has a space or quotation marks in it\"\n    if not isinstance(string, str):\n        return False\n    return \" \" in string and (not ('\"' in string or \"'\" in string))\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.parse_quote","title":"<code>parse_quote(string, delimiter=';')</code>","text":"<p>extract a value contained within quotes, with an optional change of delimiter</p>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.parse_quote--parameters","title":"Parameters","text":"<p>string: str     the string containing the value to parse</p> bool, optional <p>the quote delimiter, default ';'</p>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.parse_quote--returns","title":"Returns","text":"<p>value     the string contained inside the quotes</p> <p>parse_quote(\";quote text;\") 'quote text' parse_quote(\":'quote text':\", delimiter=\"'\") \":'quote text':\" parse_quote(\":'quote text':\", delimiter=\":\") \"'quote text'\" parse_quote(\"'-y, x-y, z'\", delimiter=\"'\") '-y, x-y, z'</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def parse_quote(string, delimiter=\";\"):\n    \"\"\"extract a value contained within quotes, with an optional change\n    of delimiter\n\n    Parameters\n    ----------\n    string: str\n        the string containing the value to parse\n\n    delimiter: bool, optional\n        the quote delimiter, default ';'\n\n    Returns\n    -------\n    value\n        the string contained inside the quotes\n\n    &gt;&gt;&gt; parse_quote(\";quote text;\")\n    'quote text'\n    &gt;&gt;&gt; parse_quote(\":'quote text':\", delimiter=\"'\")\n    \":'quote text':\"\n    &gt;&gt;&gt; parse_quote(\":'quote text':\", delimiter=\":\")\n    \"'quote text'\"\n    &gt;&gt;&gt; parse_quote(\"'-y, x-y, z'\", delimiter=\"'\")\n    '-y, x-y, z'\n\n    \"\"\"\n\n    regex = QUOTE_REGEX.format(delimiter)\n    match = re.match(regex, string)\n    if match:\n        return match.groups()[0]\n    return string\n</code></pre>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.parse_value","title":"<code>parse_value(string, with_uncertainty=False)</code>","text":"<p>parse a value from a cif file to its appropriate type e.g. int, float, str etc. Will handle uncertainty values contained in parentheses.</p>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.parse_value--parameters","title":"Parameters","text":"<p>string: str     the string containing the value to parse</p> bool, optional <p>return a tuple including uncertainty if a numeric type is expected</p>"},{"location":"reference/chmpy/fmt/cif/#chmpy.fmt.cif.parse_value--returns","title":"Returns","text":"<p>value     the value coerced into the appropriate type</p> <p>parse_value(\"2.3(1)\", with_uncertainty=True) (2.3, 1) parse_value(\"string help\") 'string help' parse_value(\"3.1415\") * 4 12.566</p> Source code in <code>chmpy/fmt/cif.py</code> <pre><code>def parse_value(string, with_uncertainty=False):\n    \"\"\"parse a value from a cif file to its appropriate type\n    e.g. int, float, str etc. Will handle uncertainty values\n    contained in parentheses.\n\n    Parameters\n    ----------\n    string: str\n        the string containing the value to parse\n\n    with_uncertainty: bool, optional\n        return a tuple including uncertainty if a numeric type is expected\n\n    Returns\n    -------\n    value\n        the value coerced into the appropriate type\n\n    &gt;&gt;&gt; parse_value(\"2.3(1)\", with_uncertainty=True)\n    (2.3, 1)\n    &gt;&gt;&gt; parse_value(\"string help\")\n    'string help'\n    &gt;&gt;&gt; parse_value(\"3.1415\") * 4\n    12.566\n    \"\"\"\n    match = NUM_ERR_REGEX.match(string)\n    if match and match.span()[1] == len(string):\n        groups = match.groups()\n        number, uncertainty = groups[0], groups[-1]\n        number = float(number)\n        if number.is_integer():\n            number = int(number)\n        if with_uncertainty:\n            return number, int(uncertainty.strip(\"()\")) if uncertainty else 0\n        return number\n    else:\n        s = string.strip()\n        if s[0] == s[-1] and s[0] in (\"'\", \";\", '\"'):\n            return parse_quote(string, delimiter=s[0])\n    return string\n</code></pre>"},{"location":"reference/chmpy/fmt/crystal17/","title":"crystal17","text":""},{"location":"reference/chmpy/fmt/cube/","title":"cube","text":""},{"location":"reference/chmpy/fmt/fchk/","title":"fchk","text":""},{"location":"reference/chmpy/fmt/gaussian_log/","title":"gaussian_log","text":""},{"location":"reference/chmpy/fmt/gen/","title":"gen","text":""},{"location":"reference/chmpy/fmt/gen/#chmpy.fmt.gen.parse_gen_file","title":"<code>parse_gen_file(filename)</code>","text":"<p>Convert a provided DFTB+ .gen file into an array of atomic numbers, positions and</p>"},{"location":"reference/chmpy/fmt/gen/#chmpy.fmt.gen.parse_gen_file--parameters","title":"Parameters","text":"<p>filename: str     path to the .xyz file to read</p>"},{"location":"reference/chmpy/fmt/gen/#chmpy.fmt.gen.parse_gen_file--returns","title":"Returns","text":"<p>tuple of :obj:<code>np.ndarray</code>     List[Element], (N, 3) positions, (4, 3) lattice vectors, bool (if fractional)     read from the given file</p> Source code in <code>chmpy/fmt/gen.py</code> <pre><code>def parse_gen_file(filename):\n    \"\"\"Convert a provided DFTB+ .gen file into an array of\n    atomic numbers, positions and\n\n    Parameters\n    ----------\n    filename: str\n        path to the .xyz file to read\n\n    Returns\n    -------\n    tuple of :obj:`np.ndarray`\n        List[Element], (N, 3) positions, (4, 3) lattice vectors, bool (if fractional)\n        read from the given file\n    \"\"\"\n    path = Path(filename)\n    return parse_gen_string(path.read_text(), filename=str(path.absolute()))\n</code></pre>"},{"location":"reference/chmpy/fmt/gen/#chmpy.fmt.gen.parse_gen_string","title":"<code>parse_gen_string(contents, filename=None)</code>","text":"<p>Convert provided xmol .xyz file contents into an array of atomic numbers and cartesian positions</p>"},{"location":"reference/chmpy/fmt/gen/#chmpy.fmt.gen.parse_gen_string--parameters","title":"Parameters","text":"<p>contents: str     text contents of the .xyz file to read</p>"},{"location":"reference/chmpy/fmt/gen/#chmpy.fmt.gen.parse_gen_string--returns","title":"Returns","text":"<p>tuple of :obj:<code>np.ndarray</code>     List[Element], (N, 3) positions, (4, 3) lattice vectors, bool (if fractional)     read from the given file</p> Source code in <code>chmpy/fmt/gen.py</code> <pre><code>def parse_gen_string(contents, filename=None):\n    \"\"\"Convert provided xmol .xyz file contents into an array of\n    atomic numbers and cartesian positions\n\n    Parameters\n    ----------\n    contents: str\n        text contents of the .xyz file to read\n\n    Returns\n    -------\n    tuple of :obj:`np.ndarray`\n        List[Element], (N, 3) positions, (4, 3) lattice vectors, bool (if fractional)\n        read from the given file\n    \"\"\"\n    lines = contents.splitlines()\n    natom_str, kind = lines[0].split()\n    natom = int(natom_str)\n    kind = kind.strip()\n    LOG.debug(\"Expecting %d atoms %s\", natom, \"in \" + filename if filename else \"\")\n    elements_map = [Element[x.strip()] for x in lines[1].split()]\n\n    arr = [[float(x) for x in line.split()] for line in lines[natom + 2 : natom + 6]]\n    elements = []\n    positions = []\n    for line in lines[2 : natom + 2]:\n        if not line.strip():\n            break\n        tokens = line.strip().split()\n        xyz = tuple(float(x) for x in tokens[2:5])\n        positions.append(xyz)\n        el = elements_map[int(tokens[1]) - 1]\n        elements.append(el)\n    LOG.debug(\n        \"Found %d atoms lines in %s\",\n        len(elements),\n        \"in \" + filename if filename else \"\",\n    )\n    return elements, np.asarray(positions), np.asarray(arr), kind == \"F\"\n</code></pre>"},{"location":"reference/chmpy/fmt/gmf/","title":"gmf","text":""},{"location":"reference/chmpy/fmt/grd/","title":"grd","text":""},{"location":"reference/chmpy/fmt/gulp/","title":"gulp","text":""},{"location":"reference/chmpy/fmt/gulp/#chmpy.fmt.gulp.parse_drv_file","title":"<code>parse_drv_file(drv_path)</code>","text":"<p>Parse GULP .drv file to extract energy, gradients, and stress.</p> <p>The .drv file format: Line 1: energy  eV Line 2: coordinates cartesian Angstroms  Lines 3 to 2+natoms: atom_id element_id x y z Line 3+natoms: gradients cartesian eV/Ang  Lines 4+natoms to 3+2natoms: atom_id gx gy gz Line 4+2natoms: gradients strain eV Remaining lines: strain gradients"},{"location":"reference/chmpy/fmt/gulp/#chmpy.fmt.gulp.parse_drv_file--parameters","title":"Parameters","text":"<p>drv_path : Path     Path to the .drv file</p>"},{"location":"reference/chmpy/fmt/gulp/#chmpy.fmt.gulp.parse_drv_file--returns","title":"Returns","text":"<p>Dict[str, Any]     Dictionary containing 'energy', 'gradients', and 'stress_raw'</p> Source code in <code>chmpy/fmt/gulp.py</code> <pre><code>def parse_drv_file(drv_path: Path) -&gt; dict[str, Any]:\n    \"\"\"\n    Parse GULP .drv file to extract energy, gradients, and stress.\n\n    The .drv file format:\n    Line 1: energy &lt;value&gt; eV\n    Line 2: coordinates cartesian Angstroms &lt;natoms&gt;\n    Lines 3 to 2+natoms: atom_id element_id x y z\n    Line 3+natoms: gradients cartesian eV/Ang &lt;natoms&gt;\n    Lines 4+natoms to 3+2*natoms: atom_id gx gy gz\n    Line 4+2*natoms: gradients strain eV\n    Remaining lines: strain gradients\n\n    Parameters\n    ----------\n    drv_path : Path\n        Path to the .drv file\n\n    Returns\n    -------\n    Dict[str, Any]\n        Dictionary containing 'energy', 'gradients', and 'stress_raw'\n    \"\"\"\n    if not drv_path.exists():\n        raise FileNotFoundError(f\"GULP .drv file not found: {drv_path}\")\n\n    lines = drv_path.read_text().splitlines()\n    if not lines:\n        raise ValueError(\"Empty .drv file\")\n\n    line_idx = 0\n\n    # Parse energy from first line: \"energy                  -0.7783918216 eV\"\n    if line_idx &gt;= len(lines):\n        raise ValueError(\n            f\"Expected energy line at index {line_idx}, but file only has {len(lines)} lines\"\n        )\n\n    energy_line = lines[line_idx].strip()\n    if not energy_line:\n        raise ValueError(f\"Empty energy line at index {line_idx}\")\n\n    energy_parts = energy_line.split()\n    if len(energy_parts) &lt; 2:\n        raise ValueError(\n            f\"Invalid energy line format: '{energy_line}' - expected at least 2 parts\"\n        )\n\n    try:\n        energy = float(energy_parts[1])\n    except (ValueError, IndexError) as e:\n        raise ValueError(f\"Could not parse energy from line '{energy_line}'\") from e\n\n    line_idx += 1\n\n    # Parse coordinates header: \"coordinates cartesian Angstroms     48\"\n    coord_header = lines[line_idx].strip()\n    natoms = int(coord_header.split()[-1])\n    line_idx += 1\n\n    # Skip coordinate lines\n    line_idx += natoms\n\n    # Parse gradients header: \"gradients cartesian eV/Ang     48\"\n    lines[line_idx].strip()\n    line_idx += 1\n\n    # Parse gradients (GULP outputs gradients directly)\n    gradients = np.zeros((natoms, 3))\n    for i in range(natoms):\n        parts = lines[line_idx].split()\n        # GULP gives gradients in eV/Ang\n        # Handle potential numerical overflow (****** values)\n        try:\n            gradients[i] = [float(parts[1]), float(parts[2]), float(parts[3])]\n        except ValueError:\n            # Handle overflow case - set to large value\n            gradients[i] = [\n                1e10 if \"*\" in parts[1] else float(parts[1]),\n                1e10 if \"*\" in parts[2] else float(parts[2]),\n                1e10 if \"*\" in parts[3] else float(parts[3]),\n            ]\n        line_idx += 1\n\n    # Parse strain gradients header: \"gradients strain eV\" (if present)\n    stress_raw = np.zeros(6)  # Default to zero stress\n\n    if line_idx &lt; len(lines):\n        strain_header = lines[line_idx].strip()\n        if strain_header.startswith(\"gradients strain\"):\n            line_idx += 1\n\n            # Parse strain gradients\n            strain_gradients = []\n            while line_idx &lt; len(lines) and lines[line_idx].strip():\n                line = lines[line_idx].strip()\n\n                # Skip force constants section if present\n                if \"force_constants\" in line:\n                    line_idx += 1\n                    # Skip the entire force constants block\n                    while line_idx &lt; len(lines) and lines[line_idx].strip():\n                        line_idx += 1\n                    break\n\n                parts = lines[line_idx].split()\n                try:\n                    # Convert each part to float, handling overflow\n                    for part in parts:\n                        if \"*\" in part:\n                            strain_gradients.append(1e10)\n                        else:\n                            strain_gradients.append(float(part))\n                except ValueError:\n                    # Skip lines that can't be parsed as numbers\n                    pass\n                line_idx += 1\n\n            # Convert strain gradients to stress (requires volume from calling context)\n            # For now, just return the raw strain gradients\n            stress_raw = (\n                np.array(strain_gradients[:6])\n                if len(strain_gradients) &gt;= 6\n                else np.zeros(6)\n            )\n\n    # Look for force constants if we skipped them earlier\n    force_constants = None\n    # Reset to find force constants section\n    for _i, line in enumerate(lines):\n        if \"force_constants\" in line:\n            # Parse force constants matrix if needed\n            # For now, just flag that they exist\n            force_constants = \"present\"\n            break\n\n    return {\n        \"energy\": energy,\n        \"gradients\": gradients,\n        \"stress_raw\": stress_raw,  # Will need volume to convert to stress\n        \"natoms\": natoms,\n        \"force_constants\": force_constants,\n    }\n</code></pre>"},{"location":"reference/chmpy/fmt/gulp/#chmpy.fmt.gulp.parse_value","title":"<code>parse_value(string, with_units=False)</code>","text":"<p>parse a value from a GULP output file to its appropriate type e.g. int, float, str etc. Will handle units with a space.</p>"},{"location":"reference/chmpy/fmt/gulp/#chmpy.fmt.gulp.parse_value--parameters","title":"Parameters","text":"<p>string: str     the string containing the value to parse</p> bool, optional <p>return a tuple including uncertainty if a numeric type is expected</p>"},{"location":"reference/chmpy/fmt/gulp/#chmpy.fmt.gulp.parse_value--returns","title":"Returns","text":"<p>value     the value coerced into the appropriate type</p> <p>parse_value(\"2.3 kj/mol\", with_units=True) (2.3, 'kj/mol') parse_value(\"5 kgm^2\", with_units=True) (5, 'kgm^2') parse_value(\"string help\") 'string help' parse_value(\"3.1415\") * 4 12.566</p> Source code in <code>chmpy/fmt/gulp.py</code> <pre><code>def parse_value(string, with_units=False):\n    \"\"\"parse a value from a GULP output file to its appropriate type\n    e.g. int, float, str etc. Will handle units with a space.\n\n    Parameters\n    ----------\n    string: str\n        the string containing the value to parse\n\n    with_uncertainty: bool, optional\n        return a tuple including uncertainty if a numeric type is expected\n\n    Returns\n    -------\n    value\n        the value coerced into the appropriate type\n\n    &gt;&gt;&gt; parse_value(\"2.3 kj/mol\", with_units=True)\n    (2.3, 'kj/mol')\n    &gt;&gt;&gt; parse_value(\"5 kgm^2\", with_units=True)\n    (5, 'kgm^2')\n    &gt;&gt;&gt; parse_value(\"string help\")\n    'string help'\n    &gt;&gt;&gt; parse_value(\"3.1415\") * 4\n    12.566\n    \"\"\"\n    match = NUMBER_REGEX.match(string)\n    try:\n        if match and match:\n            groups = match.groups()\n            number = groups[0]\n            number = float(number)\n            if number.is_integer():\n                number = int(number)\n            if with_units and len(groups) &gt; 1:\n                return number, groups[1]\n            return number\n        else:\n            s = string.strip()\n            return s\n    except Exception as e:\n        print(e)\n    return string\n</code></pre>"},{"location":"reference/chmpy/fmt/mol2/","title":"mol2","text":""},{"location":"reference/chmpy/fmt/nwchem/","title":"nwchem","text":""},{"location":"reference/chmpy/fmt/pdb/","title":"pdb","text":""},{"location":"reference/chmpy/fmt/pdb/#chmpy.fmt.pdb.Pdb","title":"<code>Pdb</code>","text":"<p>Very basic PDB parser for crystallographic and atomic data.</p> Source code in <code>chmpy/fmt/pdb.py</code> <pre><code>class Pdb:\n    \"\"\"\n    Very basic PDB parser for crystallographic and atomic data.\n    \"\"\"\n\n    def __init__(self, pdb_data):\n        self.data = pdb_data\n        self.content_lines = []\n        self.header = None\n        self.unit_cell = None\n        self.space_group = None\n        self.z = None\n        self.atoms = None\n        self.line_index = 0\n\n    def parse_crystal_line(self, line):\n        \"\"\"Parse CRYST1 record containing unit cell parameters.\"\"\"\n        line_length = len(line)\n        self.unit_cell = {\n            \"a\": float(line[6:14]),\n            \"b\": float(line[15:23]),\n            \"c\": float(line[24:32]),\n            \"alpha\": float(line[33:39]),\n            \"beta\": float(line[40:46]),\n            \"gamma\": float(line[47:53]),\n        }\n        self.space_group = \"P 1\"  # default\n        if line_length &gt; 55:\n            self.space_group = line[55 : min(line_length, 65)].strip()\n        self.z = 1  # default\n        if line_length &gt; 66:\n            z_str = line[66 : min(line_length, 69)].strip()\n            if z_str:\n                self.z = int(z_str)\n\n    def parse_atom_lines(self):\n        \"\"\"Parse ATOM and HETATM records.\"\"\"\n        # Initialize atom data structure\n        self.atoms = {\n            \"serial\": [],\n            \"name\": [],\n            \"alt_loc\": [],\n            \"res_name\": [],\n            \"chain_id\": [],\n            \"res_seq\": [],\n            \"icode\": [],\n            \"x\": [],\n            \"y\": [],\n            \"z\": [],\n            \"occupancy\": [],\n            \"temp_factor\": [],\n            \"element\": [],\n            \"charge\": [],\n        }\n\n        # Process all atom lines until we hit a non-atom record or end of file\n        total_lines = len(self.content_lines)\n\n        while self.line_index &lt; total_lines:\n            line = self.content_lines[self.line_index]\n\n            # Check for MODEL/ENDMDL records (handle multiple models)\n            if line.startswith(\"MODEL \"):\n                self.line_index += 1\n                continue\n            elif line.startswith(\"ENDMDL\") or line.startswith(\"END\"):\n                self.line_index += 1\n                break\n\n            # Process atom records\n            if line[:6] in (\"ATOM  \", \"HETATM\"):\n                try:\n                    self.atoms[\"serial\"].append(int(line[6:11]))\n                    self.atoms[\"name\"].append(line[12:16].strip())\n                    self.atoms[\"alt_loc\"].append(line[16])\n                    self.atoms[\"res_name\"].append(line[17:20].strip())\n                    self.atoms[\"chain_id\"].append(line[21])\n                    self.atoms[\"res_seq\"].append(int(line[22:26]))\n                    self.atoms[\"icode\"].append(line[26])\n                    self.atoms[\"x\"].append(float(line[30:38]))\n                    self.atoms[\"y\"].append(float(line[38:46]))\n                    self.atoms[\"z\"].append(float(line[46:54]))\n                    self.atoms[\"occupancy\"].append(float(line[54:60]))\n                    self.atoms[\"temp_factor\"].append(float(line[60:66]))\n                    self.atoms[\"element\"].append(line[76:78].strip())\n\n                    # Parse charge safely\n                    chg = line[78:80].strip()\n                    self.atoms[\"charge\"].append(float(chg[::-1]) if chg else 0.0)\n                except (ValueError, IndexError) as e:\n                    # Handle malformed lines gracefully\n                    print(\n                        f\"Warning: Error parsing atom at line {self.line_index + 1}: {e}\"\n                    )\n            else:\n                # If we hit a non-atom record, break the parsing loop\n                break\n\n            self.line_index += 1\n\n    def parse_header(self):\n        \"\"\"Parse the PDB header to find crystallographic information.\"\"\"\n        total_lines = len(self.content_lines)\n\n        while self.line_index &lt; total_lines:\n            line = self.content_lines[self.line_index]\n            record_type = line[:6]\n\n            if record_type == \"CRYST1\":\n                self.parse_crystal_line(line)\n                self.line_index += 1\n            elif record_type == \"HEADER\":\n                self.header = line[10:].strip()\n                self.line_index += 1\n            elif record_type in (\"ATOM  \", \"HETATM\", \"MODEL \"):\n                # We've reached the atom section\n                break\n            else:\n                # Skip other header records\n                self.line_index += 1\n\n        # Debug info - print crystallographic data\n        if self.unit_cell:\n            print(self.unit_cell)\n            print(self.space_group)\n            print(self.z)\n\n    def parse(self):\n        \"\"\"Parse the entire PDB contents.\"\"\"\n        self.line_index = 0\n\n        # Parse header section\n        self.parse_header()\n\n        # Parse atom records\n        self.parse_atom_lines()\n\n        # Skip any remaining records\n        while self.line_index &lt; len(self.content_lines):\n            self.line_index += 1\n\n        return self.data\n\n    def format_crystal_line(self):\n        \"\"\"Format CRYST1 record from unit cell parameters.\"\"\"\n        if not self.unit_cell:\n            return None\n\n        space_group = self.space_group or \"P 1\"\n        z = self.z or 1\n\n        return (\n            f\"CRYST1{self.unit_cell['a']:9.3f}{self.unit_cell['b']:9.3f}\"\n            f\"{self.unit_cell['c']:9.3f}{self.unit_cell['alpha']:7.2f}\"\n            f\"{self.unit_cell['beta']:7.2f}{self.unit_cell['gamma']:7.2f} \"\n            f\"{space_group:&lt;11}{z:4d}\"\n        )\n\n    def format_atom_line(self, idx, record_type=\"ATOM\"):\n        \"\"\"Format an ATOM or HETATM record.\"\"\"\n        if not self.atoms or idx &gt;= len(self.atoms[\"serial\"]):\n            return None\n\n        # Get atom data with defaults\n        serial = self.atoms[\"serial\"][idx]\n        name = self.atoms[\"name\"][idx]\n        alt_loc = self.atoms[\"alt_loc\"][idx] if self.atoms[\"alt_loc\"][idx] else \" \"\n        res_name = self.atoms[\"res_name\"][idx]\n        chain_id = self.atoms[\"chain_id\"][idx] if self.atoms[\"chain_id\"][idx] else \" \"\n        res_seq = self.atoms[\"res_seq\"][idx]\n        icode = self.atoms[\"icode\"][idx] if self.atoms[\"icode\"][idx] else \" \"\n        x = self.atoms[\"x\"][idx]\n        y = self.atoms[\"y\"][idx]\n        z = self.atoms[\"z\"][idx]\n        occupancy = (\n            self.atoms[\"occupancy\"][idx] if self.atoms[\"occupancy\"][idx] else 1.00\n        )\n        temp_factor = (\n            self.atoms[\"temp_factor\"][idx] if self.atoms[\"temp_factor\"][idx] else 0.00\n        )\n        element = self.atoms[\"element\"][idx] if self.atoms[\"element\"][idx] else \"\"\n        charge = self.atoms[\"charge\"][idx] if self.atoms[\"charge\"][idx] else 0.0\n\n        # Format charge\n        charge_str = \"\"\n        if charge != 0.0:\n            charge_str = f\"{abs(charge):.0f}{'+' if charge &gt; 0 else '-'}\"\n\n        return (\n            f\"{record_type:&lt;6}{serial:5d} {name:&lt;4}{alt_loc}{res_name:&gt;3} \"\n            f\"{chain_id}{res_seq:4d}{icode}   {x:8.3f}{y:8.3f}{z:8.3f}\"\n            f\"{occupancy:6.2f}{temp_factor:6.2f}          {element:&gt;2}{charge_str:&gt;2}\"\n        )\n\n    def to_string(self):\n        \"\"\"Convert the parsed PDB data back to a PDB format string.\"\"\"\n        lines = []\n\n        # Add header if present\n        if self.header:\n            lines.append(f\"HEADER    {self.header}\")\n\n        # Add crystal information\n        cryst_line = self.format_crystal_line()\n        if cryst_line:\n            lines.append(cryst_line)\n\n        # Add atom records\n        if self.atoms and self.atoms[\"serial\"]:\n            for i in range(len(self.atoms[\"serial\"])):\n                atom_line = self.format_atom_line(i)\n                if atom_line:\n                    lines.append(atom_line)\n\n        lines.append(\"END\")\n        return \"\\n\".join(lines)\n\n    def to_file(self, filename):\n        \"\"\"Write the PDB data to a file.\"\"\"\n        Path(filename).write_text(self.to_string())\n\n    @classmethod\n    def from_crystal(cls, crystal, header=None):\n        \"\"\"Initialize a PDB from a Crystal object.\"\"\"\n        pdb = cls({})\n\n        # Set header\n        pdb.header = header or \"Crystal structure\"\n\n        # Set unit cell parameters\n        import numpy as np\n\n        pdb.unit_cell = {\n            \"a\": crystal.unit_cell.a,\n            \"b\": crystal.unit_cell.b,\n            \"c\": crystal.unit_cell.c,\n            \"alpha\": np.degrees(crystal.unit_cell.alpha),\n            \"beta\": np.degrees(crystal.unit_cell.beta),\n            \"gamma\": np.degrees(crystal.unit_cell.gamma),\n        }\n\n        # Keep the original space group and Z\n        pdb.space_group = crystal.space_group.crystal17_spacegroup_symbol()\n        pdb.z = 1  # Default for now\n\n        # Use asymmetric unit atoms (not full unit cell)\n        positions = crystal.to_cartesian(crystal.site_positions)\n        atomic_numbers = crystal.site_atoms\n\n        # Initialize atom data structure\n        pdb.atoms = {\n            \"serial\": [],\n            \"name\": [],\n            \"alt_loc\": [],\n            \"res_name\": [],\n            \"chain_id\": [],\n            \"res_seq\": [],\n            \"icode\": [],\n            \"x\": [],\n            \"y\": [],\n            \"z\": [],\n            \"occupancy\": [],\n            \"temp_factor\": [],\n            \"element\": [],\n            \"charge\": [],\n        }\n\n        # Populate atom data\n        for i, (pos, atomic_num) in enumerate(\n            zip(positions, atomic_numbers, strict=False)\n        ):\n            from chmpy.core.element import Element\n\n            element = Element.from_atomic_number(atomic_num)\n\n            pdb.atoms[\"serial\"].append(i + 1)\n            pdb.atoms[\"name\"].append(element.symbol)\n            pdb.atoms[\"alt_loc\"].append(\" \")\n            pdb.atoms[\"res_name\"].append(\"UNL\")  # Unknown ligand\n            pdb.atoms[\"chain_id\"].append(\"A\")\n            pdb.atoms[\"res_seq\"].append(1)\n            pdb.atoms[\"icode\"].append(\" \")\n            pdb.atoms[\"x\"].append(float(pos[0]))\n            pdb.atoms[\"y\"].append(float(pos[1]))\n            pdb.atoms[\"z\"].append(float(pos[2]))\n            pdb.atoms[\"occupancy\"].append(1.00)\n            pdb.atoms[\"temp_factor\"].append(0.00)\n            pdb.atoms[\"element\"].append(element.symbol)\n            pdb.atoms[\"charge\"].append(0.0)\n\n        return pdb\n\n    @classmethod\n    def from_file(cls, filename):\n        \"\"\"Initialize a PDB parser from a file path.\"\"\"\n        return cls.from_string(Path(filename).read_text())\n\n    @classmethod\n    def from_string(cls, contents):\n        \"\"\"Initialize a PDB parser from string contents.\"\"\"\n        pdb = cls({})\n        pdb.content_lines = [line.strip() for line in contents.split(\"\\n\")]\n        pdb.parse()\n        return pdb\n</code></pre>"},{"location":"reference/chmpy/fmt/pdb/#chmpy.fmt.pdb.Pdb.format_atom_line","title":"<code>format_atom_line(idx, record_type='ATOM')</code>","text":"<p>Format an ATOM or HETATM record.</p> Source code in <code>chmpy/fmt/pdb.py</code> <pre><code>def format_atom_line(self, idx, record_type=\"ATOM\"):\n    \"\"\"Format an ATOM or HETATM record.\"\"\"\n    if not self.atoms or idx &gt;= len(self.atoms[\"serial\"]):\n        return None\n\n    # Get atom data with defaults\n    serial = self.atoms[\"serial\"][idx]\n    name = self.atoms[\"name\"][idx]\n    alt_loc = self.atoms[\"alt_loc\"][idx] if self.atoms[\"alt_loc\"][idx] else \" \"\n    res_name = self.atoms[\"res_name\"][idx]\n    chain_id = self.atoms[\"chain_id\"][idx] if self.atoms[\"chain_id\"][idx] else \" \"\n    res_seq = self.atoms[\"res_seq\"][idx]\n    icode = self.atoms[\"icode\"][idx] if self.atoms[\"icode\"][idx] else \" \"\n    x = self.atoms[\"x\"][idx]\n    y = self.atoms[\"y\"][idx]\n    z = self.atoms[\"z\"][idx]\n    occupancy = (\n        self.atoms[\"occupancy\"][idx] if self.atoms[\"occupancy\"][idx] else 1.00\n    )\n    temp_factor = (\n        self.atoms[\"temp_factor\"][idx] if self.atoms[\"temp_factor\"][idx] else 0.00\n    )\n    element = self.atoms[\"element\"][idx] if self.atoms[\"element\"][idx] else \"\"\n    charge = self.atoms[\"charge\"][idx] if self.atoms[\"charge\"][idx] else 0.0\n\n    # Format charge\n    charge_str = \"\"\n    if charge != 0.0:\n        charge_str = f\"{abs(charge):.0f}{'+' if charge &gt; 0 else '-'}\"\n\n    return (\n        f\"{record_type:&lt;6}{serial:5d} {name:&lt;4}{alt_loc}{res_name:&gt;3} \"\n        f\"{chain_id}{res_seq:4d}{icode}   {x:8.3f}{y:8.3f}{z:8.3f}\"\n        f\"{occupancy:6.2f}{temp_factor:6.2f}          {element:&gt;2}{charge_str:&gt;2}\"\n    )\n</code></pre>"},{"location":"reference/chmpy/fmt/pdb/#chmpy.fmt.pdb.Pdb.format_crystal_line","title":"<code>format_crystal_line()</code>","text":"<p>Format CRYST1 record from unit cell parameters.</p> Source code in <code>chmpy/fmt/pdb.py</code> <pre><code>def format_crystal_line(self):\n    \"\"\"Format CRYST1 record from unit cell parameters.\"\"\"\n    if not self.unit_cell:\n        return None\n\n    space_group = self.space_group or \"P 1\"\n    z = self.z or 1\n\n    return (\n        f\"CRYST1{self.unit_cell['a']:9.3f}{self.unit_cell['b']:9.3f}\"\n        f\"{self.unit_cell['c']:9.3f}{self.unit_cell['alpha']:7.2f}\"\n        f\"{self.unit_cell['beta']:7.2f}{self.unit_cell['gamma']:7.2f} \"\n        f\"{space_group:&lt;11}{z:4d}\"\n    )\n</code></pre>"},{"location":"reference/chmpy/fmt/pdb/#chmpy.fmt.pdb.Pdb.from_crystal","title":"<code>from_crystal(crystal, header=None)</code>  <code>classmethod</code>","text":"<p>Initialize a PDB from a Crystal object.</p> Source code in <code>chmpy/fmt/pdb.py</code> <pre><code>@classmethod\ndef from_crystal(cls, crystal, header=None):\n    \"\"\"Initialize a PDB from a Crystal object.\"\"\"\n    pdb = cls({})\n\n    # Set header\n    pdb.header = header or \"Crystal structure\"\n\n    # Set unit cell parameters\n    import numpy as np\n\n    pdb.unit_cell = {\n        \"a\": crystal.unit_cell.a,\n        \"b\": crystal.unit_cell.b,\n        \"c\": crystal.unit_cell.c,\n        \"alpha\": np.degrees(crystal.unit_cell.alpha),\n        \"beta\": np.degrees(crystal.unit_cell.beta),\n        \"gamma\": np.degrees(crystal.unit_cell.gamma),\n    }\n\n    # Keep the original space group and Z\n    pdb.space_group = crystal.space_group.crystal17_spacegroup_symbol()\n    pdb.z = 1  # Default for now\n\n    # Use asymmetric unit atoms (not full unit cell)\n    positions = crystal.to_cartesian(crystal.site_positions)\n    atomic_numbers = crystal.site_atoms\n\n    # Initialize atom data structure\n    pdb.atoms = {\n        \"serial\": [],\n        \"name\": [],\n        \"alt_loc\": [],\n        \"res_name\": [],\n        \"chain_id\": [],\n        \"res_seq\": [],\n        \"icode\": [],\n        \"x\": [],\n        \"y\": [],\n        \"z\": [],\n        \"occupancy\": [],\n        \"temp_factor\": [],\n        \"element\": [],\n        \"charge\": [],\n    }\n\n    # Populate atom data\n    for i, (pos, atomic_num) in enumerate(\n        zip(positions, atomic_numbers, strict=False)\n    ):\n        from chmpy.core.element import Element\n\n        element = Element.from_atomic_number(atomic_num)\n\n        pdb.atoms[\"serial\"].append(i + 1)\n        pdb.atoms[\"name\"].append(element.symbol)\n        pdb.atoms[\"alt_loc\"].append(\" \")\n        pdb.atoms[\"res_name\"].append(\"UNL\")  # Unknown ligand\n        pdb.atoms[\"chain_id\"].append(\"A\")\n        pdb.atoms[\"res_seq\"].append(1)\n        pdb.atoms[\"icode\"].append(\" \")\n        pdb.atoms[\"x\"].append(float(pos[0]))\n        pdb.atoms[\"y\"].append(float(pos[1]))\n        pdb.atoms[\"z\"].append(float(pos[2]))\n        pdb.atoms[\"occupancy\"].append(1.00)\n        pdb.atoms[\"temp_factor\"].append(0.00)\n        pdb.atoms[\"element\"].append(element.symbol)\n        pdb.atoms[\"charge\"].append(0.0)\n\n    return pdb\n</code></pre>"},{"location":"reference/chmpy/fmt/pdb/#chmpy.fmt.pdb.Pdb.from_file","title":"<code>from_file(filename)</code>  <code>classmethod</code>","text":"<p>Initialize a PDB parser from a file path.</p> Source code in <code>chmpy/fmt/pdb.py</code> <pre><code>@classmethod\ndef from_file(cls, filename):\n    \"\"\"Initialize a PDB parser from a file path.\"\"\"\n    return cls.from_string(Path(filename).read_text())\n</code></pre>"},{"location":"reference/chmpy/fmt/pdb/#chmpy.fmt.pdb.Pdb.from_string","title":"<code>from_string(contents)</code>  <code>classmethod</code>","text":"<p>Initialize a PDB parser from string contents.</p> Source code in <code>chmpy/fmt/pdb.py</code> <pre><code>@classmethod\ndef from_string(cls, contents):\n    \"\"\"Initialize a PDB parser from string contents.\"\"\"\n    pdb = cls({})\n    pdb.content_lines = [line.strip() for line in contents.split(\"\\n\")]\n    pdb.parse()\n    return pdb\n</code></pre>"},{"location":"reference/chmpy/fmt/pdb/#chmpy.fmt.pdb.Pdb.parse","title":"<code>parse()</code>","text":"<p>Parse the entire PDB contents.</p> Source code in <code>chmpy/fmt/pdb.py</code> <pre><code>def parse(self):\n    \"\"\"Parse the entire PDB contents.\"\"\"\n    self.line_index = 0\n\n    # Parse header section\n    self.parse_header()\n\n    # Parse atom records\n    self.parse_atom_lines()\n\n    # Skip any remaining records\n    while self.line_index &lt; len(self.content_lines):\n        self.line_index += 1\n\n    return self.data\n</code></pre>"},{"location":"reference/chmpy/fmt/pdb/#chmpy.fmt.pdb.Pdb.parse_atom_lines","title":"<code>parse_atom_lines()</code>","text":"<p>Parse ATOM and HETATM records.</p> Source code in <code>chmpy/fmt/pdb.py</code> <pre><code>def parse_atom_lines(self):\n    \"\"\"Parse ATOM and HETATM records.\"\"\"\n    # Initialize atom data structure\n    self.atoms = {\n        \"serial\": [],\n        \"name\": [],\n        \"alt_loc\": [],\n        \"res_name\": [],\n        \"chain_id\": [],\n        \"res_seq\": [],\n        \"icode\": [],\n        \"x\": [],\n        \"y\": [],\n        \"z\": [],\n        \"occupancy\": [],\n        \"temp_factor\": [],\n        \"element\": [],\n        \"charge\": [],\n    }\n\n    # Process all atom lines until we hit a non-atom record or end of file\n    total_lines = len(self.content_lines)\n\n    while self.line_index &lt; total_lines:\n        line = self.content_lines[self.line_index]\n\n        # Check for MODEL/ENDMDL records (handle multiple models)\n        if line.startswith(\"MODEL \"):\n            self.line_index += 1\n            continue\n        elif line.startswith(\"ENDMDL\") or line.startswith(\"END\"):\n            self.line_index += 1\n            break\n\n        # Process atom records\n        if line[:6] in (\"ATOM  \", \"HETATM\"):\n            try:\n                self.atoms[\"serial\"].append(int(line[6:11]))\n                self.atoms[\"name\"].append(line[12:16].strip())\n                self.atoms[\"alt_loc\"].append(line[16])\n                self.atoms[\"res_name\"].append(line[17:20].strip())\n                self.atoms[\"chain_id\"].append(line[21])\n                self.atoms[\"res_seq\"].append(int(line[22:26]))\n                self.atoms[\"icode\"].append(line[26])\n                self.atoms[\"x\"].append(float(line[30:38]))\n                self.atoms[\"y\"].append(float(line[38:46]))\n                self.atoms[\"z\"].append(float(line[46:54]))\n                self.atoms[\"occupancy\"].append(float(line[54:60]))\n                self.atoms[\"temp_factor\"].append(float(line[60:66]))\n                self.atoms[\"element\"].append(line[76:78].strip())\n\n                # Parse charge safely\n                chg = line[78:80].strip()\n                self.atoms[\"charge\"].append(float(chg[::-1]) if chg else 0.0)\n            except (ValueError, IndexError) as e:\n                # Handle malformed lines gracefully\n                print(\n                    f\"Warning: Error parsing atom at line {self.line_index + 1}: {e}\"\n                )\n        else:\n            # If we hit a non-atom record, break the parsing loop\n            break\n\n        self.line_index += 1\n</code></pre>"},{"location":"reference/chmpy/fmt/pdb/#chmpy.fmt.pdb.Pdb.parse_crystal_line","title":"<code>parse_crystal_line(line)</code>","text":"<p>Parse CRYST1 record containing unit cell parameters.</p> Source code in <code>chmpy/fmt/pdb.py</code> <pre><code>def parse_crystal_line(self, line):\n    \"\"\"Parse CRYST1 record containing unit cell parameters.\"\"\"\n    line_length = len(line)\n    self.unit_cell = {\n        \"a\": float(line[6:14]),\n        \"b\": float(line[15:23]),\n        \"c\": float(line[24:32]),\n        \"alpha\": float(line[33:39]),\n        \"beta\": float(line[40:46]),\n        \"gamma\": float(line[47:53]),\n    }\n    self.space_group = \"P 1\"  # default\n    if line_length &gt; 55:\n        self.space_group = line[55 : min(line_length, 65)].strip()\n    self.z = 1  # default\n    if line_length &gt; 66:\n        z_str = line[66 : min(line_length, 69)].strip()\n        if z_str:\n            self.z = int(z_str)\n</code></pre>"},{"location":"reference/chmpy/fmt/pdb/#chmpy.fmt.pdb.Pdb.parse_header","title":"<code>parse_header()</code>","text":"<p>Parse the PDB header to find crystallographic information.</p> Source code in <code>chmpy/fmt/pdb.py</code> <pre><code>def parse_header(self):\n    \"\"\"Parse the PDB header to find crystallographic information.\"\"\"\n    total_lines = len(self.content_lines)\n\n    while self.line_index &lt; total_lines:\n        line = self.content_lines[self.line_index]\n        record_type = line[:6]\n\n        if record_type == \"CRYST1\":\n            self.parse_crystal_line(line)\n            self.line_index += 1\n        elif record_type == \"HEADER\":\n            self.header = line[10:].strip()\n            self.line_index += 1\n        elif record_type in (\"ATOM  \", \"HETATM\", \"MODEL \"):\n            # We've reached the atom section\n            break\n        else:\n            # Skip other header records\n            self.line_index += 1\n\n    # Debug info - print crystallographic data\n    if self.unit_cell:\n        print(self.unit_cell)\n        print(self.space_group)\n        print(self.z)\n</code></pre>"},{"location":"reference/chmpy/fmt/pdb/#chmpy.fmt.pdb.Pdb.to_file","title":"<code>to_file(filename)</code>","text":"<p>Write the PDB data to a file.</p> Source code in <code>chmpy/fmt/pdb.py</code> <pre><code>def to_file(self, filename):\n    \"\"\"Write the PDB data to a file.\"\"\"\n    Path(filename).write_text(self.to_string())\n</code></pre>"},{"location":"reference/chmpy/fmt/pdb/#chmpy.fmt.pdb.Pdb.to_string","title":"<code>to_string()</code>","text":"<p>Convert the parsed PDB data back to a PDB format string.</p> Source code in <code>chmpy/fmt/pdb.py</code> <pre><code>def to_string(self):\n    \"\"\"Convert the parsed PDB data back to a PDB format string.\"\"\"\n    lines = []\n\n    # Add header if present\n    if self.header:\n        lines.append(f\"HEADER    {self.header}\")\n\n    # Add crystal information\n    cryst_line = self.format_crystal_line()\n    if cryst_line:\n        lines.append(cryst_line)\n\n    # Add atom records\n    if self.atoms and self.atoms[\"serial\"]:\n        for i in range(len(self.atoms[\"serial\"])):\n            atom_line = self.format_atom_line(i)\n            if atom_line:\n                lines.append(atom_line)\n\n    lines.append(\"END\")\n    return \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/chmpy/fmt/raspa/","title":"raspa","text":"<p>Parser for RASPA3 output files.</p> <p>This module provides functions to parse both text and JSON outputs from RASPA3 simulations and extract key information such as adsorption data, energy values, and more.</p>"},{"location":"reference/chmpy/fmt/raspa/#chmpy.fmt.raspa.extract_adsorption_data","title":"<code>extract_adsorption_data(parsed_data)</code>","text":"<p>Extract adsorption data from parsed RASPA output.</p> <p>Parameters:</p> Name Type Description Default <code>parsed_data</code> <code>dict[str, Any]</code> <p>Dictionary containing parsed RASPA data.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with adsorption data for each component.</p> Source code in <code>chmpy/fmt/raspa.py</code> <pre><code>def extract_adsorption_data(parsed_data: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"\n    Extract adsorption data from parsed RASPA output.\n\n    Args:\n        parsed_data: Dictionary containing parsed RASPA data.\n\n    Returns:\n        Dictionary with adsorption data for each component.\n    \"\"\"\n    # For JSON data\n    if \"properties\" in parsed_data and \"loadings\" in parsed_data[\"properties\"]:\n        return parsed_data[\"properties\"][\"loadings\"]\n\n    # For text output\n    if \"adsorption\" in parsed_data:\n        return parsed_data[\"adsorption\"]\n\n    return {}\n</code></pre>"},{"location":"reference/chmpy/fmt/raspa/#chmpy.fmt.raspa.extract_energy_data","title":"<code>extract_energy_data(parsed_data)</code>","text":"<p>Extract energy data from parsed RASPA output.</p> <p>Parameters:</p> Name Type Description Default <code>parsed_data</code> <code>dict[str, Any]</code> <p>Dictionary containing parsed RASPA data.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with energy components.</p> Source code in <code>chmpy/fmt/raspa.py</code> <pre><code>def extract_energy_data(parsed_data: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"\n    Extract energy data from parsed RASPA output.\n\n    Args:\n        parsed_data: Dictionary containing parsed RASPA data.\n\n    Returns:\n        Dictionary with energy components.\n    \"\"\"\n    # For JSON data\n    if \"output\" in parsed_data and \"runningEnergies\" in parsed_data[\"output\"]:\n        return parsed_data[\"output\"][\"runningEnergies\"]\n\n    # For text output\n    if \"energy\" in parsed_data:\n        return parsed_data[\"energy\"]\n\n    return {}\n</code></pre>"},{"location":"reference/chmpy/fmt/raspa/#chmpy.fmt.raspa.extract_enthalpy_data","title":"<code>extract_enthalpy_data(parsed_data)</code>","text":"<p>Extract enthalpy of adsorption data from parsed RASPA output.</p> <p>Parameters:</p> Name Type Description Default <code>parsed_data</code> <code>dict[str, Any]</code> <p>Dictionary containing parsed RASPA data.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with enthalpy data for each component.</p> Source code in <code>chmpy/fmt/raspa.py</code> <pre><code>def extract_enthalpy_data(parsed_data: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"\n    Extract enthalpy of adsorption data from parsed RASPA output.\n\n    Args:\n        parsed_data: Dictionary containing parsed RASPA data.\n\n    Returns:\n        Dictionary with enthalpy data for each component.\n    \"\"\"\n    # For JSON data\n    if \"properties\" in parsed_data and \"averageEnthalpy\" in parsed_data[\"properties\"]:\n        enthalpy_data = {}\n        for comp_name, data in parsed_data[\"properties\"][\"averageEnthalpy\"].items():\n            if \"mean\" in data:\n                enthalpy_data[comp_name] = data[\"mean\"]\n        return enthalpy_data\n\n    # For text output\n    if \"enthalpy\" in parsed_data:\n        return parsed_data[\"enthalpy\"]\n\n    return {}\n</code></pre>"},{"location":"reference/chmpy/fmt/raspa/#chmpy.fmt.raspa.parse_adsorption_data","title":"<code>parse_adsorption_data(content)</code>","text":"<p>Parse adsorption data from RASPA output content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Text content of the RASPA output file.</p> required <p>Returns:</p> Type Description <code>dict[str, dict[str, dict[str, float]]]</code> <p>Dictionary with adsorption data for each component.</p> Source code in <code>chmpy/fmt/raspa.py</code> <pre><code>def parse_adsorption_data(content: str) -&gt; dict[str, dict[str, dict[str, float]]]:\n    \"\"\"\n    Parse adsorption data from RASPA output content.\n\n    Args:\n        content: Text content of the RASPA output file.\n\n    Returns:\n        Dictionary with adsorption data for each component.\n    \"\"\"\n    adsorption_data = {}\n\n    # Find the last cycle section which contains the final results\n    cycles = list(re.finditer(r\"Current cycle: (\\d+) out of \\d+\", content))\n    if not cycles:\n        return adsorption_data\n\n    last_cycle_match = cycles[-1]\n    last_cycle_pos = last_cycle_match.start()\n    last_cycle_data = content[last_cycle_pos:]\n\n    # Extract component names\n    component_matches = re.findall(r\"Component\\s+\\d+\\s+\\[(.*?)\\]\", last_cycle_data)\n    for component in component_matches:\n        component = component.strip()\n        adsorption_data[component] = {\"absolute\": {}, \"excess\": {}}\n\n    # Find adsorption data sections\n    # Pattern matches \"absolute adsorption:\" followed by data, then \"excess adsorption:\" and data\n    adsorption_pattern = (\n        r\"absolute adsorption:\\s+(\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\\s+molecules.*?\"\n        + r\"(\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\\s+mol/kg.*?\"\n        + r\"(\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\\s+mg/g.*?\"\n        + r\"excess adsorption:\\s+(\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\\s+molecules.*?\"\n        + r\"(\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\\s+mol/kg.*?\"\n        + r\"(\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\\s+mg/g\"\n    )\n\n    adsorption_matches = re.findall(adsorption_pattern, last_cycle_data, re.DOTALL)\n\n    if adsorption_matches and component_matches:\n        for i, component in enumerate(component_matches):\n            if i &lt; len(adsorption_matches):\n                component = component.strip()\n                abs_mol, abs_mol_kg, abs_mg_g, exc_mol, exc_mol_kg, exc_mg_g = (\n                    adsorption_matches[i]\n                )\n\n                adsorption_data[component][\"absolute\"] = {\n                    \"molecules\": float(abs_mol),\n                    \"mol_per_kg\": float(abs_mol_kg),\n                    \"mg_per_g\": float(abs_mg_g),\n                }\n\n                adsorption_data[component][\"excess\"] = {\n                    \"molecules\": float(exc_mol),\n                    \"mol_per_kg\": float(exc_mol_kg),\n                    \"mg_per_g\": float(exc_mg_g),\n                }\n\n    return adsorption_data\n</code></pre>"},{"location":"reference/chmpy/fmt/raspa/#chmpy.fmt.raspa.parse_energy_data","title":"<code>parse_energy_data(content)</code>","text":"<p>Parse energy data from RASPA output content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Text content of the RASPA output file.</p> required <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>Dictionary with energy components.</p> Source code in <code>chmpy/fmt/raspa.py</code> <pre><code>def parse_energy_data(content: str) -&gt; dict[str, float]:\n    \"\"\"\n    Parse energy data from RASPA output content.\n\n    Args:\n        content: Text content of the RASPA output file.\n\n    Returns:\n        Dictionary with energy components.\n    \"\"\"\n    energy_data = {}\n\n    # Find the last cycle section which contains the final results\n    cycles = list(re.finditer(r\"Current cycle: (\\d+) out of \\d+\", content))\n    if not cycles:\n        return energy_data\n\n    last_cycle_match = cycles[-1]\n    last_cycle_pos = last_cycle_match.start()\n    last_cycle_data = content[last_cycle_pos:]\n\n    # Extract total energy\n    total_energy_match = re.search(\n        r\"Total potential energy/k\u0299\\s+(-?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\\s+\\((.*?)\\)\\s+\\[K\\]\",\n        last_cycle_data,\n        re.DOTALL,\n    )\n\n    if total_energy_match:\n        energy_data[\"total_potential\"] = float(total_energy_match.group(1))\n\n        # Extract energy components\n        energy_components = re.findall(\n            r\"([\\w\\s\\(\\)-]+)/k\u0299\\s+(-?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\\s+\\((.*?)\\)\\s+\\[K\\]\",\n            last_cycle_data,\n        )\n\n        for comp_name, value, _avg_value in energy_components:\n            comp_name = comp_name.strip()\n            if comp_name != \"Total potential energy\":  # Already captured\n                energy_data[comp_name.lower().replace(\" \", \"_\")] = float(value)\n\n    return energy_data\n</code></pre>"},{"location":"reference/chmpy/fmt/raspa/#chmpy.fmt.raspa.parse_enthalpy_data","title":"<code>parse_enthalpy_data(content)</code>","text":"<p>Parse enthalpy of adsorption data from RASPA output content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Text content of the RASPA output file.</p> required <p>Returns:</p> Type Description <code>dict[str, dict[str, float]]</code> <p>Dictionary with enthalpy data for each component.</p> Source code in <code>chmpy/fmt/raspa.py</code> <pre><code>def parse_enthalpy_data(content: str) -&gt; dict[str, dict[str, float]]:\n    \"\"\"\n    Parse enthalpy of adsorption data from RASPA output content.\n\n    Args:\n        content: Text content of the RASPA output file.\n\n    Returns:\n        Dictionary with enthalpy data for each component.\n    \"\"\"\n    enthalpy_data = {}\n\n    # Extract component enthalpy sections\n    enthalpy_pattern = r\"Component\\s+\\d+\\s+\\[(.*?)\\].*?Enthalpy of adsorption:\\s+(-?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\\s+\\+/-\\s+(-?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\\s+\\[K\\]\"\n    enthalpy_matches = re.findall(enthalpy_pattern, content, re.DOTALL)\n\n    for comp_name, value, error in enthalpy_matches:\n        comp_name = comp_name.strip()\n        enthalpy_data[comp_name] = {\"value\": float(value), \"error\": float(error)}\n\n    return enthalpy_data\n</code></pre>"},{"location":"reference/chmpy/fmt/raspa/#chmpy.fmt.raspa.parse_output_directory","title":"<code>parse_output_directory(directory_path)</code>","text":"<p>Parse all RASPA output files in a directory.</p> <p>Parameters:</p> Name Type Description Default <code>directory_path</code> <code>str | Path</code> <p>Path to the directory containing RASPA output files.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with parsed data from all files.</p> Source code in <code>chmpy/fmt/raspa.py</code> <pre><code>def parse_output_directory(directory_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"\n    Parse all RASPA output files in a directory.\n\n    Args:\n        directory_path: Path to the directory containing RASPA output files.\n\n    Returns:\n        Dictionary with parsed data from all files.\n    \"\"\"\n    directory_path = Path(directory_path)\n\n    result = {\"text_outputs\": {}, \"json_outputs\": {}}\n\n    # Look for .txt files\n    txt_files = list(directory_path.glob(\"*.txt\"))\n    for txt_file in txt_files:\n        try:\n            result[\"text_outputs\"][txt_file.name] = parse_raspa_txt(txt_file)\n        except Exception as e:\n            print(f\"Error parsing {txt_file}: {e}\")\n\n    # Look for .json files\n    json_files = list(directory_path.glob(\"*.json\"))\n    for json_file in json_files:\n        try:\n            result[\"json_outputs\"][json_file.name] = parse_raspa_json(json_file)\n        except Exception as e:\n            print(f\"Error parsing {json_file}: {e}\")\n\n    return result\n</code></pre>"},{"location":"reference/chmpy/fmt/raspa/#chmpy.fmt.raspa.parse_pressure_data","title":"<code>parse_pressure_data(content)</code>","text":"<p>Parse pressure data from RASPA output content.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Text content of the RASPA output file.</p> required <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>Dictionary with pressure data.</p> Source code in <code>chmpy/fmt/raspa.py</code> <pre><code>def parse_pressure_data(content: str) -&gt; dict[str, float]:\n    \"\"\"\n    Parse pressure data from RASPA output content.\n\n    Args:\n        content: Text content of the RASPA output file.\n\n    Returns:\n        Dictionary with pressure data.\n    \"\"\"\n    pressure_data = {}\n\n    # Find the last cycle section which contains the final results\n    cycles = list(re.finditer(r\"Current cycle: (\\d+) out of \\d+\", content))\n    if not cycles:\n        return pressure_data\n\n    last_cycle_match = cycles[-1]\n    last_cycle_pos = last_cycle_match.start()\n    last_cycle_data = content[last_cycle_pos:]\n\n    # Extract pressure data\n    pressure_match = re.search(\n        r\"Ideal-gas pressure:\\s+(-?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\\s+\\+/\\s+.*?\\s+\\[bar\\]\\s+\"\n        r\"Excess pressure:\\s+(-?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\\s+\\+/\\s+.*?\\s+\\[bar\\]\\s+\"\n        r\"Pressure:\\s+(-?\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\\s+\\+/\\s+.*?\\s+\\[bar\\]\",\n        last_cycle_data,\n        re.DOTALL,\n    )\n\n    if pressure_match:\n        pressure_data[\"ideal_gas\"] = float(pressure_match.group(1))\n        pressure_data[\"excess\"] = float(pressure_match.group(2))\n        pressure_data[\"total\"] = float(pressure_match.group(3))\n\n    return pressure_data\n</code></pre>"},{"location":"reference/chmpy/fmt/raspa/#chmpy.fmt.raspa.parse_raspa_json","title":"<code>parse_raspa_json(file_path)</code>","text":"<p>Parse a RASPA3 JSON output file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str | Path</code> <p>Path to the JSON output file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing the parsed data.</p> Source code in <code>chmpy/fmt/raspa.py</code> <pre><code>def parse_raspa_json(file_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"\n    Parse a RASPA3 JSON output file.\n\n    Args:\n        file_path: Path to the JSON output file.\n\n    Returns:\n        Dictionary containing the parsed data.\n    \"\"\"\n    file_path = Path(file_path)\n\n    with open(file_path) as f:\n        data = json.load(f)\n\n    return data\n</code></pre>"},{"location":"reference/chmpy/fmt/raspa/#chmpy.fmt.raspa.parse_raspa_txt","title":"<code>parse_raspa_txt(file_path)</code>","text":"<p>Parse a RASPA3 text output file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str | Path</code> <p>Path to the text output file.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing structured parsed data.</p> Source code in <code>chmpy/fmt/raspa.py</code> <pre><code>def parse_raspa_txt(file_path: str | Path) -&gt; dict[str, Any]:\n    \"\"\"\n    Parse a RASPA3 text output file.\n\n    Args:\n        file_path: Path to the text output file.\n\n    Returns:\n        Dictionary containing structured parsed data.\n    \"\"\"\n    file_path = Path(file_path)\n\n    with open(file_path) as f:\n        content = f.read()\n\n    # Extract basic information\n    result = {\n        \"general\": {},\n        \"adsorption\": {},\n        \"energy\": {},\n        \"pressure\": {},\n        \"enthalpy\": {},\n    }\n\n    # Extract version\n    version_match = re.search(r\"RASPA\\s+(\\d+\\.\\d+\\.\\d+)\", content)\n    if version_match:\n        result[\"general\"][\"version\"] = version_match.group(1)\n\n    # Extract temperature and pressure\n    temp_match = re.search(r\"Temperature:\\s+(\\d+(?:\\.\\d+)?)\\s+\\[K\\]\", content)\n    pressure_match = re.search(\n        r\"Pressure:\\s+(\\d+(?:\\.\\d+)?(?:[eE][+-]?\\d+)?)\\s+\\[Pa\\]\", content\n    )\n    if temp_match:\n        result[\"general\"][\"temperature\"] = float(temp_match.group(1))\n    if pressure_match:\n        result[\"general\"][\"pressure\"] = float(pressure_match.group(1))\n\n    # Parse specific data sections\n    result[\"adsorption\"] = parse_adsorption_data(content)\n    result[\"energy\"] = parse_energy_data(content)\n    result[\"pressure\"] = parse_pressure_data(content)\n    result[\"enthalpy\"] = parse_enthalpy_data(content)\n\n    return result\n</code></pre>"},{"location":"reference/chmpy/fmt/sdf/","title":"sdf","text":""},{"location":"reference/chmpy/fmt/shelx/","title":"shelx","text":""},{"location":"reference/chmpy/fmt/shelx/#chmpy.fmt.shelx.parse_shelx_file","title":"<code>parse_shelx_file(filename)</code>","text":"<p>Read a SHELX formatted .res file. Parameters</p> <p>filename: str     path to the shelx .res file to read</p>"},{"location":"reference/chmpy/fmt/shelx/#chmpy.fmt.shelx.parse_shelx_file--returns","title":"Returns","text":"<p>dict     dictionary of parsed shelx data</p> Source code in <code>chmpy/fmt/shelx.py</code> <pre><code>def parse_shelx_file(filename):\n    \"\"\"Read a SHELX formatted .res file.\n    Parameters\n    ----------\n    filename: str\n        path to the shelx .res file to read\n\n    Returns\n    -------\n    dict\n        dictionary of parsed shelx data\n    \"\"\"\n    return parse_shelx_file_content(Path(filename).read_text())\n</code></pre>"},{"location":"reference/chmpy/fmt/shelx/#chmpy.fmt.shelx.parse_shelx_file_content","title":"<code>parse_shelx_file_content(file_content)</code>","text":"<p>Read a SHELX formatted crystal structure from a string Parameters</p> <p>file_content: str     text contents of the SHELX .res file to read</p>"},{"location":"reference/chmpy/fmt/shelx/#chmpy.fmt.shelx.parse_shelx_file_content--returns","title":"Returns","text":"<p>dict     dictionary of parsed shelx data</p> Source code in <code>chmpy/fmt/shelx.py</code> <pre><code>def parse_shelx_file_content(file_content):\n    \"\"\"Read a SHELX formatted crystal structure from\n    a string\n    Parameters\n    ----------\n    file_content: str\n        text contents of the SHELX .res file to read\n\n    Returns\n    -------\n    dict\n        dictionary of parsed shelx data\n    \"\"\"\n    contents = file_content.split(\"\\n\")\n    shelx_dict = {\"SYMM\": [SymmetryOperation.from_string_code(\"x,y,z\")], \"ATOM\": []}\n    for line_number, line in enumerate(contents, start=1):\n        try:\n            line = line.strip()\n            if not line:\n                continue\n            key = line[:4].upper()\n            if key == \"END\":\n                break\n            elif key == \"SYMM\":\n                shelx_dict[key].append(SHELX_LINE_KEYS[key](line))\n            elif key not in SHELX_LINE_KEYS:\n                shelx_dict[\"ATOM\"].append(_parse_atom_line(shelx_dict[\"SFAC\"], line))\n            else:\n                f = SHELX_LINE_KEYS[key]\n                if f is None:\n                    continue\n                shelx_dict[key] = f(line)\n        except Exception as e:\n            raise ValueError(f\"Error parsing shelx string: line {line_number}\") from e\n    return shelx_dict\n</code></pre>"},{"location":"reference/chmpy/fmt/shelx/#chmpy.fmt.shelx.to_res_contents","title":"<code>to_res_contents(shelx_data)</code>","text":""},{"location":"reference/chmpy/fmt/shelx/#chmpy.fmt.shelx.to_res_contents--parameters","title":"Parameters","text":"<p>shelx_data: dict     dictionary of data to write into a SHELX .res format</p>"},{"location":"reference/chmpy/fmt/shelx/#chmpy.fmt.shelx.to_res_contents--returns","title":"Returns","text":"<p>str     the string encoded contents of this shelx_data</p> Source code in <code>chmpy/fmt/shelx.py</code> <pre><code>def to_res_contents(shelx_data):\n    \"\"\"\n    Parameters\n    ----------\n    shelx_data: dict\n        dictionary of data to write into a SHELX .res format\n\n    Returns\n    -------\n    str\n        the string encoded contents of this shelx_data\n    \"\"\"\n    SHELX_FORMATTERS = {\n        \"TITL\": lambda x: f\"TITL {x}\",\n        \"CELL\": _cell_string,\n        \"LATT\": lambda x: f\"LATT {x}\",\n        \"SYMM\": lambda symm: \"\\n\".join(f\"SYMM {x}\" for x in symm),\n        \"SFAC\": lambda x: \"SFAC \" + \" \".join(x),\n        \"ATOM\": _atom_lines,\n    }\n    sections = []\n    for key in SHELX_FORMATTERS:\n        sections.append(SHELX_FORMATTERS[key](shelx_data[key]))\n    return \"\\n\".join(sections)\n</code></pre>"},{"location":"reference/chmpy/fmt/smiles/","title":"smiles","text":""},{"location":"reference/chmpy/fmt/tmol/","title":"tmol","text":""},{"location":"reference/chmpy/fmt/tmol/#chmpy.fmt.tmol.parse_tmol_file","title":"<code>parse_tmol_file(filename)</code>","text":"<p>Convert a provided turbomole coord file into an array of atomic numbers and cartesian positions</p>"},{"location":"reference/chmpy/fmt/tmol/#chmpy.fmt.tmol.parse_tmol_file--parameters","title":"Parameters","text":"<p>filename: str     path to the turbomole file to read</p>"},{"location":"reference/chmpy/fmt/tmol/#chmpy.fmt.tmol.parse_tmol_file--returns","title":"Returns","text":"<p>tuple of :obj:<code>np.ndarray</code>     array of (N) atomic numbers and (N, 3) Cartesian positions     read from the given file</p> Source code in <code>chmpy/fmt/tmol.py</code> <pre><code>def parse_tmol_file(filename):\n    \"\"\"Convert a provided turbomole coord file into an array of\n    atomic numbers and cartesian positions\n\n    Parameters\n    ----------\n    filename: str\n        path to the turbomole file to read\n\n    Returns\n    -------\n    tuple of :obj:`np.ndarray`\n        array of (N) atomic numbers and (N, 3) Cartesian positions\n        read from the given file\n    \"\"\"\n    path = Path(filename)\n    return parse_tmol_string(path.read_text(), filename=str(path.absolute()))\n</code></pre>"},{"location":"reference/chmpy/fmt/tmol/#chmpy.fmt.tmol.parse_tmol_string","title":"<code>parse_tmol_string(contents, filename=None)</code>","text":"<p>Convert provided turbomole coord file contents into an array of atomic numbers and cartesian positions</p>"},{"location":"reference/chmpy/fmt/tmol/#chmpy.fmt.tmol.parse_tmol_string--parameters","title":"Parameters","text":"<p>contents: str     text contents of the .xyz file to read</p>"},{"location":"reference/chmpy/fmt/tmol/#chmpy.fmt.tmol.parse_tmol_string--returns","title":"Returns","text":"<p>tuple of :obj:<code>np.ndarray</code>     array of (N) atomic numbers and (N, 3) Cartesian positions     read from the given file</p> Source code in <code>chmpy/fmt/tmol.py</code> <pre><code>def parse_tmol_string(contents, filename=None):\n    \"\"\"Convert provided turbomole coord file contents into an array of\n    atomic numbers and cartesian positions\n\n    Parameters\n    ----------\n    contents: str\n        text contents of the .xyz file to read\n\n    Returns\n    -------\n    tuple of :obj:`np.ndarray`\n        array of (N) atomic numbers and (N, 3) Cartesian positions\n        read from the given file\n    \"\"\"\n    lines = contents.splitlines()\n    angstroms = \"angs\" in lines[0]\n    elements = []\n    positions = []\n    for line in lines[1:]:\n        stripped = line.strip()\n        if (not stripped) or \"$end\" in line:\n            break\n        if \"$\" in line:\n            continue\n        tokens = line.strip().split()\n        xyz = tuple(float(x) for x in tokens[:3])\n        positions.append(xyz)\n        elements.append(Element[tokens[3]])\n    LOG.debug(\n        \"Found %d atoms lines in %s\",\n        len(elements),\n        \"in \" + filename if filename else \"\",\n    )\n    positions = np.array(positions)\n    if not angstroms:\n        from chmpy.util.unit import units\n\n        positions = units.angstrom(positions)\n    return elements, positions\n</code></pre>"},{"location":"reference/chmpy/fmt/vasp/","title":"vasp","text":""},{"location":"reference/chmpy/fmt/vasp/#chmpy.fmt.vasp.parse_poscar","title":"<code>parse_poscar(poscar_string)</code>","text":"<p>Read in a VASP POSCAR or CONTCAR file</p> Source code in <code>chmpy/fmt/vasp.py</code> <pre><code>def parse_poscar(poscar_string):\n    \"Read in a VASP POSCAR or CONTCAR file\"\n    result = {\n        \"name\": None,\n        \"direct\": None,\n        \"elements\": None,\n        \"positions\": None,\n    }\n    lines = poscar_string.splitlines()\n    result[\"name\"] = lines[0].strip()\n    scale_factor = float(lines[1])\n    result[\"direct\"] = scale_factor * np.fromstring(\n        \" \".join(lines[2:5]), sep=\" \"\n    ).reshape((3, 3))\n    elements = []\n    for el, x in zip(lines[5].split(), lines[6].split(), strict=False):\n        elements += [Element[el]] * int(x)\n    result[\"elements\"] = elements\n    result[\"coord_type\"] = lines[7].strip().lower()\n    N = len(elements)\n    result[\"positions\"] = np.fromstring(\" \".join(lines[8 : 8 + N]), sep=\" \").reshape(\n        (-1, 3)\n    )\n    return result\n</code></pre>"},{"location":"reference/chmpy/fmt/xtb/","title":"xtb","text":""},{"location":"reference/chmpy/fmt/xyz_file/","title":"xyz_file","text":""},{"location":"reference/chmpy/fmt/xyz_file/#chmpy.fmt.xyz_file.parse_traj_file","title":"<code>parse_traj_file(filename)</code>","text":"<p>Convert a provided xmol .xyz file into an array of atomic numbers and cartesian positions</p>"},{"location":"reference/chmpy/fmt/xyz_file/#chmpy.fmt.xyz_file.parse_traj_file--parameters","title":"Parameters","text":"<p>filename: str     path to the .xyz file to read</p>"},{"location":"reference/chmpy/fmt/xyz_file/#chmpy.fmt.xyz_file.parse_traj_file--returns","title":"Returns","text":"<p>tuple of :obj:<code>np.ndarray</code>     array of (N) atomic numbers and (N, 3) Cartesian positions     read from the given file</p> Source code in <code>chmpy/fmt/xyz_file.py</code> <pre><code>def parse_traj_file(filename):\n    \"\"\"Convert a provided xmol .xyz file into an array of\n    atomic numbers and cartesian positions\n\n    Parameters\n    ----------\n    filename: str\n        path to the .xyz file to read\n\n    Returns\n    -------\n    tuple of :obj:`np.ndarray`\n        array of (N) atomic numbers and (N, 3) Cartesian positions\n        read from the given file\n    \"\"\"\n    path = Path(filename)\n    return parse_traj_string(path.read_text(), filename=str(path.absolute()))\n</code></pre>"},{"location":"reference/chmpy/fmt/xyz_file/#chmpy.fmt.xyz_file.parse_traj_string","title":"<code>parse_traj_string(contents, filename=None)</code>","text":"<p>Convert provided xmol .xyz file contents into list of arrays of atomic numbers and cartesian positions</p>"},{"location":"reference/chmpy/fmt/xyz_file/#chmpy.fmt.xyz_file.parse_traj_string--parameters","title":"Parameters","text":"<p>contents: str     text contents of the .xyz file to read</p>"},{"location":"reference/chmpy/fmt/xyz_file/#chmpy.fmt.xyz_file.parse_traj_string--returns","title":"Returns","text":"<p>list of tuple of :obj:<code>np.ndarray</code>     list of (N) :obj:<code>Element</code> and (N, 3) Cartesian positions     read from the given file</p> Source code in <code>chmpy/fmt/xyz_file.py</code> <pre><code>def parse_traj_string(contents, filename=None):\n    \"\"\"Convert provided xmol .xyz file contents into list of arrays of\n    atomic numbers and cartesian positions\n\n    Parameters\n    ----------\n    contents: str\n        text contents of the .xyz file to read\n\n    Returns\n    -------\n    list of tuple of :obj:`np.ndarray`\n        list of (N) :obj:`Element` and (N, 3) Cartesian positions\n        read from the given file\n    \"\"\"\n    lines = contents.splitlines()\n    i = 0\n    frames = []\n    while i &lt; len(lines):\n        natom = int(lines[i].strip())\n        elements = []\n        positions = []\n        i += 1\n        comment = lines[i]\n        i += 1\n        for line in lines[i : i + natom]:\n            if not line.strip():\n                continue\n            tokens = line.strip().split()\n            xyz = tuple(float(x) for x in tokens[1:4])\n            positions.append(xyz)\n            elements.append(Element[tokens[0]])\n        frames.append((elements, comment, np.asarray(positions)))\n        i += natom\n    return frames\n</code></pre>"},{"location":"reference/chmpy/fmt/xyz_file/#chmpy.fmt.xyz_file.parse_xyz_file","title":"<code>parse_xyz_file(filename)</code>","text":"<p>Convert a provided xmol .xyz file into an array of atomic numbers and cartesian positions</p>"},{"location":"reference/chmpy/fmt/xyz_file/#chmpy.fmt.xyz_file.parse_xyz_file--parameters","title":"Parameters","text":"<p>filename: str     path to the .xyz file to read</p>"},{"location":"reference/chmpy/fmt/xyz_file/#chmpy.fmt.xyz_file.parse_xyz_file--returns","title":"Returns","text":"<p>tuple of :obj:<code>np.ndarray</code>     array of (N) atomic numbers and (N, 3) Cartesian positions     read from the given file</p> Source code in <code>chmpy/fmt/xyz_file.py</code> <pre><code>def parse_xyz_file(filename):\n    \"\"\"Convert a provided xmol .xyz file into an array of\n    atomic numbers and cartesian positions\n\n    Parameters\n    ----------\n    filename: str\n        path to the .xyz file to read\n\n    Returns\n    -------\n    tuple of :obj:`np.ndarray`\n        array of (N) atomic numbers and (N, 3) Cartesian positions\n        read from the given file\n    \"\"\"\n    path = Path(filename)\n    return parse_xyz_string(path.read_text(), filename=str(path.absolute()))\n</code></pre>"},{"location":"reference/chmpy/fmt/xyz_file/#chmpy.fmt.xyz_file.parse_xyz_string","title":"<code>parse_xyz_string(contents, filename=None)</code>","text":"<p>Convert provided xmol .xyz file contents into an array of atomic numbers and cartesian positions</p>"},{"location":"reference/chmpy/fmt/xyz_file/#chmpy.fmt.xyz_file.parse_xyz_string--parameters","title":"Parameters","text":"<p>contents: str     text contents of the .xyz file to read</p>"},{"location":"reference/chmpy/fmt/xyz_file/#chmpy.fmt.xyz_file.parse_xyz_string--returns","title":"Returns","text":"<p>tuple of :obj:<code>np.ndarray</code>     array of (N) atomic numbers and (N, 3) Cartesian positions     read from the given file</p> Source code in <code>chmpy/fmt/xyz_file.py</code> <pre><code>def parse_xyz_string(contents, filename=None):\n    \"\"\"Convert provided xmol .xyz file contents into an array of\n    atomic numbers and cartesian positions\n\n    Parameters\n    ----------\n    contents: str\n        text contents of the .xyz file to read\n\n    Returns\n    -------\n    tuple of :obj:`np.ndarray`\n        array of (N) atomic numbers and (N, 3) Cartesian positions\n        read from the given file\n    \"\"\"\n    lines = contents.splitlines()\n    natom = int(lines[0].strip())\n    LOG.debug(\"Expecting %d atoms %s\", natom, \"in \" + filename if filename else \"\")\n    elements = []\n    positions = []\n    for line in lines[2:]:\n        if not line.strip():\n            break\n        tokens = line.strip().split()\n        xyz = tuple(float(x) for x in tokens[1:4])\n        positions.append(xyz)\n        elements.append(Element[tokens[0]])\n    LOG.debug(\n        \"Found %d atoms lines in %s\",\n        len(elements),\n        \"in \" + filename if filename else \"\",\n    )\n    return elements, np.asarray(positions)\n</code></pre>"},{"location":"reference/chmpy/interpolate/density/","title":"density","text":""},{"location":"reference/chmpy/interpolate/lerp/","title":"lerp","text":""},{"location":"reference/chmpy/ints/lebedev/","title":"lebedev","text":""},{"location":"reference/chmpy/ints/solvation/","title":"solvation","text":""},{"location":"reference/chmpy/mc/_mc/","title":"_mc","text":"<p>Marching cubes implementation of volumetric data.</p> <p>This file is a modification of the original _marching_cubes_lewiner.pyx file from the scikit-image project, retrieved from git revision:</p> <pre><code>129af33b9c118dd87efd4a39ce623e70f8188ce8\n</code></pre> <p>As such the following copyright notice must be included here, and we should include the acknowledgement in the LICENSE.txt of this project.</p> <p>Copyright (C) 2019, the scikit-image team All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <pre><code>1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in\n   the documentation and/or other materials provided with the\n   distribution.\n3. Neither the name of skimage nor the names of its contributors may be\n   used to endorse or promote products derived from this software without\n   specific prior written permission.\n</code></pre> <p>THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE), ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"reference/chmpy/mc/_mc/#chmpy.mc._mc.marching_cubes","title":"<code>marching_cubes(volume, level=None, spacing=(1.0, 1.0, 1.0), gradient_direction='descent', step_size=1, allow_degenerate=True, use_classic=False)</code>","text":"<p>Lewiner marching cubes algorithm to find surfaces in 3d volumetric data.</p> <p>In contrast to <code>marching_cubes_classic()</code>, this algorithm is faster, resolves ambiguities, and guarantees topologically correct results. Therefore, this algorithm generally a better choice, unless there is a specific need for the classic algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>volume</code> <p>(M, N, P) array Input data volume to find isosurfaces. Will internally be converted to float32 if necessary.</p> required <code>level</code> <p>float, optional Contour value to search for isosurfaces in <code>volume</code>. If not given or None, the average of the min and max of vol is used.</p> <code>None</code> <code>spacing</code> <p>length-3 tuple of floats, optional Voxel spacing in spatial dimensions corresponding to numpy array indexing dimensions (M, N, P) as in <code>volume</code>.</p> <code>(1.0, 1.0, 1.0)</code> <code>gradient_direction</code> <p>string, optional Controls if the mesh was generated from an isosurface with gradient descent toward objects of interest (the default), or the opposite, considering the left-hand rule. The two options are: * descent : Object was greater than exterior * ascent : Exterior was greater than object</p> <code>'descent'</code> <code>step_size</code> <p>int, optional Step size in voxels. Default 1. Larger steps yield faster but coarser results. The result will always be topologically correct though.</p> <code>1</code> <code>allow_degenerate</code> <p>bool, optional Whether to allow degenerate (i.e. zero-area) triangles in the end-result. Default True. If False, degenerate triangles are removed, at the cost of making the algorithm slower.</p> <code>True</code> <code>use_classic</code> <p>bool, optional If given and True, the classic marching cubes by Lorensen (1987) is used. This option is included for reference purposes. Note that this algorithm has ambiguities and is not guaranteed to produce a topologically correct result. The results with using this option are not generally the same as the <code>marching_cubes_classic()</code> function.</p> <code>False</code>"},{"location":"reference/chmpy/mc/_mc/#chmpy.mc._mc.marching_cubes--returns","title":"Returns","text":"<p>verts : (V, 3) array     Spatial coordinates for V unique mesh vertices. Coordinate order     matches input <code>volume</code> (M, N, P). faces : (F, 3) array     Define triangular faces via referencing vertex indices from <code>verts</code>.     This algorithm specifically outputs triangles, so each face has     exactly three indices. normals : (V, 3) array     The normal direction at each vertex, as calculated from the     data. values : (V, ) array     Gives a measure for the maximum value of the data in the local region     near each vertex. This can be used by visualization tools to apply     a colormap to the mesh.</p>"},{"location":"reference/chmpy/mc/_mc/#chmpy.mc._mc.marching_cubes--notes","title":"Notes","text":"<p>The algorithm [1] is an improved version of Chernyaev's Marching Cubes 33 algorithm. It is an efficient algorithm that relies on heavy use of lookup tables to handle the many different cases, keeping the algorithm relatively easy. This implementation is written in Cython, ported from Lewiner's C++ implementation.</p> <p>To quantify the area of an isosurface generated by this algorithm, pass verts and faces to <code>skimage.measure.mesh_surface_area</code>.</p>"},{"location":"reference/chmpy/mc/_mc/#chmpy.mc._mc.marching_cubes--references","title":"References","text":"<p>[1] Thomas Lewiner, Helio Lopes, Antonio Wilson Vieira and Geovan     Tavares. Efficient implementation of Marching Cubes' cases with     topological guarantees. Journal of Graphics Tools 8(2)     pp. 1-15 (Dec 2003).     https://dx.doi.org/10.1080/10867651.2003.10487582</p>"},{"location":"reference/chmpy/mc/_mc/#chmpy.mc._mc.marching_cubes--see-also","title":"See Also","text":"<p>skimage.measure.marching_cubes_classic skimage.measure.mesh_surface_area</p> Source code in <code>chmpy/mc/_mc.py</code> <pre><code>def marching_cubes(\n    volume,\n    level=None,\n    spacing=(1.0, 1.0, 1.0),\n    gradient_direction=\"descent\",\n    step_size=1,\n    allow_degenerate=True,\n    use_classic=False,\n):\n    \"\"\"Lewiner marching cubes algorithm to find surfaces in 3d volumetric data.\n\n    In contrast to ``marching_cubes_classic()``, this algorithm is faster,\n    resolves ambiguities, and guarantees topologically correct results.\n    Therefore, this algorithm generally a better choice, unless there\n    is a specific need for the classic algorithm.\n\n    Args:\n        volume: (M, N, P) array\n            Input data volume to find isosurfaces. Will internally be\n            converted to float32 if necessary.\n        level: float, optional\n            Contour value to search for isosurfaces in `volume`. If not\n            given or None, the average of the min and max of vol is used.\n        spacing: length-3 tuple of floats, optional\n            Voxel spacing in spatial dimensions corresponding to numpy array\n            indexing dimensions (M, N, P) as in `volume`.\n        gradient_direction: string, optional\n            Controls if the mesh was generated from an isosurface with gradient\n            descent toward objects of interest (the default), or the opposite,\n            considering the *left-hand* rule.\n            The two options are:\n            * descent : Object was greater than exterior\n            * ascent : Exterior was greater than object\n        step_size: int, optional\n            Step size in voxels. Default 1. Larger steps yield faster but\n            coarser results. The result will always be topologically correct\n            though.\n        allow_degenerate: bool, optional\n            Whether to allow degenerate (i.e. zero-area) triangles in the\n            end-result. Default True. If False, degenerate triangles are\n            removed, at the cost of making the algorithm slower.\n        use_classic: bool, optional\n            If given and True, the classic marching cubes by Lorensen (1987)\n            is used. This option is included for reference purposes. Note\n            that this algorithm has ambiguities and is not guaranteed to\n            produce a topologically correct result. The results with using\n            this option are *not* generally the same as the\n            ``marching_cubes_classic()`` function.\n\n    Returns\n    -------\n    verts : (V, 3) array\n        Spatial coordinates for V unique mesh vertices. Coordinate order\n        matches input `volume` (M, N, P).\n    faces : (F, 3) array\n        Define triangular faces via referencing vertex indices from ``verts``.\n        This algorithm specifically outputs triangles, so each face has\n        exactly three indices.\n    normals : (V, 3) array\n        The normal direction at each vertex, as calculated from the\n        data.\n    values : (V, ) array\n        Gives a measure for the maximum value of the data in the local region\n        near each vertex. This can be used by visualization tools to apply\n        a colormap to the mesh.\n\n    Notes\n    -----\n    The algorithm [1] is an improved version of Chernyaev's Marching\n    Cubes 33 algorithm. It is an efficient algorithm that relies on\n    heavy use of lookup tables to handle the many different cases,\n    keeping the algorithm relatively easy. This implementation is\n    written in Cython, ported from Lewiner's C++ implementation.\n\n    To quantify the area of an isosurface generated by this algorithm, pass\n    verts and faces to `skimage.measure.mesh_surface_area`.\n\n    References\n    ----------\n    [1] Thomas Lewiner, Helio Lopes, Antonio Wilson Vieira and Geovan\n        Tavares. Efficient implementation of Marching Cubes' cases with\n        topological guarantees. Journal of Graphics Tools 8(2)\n        pp. 1-15 (Dec 2003).\n        https://dx.doi.org/10.1080/10867651.2003.10487582\n\n    See Also\n    --------\n    skimage.measure.marching_cubes_classic\n    skimage.measure.mesh_surface_area\n    \"\"\"\n    # Check volume and ensure its in the format that the alg needs\n    if not isinstance(volume, np.ndarray) or (volume.ndim != 3):\n        raise ValueError(\"Input volume should be a 3D numpy array.\")\n    if volume.shape[0] &lt; 2 or volume.shape[1] &lt; 2 or volume.shape[2] &lt; 2:\n        raise ValueError(\"Input array must be at least 2x2x2.\")\n    volume = np.ascontiguousarray(volume, np.float32)  # no copy if not necessary\n\n    # Check/convert other inputs:\n    # level\n    if level is None:\n        level = 0.5 * (volume.min() + volume.max())\n    else:\n        level = float(level)\n        if level &lt; volume.min() or level &gt; volume.max():\n            raise ValueError(\"Surface level must be within volume data range.\")\n    # spacing\n    if len(spacing) != 3:\n        raise ValueError(\"`spacing` must consist of three floats.\")\n    # step_size\n    step_size = int(step_size)\n    if step_size &lt; 1:\n        raise ValueError(\"step_size must be at least one.\")\n    # use_classic\n    use_classic = bool(use_classic)\n\n    # Get LutProvider class (reuse if possible)\n    L = _get_lookup_tables()\n\n    # Apply algorithm\n    func = _marching_cubes\n    vertices, faces, normals, values = func(volume, level, L, step_size, use_classic)\n\n    if not len(vertices):\n        raise RuntimeError(\"No surface found at the given iso value.\")\n\n    # Output in z-y-x order, as is common in skimage\n    vertices = np.fliplr(vertices)\n    normals = np.fliplr(normals)\n\n    # Finishing touches to output\n    faces.shape = -1, 3\n    if gradient_direction == \"descent\":\n        # MC implementation is right-handed, but gradient_direction is left-handed\n        faces = np.fliplr(faces)\n    elif not gradient_direction == \"ascent\":\n        raise ValueError(\n            f\"Incorrect input {gradient_direction} in `gradient_direction`, see \"\n            \"docstring.\"\n        )\n    if not np.array_equal(spacing, (1, 1, 1)):\n        vertices = vertices * np.r_[spacing]\n\n    if allow_degenerate:\n        return vertices, faces, normals, values\n    else:\n        fun = remove_degenerate_faces\n        return fun(vertices.astype(np.float32), faces, normals, values)\n</code></pre>"},{"location":"reference/chmpy/mc/lookup_tables/","title":"lookup_tables","text":""},{"location":"reference/chmpy/opt/gulp/","title":"gulp","text":""},{"location":"reference/chmpy/opt/xtb/","title":"xtb","text":""},{"location":"reference/chmpy/shape/assoc_legendre/","title":"assoc_legendre","text":""},{"location":"reference/chmpy/shape/convex_hull/","title":"convex_hull","text":""},{"location":"reference/chmpy/shape/convex_hull/#chmpy.shape.convex_hull.ray_hull_intersections","title":"<code>ray_hull_intersections(directions, hull, method='fast')</code>","text":"<p>Find the distance from the origin to the intersection with the given ConvexHull for a list of directions. Assumes <code>directions</code> is a (N, 3) array of unit vectors representing directions, and <code>hull</code> is a <code>ConvexHull</code> object centered about the origin.</p> <p>Parameters:</p> Name Type Description Default <code>directions</code> <code>ndarray</code> <p>(N, 3) array of unit vectors</p> required <code>hull</code> <code>ConvexHull</code> <p>A ConvexHull for which to find intersections</p> required <p>Returns:</p> Type Description <p>np.ndarray: (N,) array of the distances for each intersection</p> Source code in <code>chmpy/shape/convex_hull.py</code> <pre><code>def ray_hull_intersections(directions, hull, method=\"fast\"):\n    \"\"\"\n    Find the distance from the origin to the intersection with the\n    given ConvexHull for a list of directions. Assumes `directions`\n    is a (N, 3) array of unit vectors representing directions, and\n    `hull` is a `ConvexHull` object centered about the origin.\n\n\n    Args:\n        directions (np.ndarray): (N, 3) array of unit vectors\n        hull (ConvexHull): A ConvexHull for which to find intersections\n\n\n    Returns:\n        np.ndarray: (N,) array of the distances for each intersection\n    \"\"\"\n    if method == \"fast\":\n        return _ray_hull_intersections_batch(directions, hull)\n    else:\n        return np.array([_ray_hull_intersection(p, hull) for p in directions])\n</code></pre>"},{"location":"reference/chmpy/shape/convex_hull/#chmpy.shape.convex_hull.transform_hull","title":"<code>transform_hull(sht, hull, **kwargs)</code>","text":"<p>Calculate the spherical harmonic transform of the shape of the provided convex hull</p> <p>Parameters:</p> Name Type Description Default <code>sht</code> <code>SHT</code> <p>the spherical harmonic transform object handle</p> required <code>n_i</code> <code>ConvexHull</code> <p>the convex hull (or shape to describe)</p> required <code>kwargs</code> <code>dict</code> <p>keyword arguments for optional settings. Options include: <pre><code>origin (np.ndarray): specify the center of the surface\n    (default is the geometric centroid of the interior atoms)\n</code></pre> distances (bool): also return the distances of intersection</p> <code>{}</code> <p>Returns:</p> Type Description <p>np.ndarray: the coefficients from the analysis step of the SHT</p> Source code in <code>chmpy/shape/convex_hull.py</code> <pre><code>def transform_hull(sht, hull, **kwargs):\n    \"\"\"\n    Calculate the spherical harmonic transform of the shape of the\n    provided convex hull\n\n    Args:\n        sht (SHT): the spherical harmonic transform object handle\n        n_i (ConvexHull): the convex hull (or shape to describe)\n        kwargs (dict): keyword arguments for optional settings.\n            Options include:\n            ```\n            origin (np.ndarray): specify the center of the surface\n                (default is the geometric centroid of the interior atoms)\n            ```\n            distances (bool): also return the distances of intersection\n\n    Returns:\n        np.ndarray: the coefficients from the analysis step of the SHT\n    \"\"\"\n\n    x, y, z = sht.grid_cartesian\n    directions = np.c_[x.flatten(), y.flatten(), z.flatten()]\n\n    r = ray_hull_intersections(directions, hull).reshape(x.shape)\n    coeffs = sht.analysis(r)\n    if kwargs.get(\"distances\", False):\n        return coeffs, r\n    else:\n        return coeffs\n</code></pre>"},{"location":"reference/chmpy/shape/reconstruct/","title":"reconstruct","text":""},{"location":"reference/chmpy/shape/shape_descriptors/","title":"shape_descriptors","text":""},{"location":"reference/chmpy/shape/shape_descriptors/#chmpy.shape.shape_descriptors.make_N_invariants","title":"<code>make_N_invariants(coefficients)</code>","text":"<p>Construct the <code>N</code> type invariants from SHT coefficients. If coefficients is of length n, the size of the result will be sqrt(n)</p> <p>Parameters:</p> Name Type Description Default <code>coefficients</code> <code>ndarray</code> <p>the set of spherical harmonic coefficients</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray the <code>N</code> type rotational invariants based on these coefficients</p> Source code in <code>chmpy/shape/shape_descriptors.py</code> <pre><code>def make_N_invariants(coefficients) -&gt; np.ndarray:\n    \"\"\"\n    Construct the `N` type invariants from SHT coefficients.\n    If coefficients is of length n, the size of the result will be sqrt(n)\n\n    Arguments:\n        coefficients (np.ndarray): the set of spherical harmonic coefficients\n\n    Returns:\n        np.ndarray the `N` type rotational invariants based on these coefficients\n    \"\"\"\n    size = int(np.sqrt(len(coefficients)))\n    invariants = np.empty(shape=(size), dtype=np.float64)\n    for i in range(0, size):\n        lower, upper = i**2, (i + 1) ** 2\n        invariants[i] = np.sum(\n            coefficients[lower : upper + 1] * np.conj(coefficients[lower : upper + 1])\n        ).real\n    return np.sqrt(invariants)\n</code></pre>"},{"location":"reference/chmpy/shape/shape_descriptors/#chmpy.shape.shape_descriptors.make_invariants","title":"<code>make_invariants(l_max, coefficients, kinds='NP')</code>","text":"<p>Construct the <code>N</code> and/or <code>P</code> type invariants from SHT coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>l_max</code> <code>int</code> <p>the maximum angular momentum of the coefficients</p> required <code>coefficients</code> <code>ndarray</code> <p>the set of spherical harmonic coefficients</p> required <code>kinds</code> <code>str</code> <p>which kinds of invariants to include</p> <code>'NP'</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray the <code>N</code> and/or <code>P</code> type rotational invariants based on these coefficients</p> Source code in <code>chmpy/shape/shape_descriptors.py</code> <pre><code>def make_invariants(l_max, coefficients, kinds=\"NP\") -&gt; np.ndarray:\n    \"\"\"\n    Construct the `N` and/or `P` type invariants from SHT coefficients.\n\n    Arguments:\n        l_max (int): the maximum angular momentum of the coefficients\n        coefficients (np.ndarray): the set of spherical harmonic coefficients\n        kinds (str, optional): which kinds of invariants to include\n\n    Returns:\n        np.ndarray the `N` and/or `P` type rotational invariants based on these\n            coefficients\n    \"\"\"\n\n    global _HAVE_WARNED_ABOUT_LMAX_P\n    invariants = []\n    if \"N\" in kinds:\n        invariants.append(make_N_invariants(coefficients))\n    if \"P\" in kinds:\n        # Because we only have factorial precision (double precision)\n        # in our clebsch implementation up to 70! l_max for P type\n        # invariants is restricted to &lt;= 23\n        # TODO use a better clebsch gordan coefficients implementation\n        # e.g. that in https://github.com/GXhelsinki/Clebsch-Gordan-Coefficients-\n        pfunc = p_invariants_c\n        MAX_L_MAX = 23\n        if l_max &gt; MAX_L_MAX:\n            if not _HAVE_WARNED_ABOUT_LMAX_P:\n                LOG.warn(\n                    f\"P type invariants only supported up to l_max = {MAX_L_MAX}: \"\n                    \"will only using N type invariants beyond that.\"\n                )\n                _HAVE_WARNED_ABOUT_LMAX_P = True\n            c = coefficients[: MAX_L_MAX * MAX_L_MAX]\n            invariants.append(pfunc(c))\n        else:\n            invariants.append(pfunc(coefficients))\n    return np.hstack(invariants)\n</code></pre>"},{"location":"reference/chmpy/shape/shape_descriptors/#chmpy.shape.shape_descriptors.promolecule_density_descriptor","title":"<code>promolecule_density_descriptor(sht, n_i, p_i, **kwargs)</code>","text":"<p>Calculate the shape description of the promolecule density isosurface.</p> <p>Parameters:</p> Name Type Description Default <code>sht</code> <code>SHT</code> <p>the spherical harmonic transform object handle</p> required <code>n_i</code> <code>ndarray</code> <p>atomic numbers of the atoms</p> required <code>p_i</code> <code>ndarray</code> <p>Cartesian coordinates of the atoms</p> required <code>**kwargs</code> <p>keyword arguments for optional settings.</p> <code>{}</code> <p>Keyword Args:     isovalue (float): change the Hirshfeld weight value (default 0.5)     with_property (str): calculate the combined shape + surface         property descriptor using the specified property on the         surface (e.g. d_norm, esp)     bounds (Tuple): modify the lower/upper bounds on the search for         the isovalue (default 0.1, 20.0)     coefficients (bool): also return the coefficients of the SHT     origin (np.ndarray): specify the center of the surface         (default is the geometric centroid of the atoms)     kinds (str): the kinds of invariants to calculate (default 'NP') Returns:     np.ndarray: the rotation invariant descriptors of the promolecule surface shape</p> Source code in <code>chmpy/shape/shape_descriptors.py</code> <pre><code>def promolecule_density_descriptor(sht, n_i, p_i, **kwargs):\n    \"\"\"\n    Calculate the shape description of the promolecule density isosurface.\n\n    Args:\n        sht (SHT): the spherical harmonic transform object handle\n        n_i (np.ndarray): atomic numbers of the atoms\n        p_i (np.ndarray): Cartesian coordinates of the atoms\n        **kwargs: keyword arguments for optional settings.\n    Keyword Args:\n        isovalue (float): change the Hirshfeld weight value (default 0.5)\n        with_property (str): calculate the combined shape + surface\n            property descriptor using the specified property on the\n            surface (e.g. d_norm, esp)\n        bounds (Tuple): modify the lower/upper bounds on the search for\n            the isovalue (default 0.1, 20.0)\n        coefficients (bool): also return the coefficients of the SHT\n        origin (np.ndarray): specify the center of the surface\n            (default is the geometric centroid of the atoms)\n        kinds (str): the kinds of invariants to calculate (default 'NP')\n    Returns:\n        np.ndarray: the rotation invariant descriptors of the promolecule surface shape\n    \"\"\"\n    isovalue = kwargs.get(\"isovalue\", 0.0002)\n    property_function = kwargs.get(\"with_property\", None)\n    r_min, r_max = kwargs.get(\"bounds\", (0.4, 20.0))\n    pro = PromoleculeDensity((n_i, p_i))\n    g = np.empty((sht.grid[0].size, 3), dtype=np.float32)\n    x, y, z = sht.grid_cartesian\n    g[:, 0] = x.flatten()\n    g[:, 1] = y.flatten()\n    g[:, 2] = z.flatten()\n\n    o = kwargs.get(\"origin\", np.mean(p_i, axis=0, dtype=np.float32))\n    r = sphere_promolecule_radii(\n        pro.dens, o, g, r_min, r_max, 1e-12, 30, isovalue\n    ).reshape(sht.grid[0].shape)\n    if np.any(r &lt; 0):\n        raise ValueError(\n            f\"Unable to find isovalue {isovalue:.2f} in all \"\n            f\"directions for bounds ({r_min:.2f}, {r_max:.2f})\"\n        )\n    real = True\n    if property_function is not None:\n        if property_function == \"d_norm\":\n\n            def property_function(x):\n                return pro.d_norm(x)[1]\n        elif property_function == \"esp\":\n            from chmpy import Molecule\n\n            els = pro.elements\n            pos = pro.positions\n            property_function = Molecule.from_arrays(els, pos).electrostatic_potential\n        r = _compute_property_in_j_channel(sht, r, property_function)\n        real = False\n    l_max = sht.lmax\n    coeffs = sht.analysis(r)\n    coeff4inv = expand_coeffs_to_full(l_max, coeffs) if real else coeffs\n    invariants = make_invariants(l_max, coeff4inv, kinds=kwargs.get(\"kinds\", \"NP\"))\n\n    if kwargs.get(\"coefficients\", False):\n        return coeffs, invariants\n    return invariants\n</code></pre>"},{"location":"reference/chmpy/shape/shape_descriptors/#chmpy.shape.shape_descriptors.stockholder_weight_descriptor","title":"<code>stockholder_weight_descriptor(sht, n_i, p_i, n_e, p_e, **kwargs)</code>","text":"<p>Calculate the 'stockholder weight' shape descriptors based on the Hirshfeld weight i.e. ratio of electron density from the 'interior' to the total electron density.</p> <p>Parameters:</p> Name Type Description Default <code>sht</code> <code>SHT</code> <p>the spherical harmonic transform object handle</p> required <code>n_i</code> <code>ndarray</code> <p>atomic numbers of the interior atoms</p> required <code>p_i</code> <code>ndarray</code> <p>Cartesian coordinates of the interior atoms</p> required <code>n_e</code> <code>ndarray</code> <p>atomic numbers of the exterior atoms</p> required <code>p_e</code> <code>ndarray</code> <p>Cartesian coordinates of the exterior atoms</p> required <p>Other Parameters:</p> Name Type Description <code>isovalue</code> <code>float</code> <p>change the Hirshfeld weight value (default 0.5)</p> <code>background</code> <code>float</code> <p>include an optional 'background' electron density (default 0.0)</p> <code>with_property</code> <code>str</code> <p>calculate the combined shape + surface property descriptor using the specified property on the surface (e.g. d_norm, esp)</p> <code>bounds</code> <code>Tuple</code> <p>modify the lower/upper bounds on the search for the isovalue (default 0.1, 20.0)</p> <code>coefficients</code> <code>bool</code> <p>also return the coefficients of the SHT</p> <code>origin</code> <code>ndarray</code> <p>specify the center of the surface (default is the geometric centroid of the interior atoms)</p> <code>kinds</code> <code>str</code> <p>the kinds of invariants to calculate (default 'NP')</p> <p>Returns:     np.ndarray: the rotation invariant descriptors of the Hirshfeld surface shape</p> Source code in <code>chmpy/shape/shape_descriptors.py</code> <pre><code>def stockholder_weight_descriptor(sht, n_i, p_i, n_e, p_e, **kwargs):\n    \"\"\"\n    Calculate the 'stockholder weight' shape descriptors based on the\n    Hirshfeld weight i.e. ratio of electron density from the 'interior'\n    to the total electron density.\n\n    Args:\n        sht (SHT): the spherical harmonic transform object handle\n        n_i (np.ndarray): atomic numbers of the interior atoms\n        p_i (np.ndarray): Cartesian coordinates of the interior atoms\n        n_e (np.ndarray): atomic numbers of the exterior atoms\n        p_e (np.ndarray): Cartesian coordinates of the exterior atoms\n\n    Keyword Args:\n        isovalue (float): change the Hirshfeld weight value (default 0.5)\n        background (float): include an optional 'background' electron\n            density (default 0.0)\n        with_property (str): calculate the combined shape + surface\n            property descriptor using the specified property on the\n            surface (e.g. d_norm, esp)\n        bounds (Tuple): modify the lower/upper bounds on the search for\n            the isovalue (default 0.1, 20.0)\n        coefficients (bool): also return the coefficients of the SHT\n        origin (np.ndarray): specify the center of the surface\n            (default is the geometric centroid of the interior atoms)\n        kinds (str): the kinds of invariants to calculate (default 'NP')\n    Returns:\n        np.ndarray: the rotation invariant descriptors of the Hirshfeld surface shape\n    \"\"\"\n    isovalue = kwargs.get(\"isovalue\", 0.5)\n    background = kwargs.get(\"background\", 0.0)\n    property_function = kwargs.get(\"with_property\", None)\n    r_min, r_max = kwargs.get(\"bounds\", (0.1, 20.0))\n    o = kwargs.get(\"origin\", np.mean(p_i, axis=0, dtype=np.float32))\n    s = StockholderWeight.from_arrays(n_i, p_i, n_e, p_e, background=background)\n    g = np.empty((sht.grid[0].size, 3), dtype=np.float32)\n    x, y, z = sht.grid_cartesian\n    g[:, 0] = x.flatten()\n    g[:, 1] = y.flatten()\n    g[:, 2] = z.flatten()\n\n    r = sphere_stockholder_radii(s.s, o, g, r_min, r_max, 1e-7, 30, isovalue).reshape(\n        sht.grid[0].shape\n    )\n    if np.any(r &lt; 0):\n        raise ValueError(\n            f\"Unable to find isovalue {isovalue:.2f} in all directions\"\n            f\"for bounds ({r_min:.2f}, {r_max:.2f})\"\n        )\n    real = True\n    if property_function is not None:\n        if property_function == \"d_norm\":\n\n            def property_function(x):\n                return s.d_norm(x)[3]\n        elif property_function == \"esp\":\n            from chmpy import Molecule\n\n            property_function = Molecule.from_arrays(\n                s.dens_a.elements, s.dens_a.positions\n            ).electrostatic_potential\n        r = _compute_property_in_j_channel(sht, r, property_function, origin=o)\n        real = False\n    l_max = sht.lmax\n    coeffs = sht.analysis(r)\n\n    coeff4inv = expand_coeffs_to_full(l_max, coeffs) if real else coeffs\n    invariants = make_invariants(l_max, coeff4inv, kinds=kwargs.get(\"kinds\", \"NP\"))\n\n    if kwargs.get(\"coefficients\", False):\n        return coeffs, invariants\n    return invariants\n</code></pre>"},{"location":"reference/chmpy/shape/sht/","title":"sht","text":""},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT","title":"<code>SHT</code>","text":"<p>A class to encapsulate the re-usable data for a Spherical Harmonic Transform (SHT).</p> <p>Attributes:</p> Name Type Description <code>lmax</code> <p>the maximum angular momentum of the SHT, affects grid size etc.</p> <code>plm</code> <p>class to evaluate associated Legendre polynomials</p> <code>nphi</code> <p>the number of phi angular grid points</p> <code>ntheta</code> <p>the number of theta angular grid points</p> <code>phi</code> <p>the phi angular grid points (equispaced) between [i, 2 \\pi]</p> <code>cos_theta</code> <p>cos values of the theta grid (evaluated as Gauss-Legendre quadrature points)</p> <code>weights</code> <p>the Gauss-Legendre grid weights</p> <code>theta</code> <p>the theta angular grid points (derived from cos_theta)</p> <code>fft_work_array</code> <p>an internal work array for the various FFTs done in the transform</p> <code>plm_work_array</code> <p>an internal work array for the evaluate of plm values</p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>class SHT:\n    r\"\"\"\n    A class to encapsulate the re-usable data for a Spherical Harmonic Transform (SHT).\n\n    Attributes:\n        lmax: the maximum angular momentum of the SHT, affects grid size etc.\n        plm: class to evaluate associated Legendre polynomials\n        nphi: the number of phi angular grid points\n        ntheta: the number of theta angular grid points\n        phi: the phi angular grid points (equispaced) between [i, 2 \\pi]\n        cos_theta: cos values of the theta grid (evaluated as Gauss-Legendre\n            quadrature points)\n        weights: the Gauss-Legendre grid weights\n        theta: the theta angular grid points (derived from cos_theta)\n        fft_work_array: an internal work array for the various FFTs done\n            in the transform\n        plm_work_array: an internal work array for the evaluate of plm values\n\n    \"\"\"\n\n    def __init__(self, lm, nphi=None, ntheta=None):\n        self.lmax = lm\n        self.plm = AssocLegendre(lm)\n\n        if nphi is None:\n            self.nphi = _closest_int_with_only_prime_factors_up_to_fmax(2 * lm + 1)\n        else:\n            self.nphi = nphi\n        # avoid the poles\n        self.phi = np.arange(0, self.nphi) * 2 * np.pi / self.nphi\n\n        if ntheta is None:\n            n = self.lmax + 1\n            n += n &amp; 1\n            n = ((n + 7) // 8) * 8\n            self.ntheta = n\n        else:\n            self.ntheta = ntheta\n\n        self.cos_theta, self.weights, self.total_weight = roots_legendre(\n            self.ntheta, mu=True\n        )\n        self.weights *= 4 * np.pi / self.total_weight\n        self.theta = np.arccos(self.cos_theta)\n\n        self.fft_work_array = np.empty(self.nphi, dtype=np.complex128)\n        self.plm_work_array = np.empty(self.nplm())\n        self._grid = None\n        self._grid_cartesian = None\n\n    def idx_c(self, l, m):\n        return l * (l + 1) + m\n\n    def nlm(self):\n        \"the number of complex SHT coefficients\"\n        return (self.lmax + 1) * (self.lmax + 1)\n\n    def nplm(self):\n        \"the number of real SHT coefficients (i.e. legendre polynomial terms)\"\n        return (self.lmax + 1) * (self.lmax + 2) // 2\n\n    def compute_on_grid(self, func):\n        \"compute the values of `func` on the SHT grid\"\n        values = func(*self.grid)\n        return values\n\n    def analysis_pure_python(self, values):\n        \"\"\"\n        Perform the forward SHT i.e. evaluate the given SHT coefficients\n        given the values of the (real-valued) function at the grid points\n        used in the transform.\n\n        *NOTE*: this is implemented in pure python so will be much slower than\n        just calling analysis, but it is provided here as a reference implementation\n\n        Arguments:\n            values (np.ndarray): the evaluated function at the SHT grid points\n\n        Returns:\n            np.ndarray the set of spherical harmonic coefficients\n        \"\"\"\n        coeffs = np.zeros(self.nplm(), dtype=np.complex128)\n        for itheta, (ct, w) in enumerate(\n            zip(self.cos_theta, self.weights, strict=False)\n        ):\n            self.fft_work_array[:] = values[itheta, :]\n\n            fft(self.fft_work_array, norm=\"forward\", overwrite_x=True)\n            self.plm.evaluate_batch(ct, result=self.plm_work_array)\n            plm_idx = 0\n            # m = 0 case\n            for _l in range(self.lmax + 1):\n                p = self.plm_work_array[plm_idx]\n                coeffs[plm_idx] += self.fft_work_array[0] * p * w\n                plm_idx += 1\n\n            # because we don't include a phase factor (-1)^m in our\n            # Associated Legendre Polynomials, we need a factor here.\n            # which alternates with m and l\n            for m in range(1, self.lmax + 1):\n                sign = -1 if m &amp; 1 else 1\n                for _l in range(m, self.lmax + 1):\n                    p = self.plm_work_array[plm_idx]\n                    coeffs[plm_idx] += sign * self.fft_work_array[m] * p * w\n                    plm_idx += 1\n        return coeffs\n\n    def analysis_pure_python_cplx(self, values):\n        \"\"\"\n        Perform the forward SHT i.e. evaluate the given SHT coefficients\n        given the values of the (complex-valued) function at the grid points\n        used in the transform.\n\n        *NOTE*: this is implemented in pure python so will be much slower than\n        just calling analysis, but it is provided here as a reference implementation\n\n        Arguments:\n            values (np.ndarray): the evaluated function at the SHT grid points\n\n        Returns:\n            np.ndarray the set of spherical harmonic coefficients\n        \"\"\"\n\n        coeffs = np.zeros(self.nlm(), dtype=np.complex128)\n        np.zeros(self.nlm(), dtype=np.complex128)\n        np.zeros(self.nlm(), dtype=np.complex128)\n        for itheta, (ct, w) in enumerate(\n            zip(self.cos_theta, self.weights, strict=False)\n        ):\n            self.fft_work_array[:] = values[itheta, :]\n\n            fft(self.fft_work_array, norm=\"forward\", overwrite_x=True)\n            self.plm.evaluate_batch(ct, result=self.plm_work_array)\n\n            plm_idx = 0\n            for l in range(self.lmax + 1):\n                l_offset = l * (l + 1)\n                pw = self.plm_work_array[plm_idx] * w\n                coeffs[l_offset] = coeffs[l_offset] + self.fft_work_array[0] * pw\n                plm_idx += 1\n\n            # because we don't include a phase factor (-1)^m in our\n            # Associated Legendre Polynomials, we need a factor here.\n            # which alternates with m\n            for m in range(1, self.lmax + 1):\n                sign = -1 if m &amp; 1 else 1\n                for l in range(m, self.lmax + 1):\n                    l_offset = l * (l + 1)\n                    pw = self.plm_work_array[plm_idx] * w\n                    m_idx_neg = self.nphi - m\n                    m_idx_pos = m\n                    rr = sign * self.fft_work_array[m_idx_pos] * pw\n                    ii = sign * self.fft_work_array[m_idx_neg] * pw\n                    if m &amp; 1:\n                        ii = -ii\n\n                    coeffs[l_offset - m] = coeffs[l_offset - m] + ii\n                    coeffs[l_offset + m] = coeffs[l_offset + m] + rr\n                    plm_idx += 1\n        return coeffs\n\n    def synthesis_pure_python_cplx(self, coeffs):\n        \"\"\"\n        Perform the inverse SHT i.e. evaluate the given (complex-valued) function at the\n        grid points used in the transform.\n\n\n        *NOTE*: this is implemented in pure python so will be much slower than\n        just calling analysis, but it is provided here as a reference implementation\n\n        Arguments:\n            coeffs (np.ndarray): the set of spherical harmonic coefficients\n\n        Returns:\n            np.ndarray the evaluated function at the SHT grid points\n        \"\"\"\n\n        values = np.zeros((self.ntheta, self.nphi), dtype=np.complex128)\n        for itheta, ct in enumerate(self.cos_theta):\n            self.fft_work_array[:] = 0\n            self.plm.evaluate_batch(ct, result=self.plm_work_array)\n\n            plm_idx = 0\n            # m = 0 case\n            for l in range(self.lmax + 1):\n                l_offset = l * (l + 1)\n                p = self.plm_work_array[plm_idx]\n                self.fft_work_array[0] += coeffs[l_offset] * p\n                plm_idx += 1\n\n            for m in range(1, self.lmax + 1):\n                sign = -1 if m &amp; 1 else 1\n                for l in range(m, self.lmax + 1):\n                    l_offset = l * (l + 1)\n                    p = self.plm_work_array[plm_idx]\n                    m_idx_neg = self.nphi - m\n                    m_idx_pos = m\n                    rr = sign * coeffs[l_offset + m] * p\n                    ii = sign * coeffs[l_offset - m] * p\n                    if m &amp; 1:\n                        ii = -ii\n                    self.fft_work_array[m_idx_neg] += ii\n                    self.fft_work_array[m_idx_pos] += rr\n                    plm_idx += 1\n\n            ifft(self.fft_work_array, norm=\"forward\", overwrite_x=True)\n            values[itheta, :] = self.fft_work_array[:]\n        return values\n\n    def synthesis_pure_python(self, coeffs):\n        \"\"\"\n        Perform the inverse SHT i.e. evaluate the given (real-valued) function at the\n        grid points used in the transform.\n\n        *NOTE*\n\n        Arguments:\n            coeffs (np.ndarray): the set of spherical harmonic coefficients\n\n        Returns:\n            np.ndarray the evaluated function at the SHT grid points\n        \"\"\"\n\n        values = np.zeros((self.ntheta, self.nphi))\n        for itheta, ct in enumerate(self.cos_theta):\n            self.fft_work_array[:] = 0\n            self.plm.evaluate_batch(ct, result=self.plm_work_array)\n\n            plm_idx = 0\n            # m = 0 case\n            for _l in range(self.lmax + 1):\n                p = self.plm_work_array[plm_idx]\n                self.fft_work_array[0] += coeffs[plm_idx] * p\n                plm_idx += 1\n\n            for m in range(1, self.lmax + 1):\n                sign = -1 if m &amp; 1 else 1\n                for _l in range(m, self.lmax + 1):\n                    p = self.plm_work_array[plm_idx]\n                    rr = 2 * sign * coeffs[plm_idx] * p\n                    self.fft_work_array[m] += rr\n                    plm_idx += 1\n\n            ifft(self.fft_work_array, norm=\"forward\", overwrite_x=True)\n            values[itheta, :] = self.fft_work_array[:].real\n        return values\n\n    def analysis(self, values):\n        \"\"\"\n        Perform the forward SHT i.e. evaluate the given SHT coefficients\n        given the values of the function at the grid points used in the transform.\n\n        Arguments:\n            values (np.ndarray): the evaluated function at the SHT grid points\n\n        Returns:\n            np.ndarray the set of spherical harmonic coefficients\n        \"\"\"\n\n        real = not np.iscomplexobj(values)\n        if real:\n            kernel = analysis_kernel_real\n            coeffs = np.zeros(self.nplm(), dtype=np.complex128)\n        else:\n            kernel = analysis_kernel_cplx\n            coeffs = np.zeros(self.nlm(), dtype=np.complex128)\n        for itheta, (ct, w) in enumerate(\n            zip(self.cos_theta, self.weights, strict=False)\n        ):\n            self.fft_work_array[:] = values[itheta, :]\n\n            fft(self.fft_work_array, norm=\"forward\", overwrite_x=True)\n            self.plm.evaluate_batch(ct, result=self.plm_work_array)\n            kernel(self, w, coeffs)\n        return coeffs\n\n    def synthesis(self, coeffs):\n        \"\"\"\n        Perform the inverse SHT i.e. evaluate the given function at the\n        grid points used in the transform.\n\n        Arguments:\n            coeffs (np.ndarray): the set of spherical harmonic coefficients\n\n        Returns:\n            np.ndarray the evaluated function at the SHT grid points\n        \"\"\"\n        real = coeffs.size == self.nplm()\n        if real:\n            kernel = synthesis_kernel_real\n            values = np.zeros(self.grid[0].shape)\n        else:\n            kernel = synthesis_kernel_cplx\n            values = np.zeros(self.grid[0].shape, dtype=np.complex128)\n\n        for itheta, ct in enumerate(self.cos_theta):\n            self.fft_work_array[:] = 0\n            self.plm.evaluate_batch(ct, result=self.plm_work_array)\n            kernel(self, coeffs)\n            ifft(self.fft_work_array, norm=\"forward\", overwrite_x=True)\n\n            if real:\n                values[itheta, :] = self.fft_work_array[:].real\n            else:\n                values[itheta, :] = self.fft_work_array[:]\n        return values\n\n    def _eval_at_points_real(self, coeffs, theta, phi):\n        # very slow pure python implementation, should move to cython\n        cos_theta = np.cos(theta)\n        result = 0.0\n        self.plm.evaluate_batch(cos_theta, result=self.plm_work_array)\n        plm_idx = 0\n        for _l in range(0, self.lmax + 1):\n            result += self.plm_work_array[plm_idx] * coeffs[plm_idx].real\n            plm_idx += 1\n\n        mv = 2 * np.exp(1j * np.arange(1, self.lmax + 1) * phi)\n        sign = 1\n        for m in range(1, self.lmax + 1):\n            tmp = 0.0\n            sign *= -1\n            for _l in range(m, self.lmax + 1):\n                # m +ve and m -ve\n                tmp += sign * self.plm_work_array[plm_idx] * coeffs[plm_idx]\n                plm_idx += 1\n\n            result += tmp.real * mv[m - 1].real + tmp.imag * mv[m - 1].imag\n        return result\n\n    def _eval_at_points_cplx(self, coeffs, theta, phi):\n        # very slow pure python implementation, should move to cython\n        cos_theta = np.cos(theta)\n        result = 0.0\n        self.plm.evaluate_batch(cos_theta, result=self.plm_work_array)\n\n        plm_idx = 0\n        for l in range(0, self.lmax + 1):\n            l_offset = l * (l + 1)\n            result += self.plm_work_array[plm_idx] * coeffs[l_offset]\n            plm_idx += 1\n\n        mv = np.exp(1j * np.arange(-self.lmax, self.lmax + 1) * phi)\n        cos_vals = 0.0\n        sin_vals = 0.0\n        for m in range(1, self.lmax + 1):\n            tmpr = 0.0\n            tmpc = 0.0\n            for l in range(m, self.lmax + 1):\n                l_offset = l * (l + 1)\n                tmpr += self.plm_work_array[plm_idx] * coeffs[l_offset + m]\n                tmpc += self.plm_work_array[plm_idx] * coeffs[l_offset - m]\n                plm_idx += 1\n            if m &amp; 1:\n                tmpc = -tmpc\n            cos_vals += np.real(mv[self.lmax + m]) * (tmpr + tmpc)\n            sin_vals += np.imag(mv[self.lmax - m]) * (tmpr - tmpc)\n        result += (\n            np.real(cos_vals)\n            - np.imag(sin_vals)\n            + 1j * (np.imag(cos_vals) + np.real(sin_vals))\n        )\n        return result\n\n    def evaluate_at_points(self, coeffs, theta, phi):\n        r\"\"\"\n        Evaluate the value of the function described in terms of the\n        provided SH coefficients at the provided (angular) points.\n        Will attempt to detect if the provided coefficients are from a real\n        or a complex transform.\n\n        Note that this can be quite slow, especially in comparison with just\n        synthesis step.\n\n        Arguments:\n            coeffs (np.ndarray): the set of spherical harmonic coefficients\n            theta (np.ndarray): the angular coordinates \\theta\n            phi (np.ndarray): the angular coordinates \\phi\n\n        Returns:\n            np.ndarray the evaluated function values\n        \"\"\"\n        real = coeffs.size == self.nplm()\n        if real:\n            return self._eval_at_points_real(coeffs, theta, phi)\n        # assumes coeffs are the real transform order\n        else:\n            return self._eval_at_points_cplx(coeffs, theta, phi)\n\n    def complete_coefficients(self, coeffs):\n        \"\"\"\n        Construct the complete set of SHT coefficients\n        for a given real analysis. Should be equivalent to performing\n        a complex valued SHT with the imaginary values being zero.\n\n        Arguments:\n            coefficients (np.ndarray): the set of spherical harmonic coefficients\n\n        Returns:\n            np.ndarray the full set of spherical harmonic coefficients for a\n                complex transform\n        \"\"\"\n        return expand_coeffs_to_full(self.lmax, coeffs)\n\n    @property\n    def grid(self):\n        r\"The set of grid points [\\theta, \\phi] for this SHT\"\n        return np.meshgrid(self.theta, self.phi, indexing=\"ij\")\n\n    @property\n    def grid_cartesian(self):\n        \"The set of cartesian grid points for this SHT\"\n        theta, phi = self.grid\n        r = np.ones_like(theta)\n        return spherical_to_cartesian_mgrid(r, theta, phi)\n\n    def power_spectrum(self, coeffs) -&gt; np.ndarray:\n        r\"\"\"\n        Evaluate the power spectrum of the function described in terms of the\n        provided SH coefficients.\n\n        Arguments:\n            coeffs (np.ndarray): the set of spherical harmonic coefficients\n\n        Returns:\n            np.ndarray the evaluated power spectrum\n        \"\"\"\n\n        real = coeffs.size == self.nplm()\n        if real:\n            n = len(coeffs)\n            l_max = int((-3 + np.sqrt(8 * n + 1)) // 2)\n            spectrum = np.zeros(l_max + 1)\n\n            pattern = np.concatenate(\n                [np.arange(m, l_max + 1) for m in range(l_max + 1)]\n            )\n            boundary = l_max + 1\n            np.add.at(spectrum, pattern[:boundary], np.abs(coeffs[:boundary]) ** 2)\n            np.add.at(spectrum, pattern[boundary:], 2 * np.abs(coeffs[boundary:]) ** 2)\n            spectrum /= 2 * pattern[:boundary] + 1\n\n            return spectrum\n        else:\n            l_max = int(np.sqrt(len(coeffs))) - 1\n            spectrum = np.empty(l_max + 1)\n            coeffs2 = np.abs(coeffs) ** 2\n            idx = 0\n            for l in range(l_max + 1):\n                count = 2 * l + 1\n                spectrum[l] = np.sum(coeffs2[idx : idx + count]) / count\n                idx += count\n            return spectrum\n\n    def invariants_kazhdan(self, coeffs):\n        r\"\"\"\n        Evaluate the rotation invariants as detailed in Kazhdan et al.[1] for the\n        provided set of SHT coefficients\n\n        *NOTE* this is not a well-tested implementation, and is not complete\n        for the set of invariants described in the work.\n\n        Arguments:\n            coeffs(np.ndarray): the set of spherical harmonic coefficients\n\n        Returns:\n            np.ndarray the evaluated rotation invariants\n\n        References:\n        ```\n        [1] Kazhdan et al. Proc. 2003 Eurographics/ACM SIGGRAPH SGP, (2003)\n            https://dl.acm.org/doi/10.5555/882370.882392\n        ```\n\n        \"\"\"\n\n        invariants = np.empty(self.lmax + 1)\n        for lvalue in range(0, self.lmax + 1):\n            values = np.zeros((self.ntheta, self.nphi))\n            for itheta, ct in enumerate(self.cos_theta):\n                self.fft_work_array[:] = 0\n                self.plm.evaluate_batch(ct, result=self.plm_work_array)\n\n                plm_idx = 0\n                # m = 0 case\n                for l in range(self.lmax + 1):\n                    if l == lvalue:\n                        p = self.plm_work_array[plm_idx]\n                        self.fft_work_array[0] += coeffs[plm_idx] * p\n                    plm_idx += 1\n\n                for m in range(1, self.lmax + 1):\n                    sign = -1 if m &amp; 1 else 1\n                    for l in range(m, self.lmax + 1):\n                        if l == lvalue:\n                            p = self.plm_work_array[plm_idx]\n                            rr = 2 * sign * coeffs[plm_idx] * p\n                            self.fft_work_array[m] += rr\n                        plm_idx += 1\n\n                ifft(self.fft_work_array, norm=\"forward\", overwrite_x=True)\n                values[itheta, :] = self.fft_work_array[:].real\n            invariants[lvalue] = np.sum(values**2) / values.size / (2 * lvalue + 1)\n        return invariants\n\n    def faces(self):\n        \"\"\"\n        Generate the triangular faces for the grid vertices.\n        Returns:\n            list: A list of lists representing the faces, where each inner list\n                contains the indices of the vertices that form a triangular face.\n        \"\"\"\n        faces = []\n        for i in range(self.ntheta - 1):\n            for j in range(self.nphi):\n                # Create two triangles for each quad\n                triangle1 = [\n                    i * self.nphi + j,\n                    i * self.nphi + (j + 1) % self.nphi,\n                    (i + 1) * self.nphi + j,\n                ]\n                triangle2 = [\n                    (i + 1) * self.nphi + j,\n                    i * self.nphi + (j + 1) % self.nphi,\n                    (i + 1) * self.nphi + (j + 1) % self.nphi,\n                ]\n                faces.append(triangle1)\n                faces.append(triangle2)\n        return faces\n</code></pre>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.grid","title":"<code>grid</code>  <code>property</code>","text":"<p>The set of grid points [\\theta, \\phi] for this SHT</p>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.grid_cartesian","title":"<code>grid_cartesian</code>  <code>property</code>","text":"<p>The set of cartesian grid points for this SHT</p>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.analysis","title":"<code>analysis(values)</code>","text":"<p>Perform the forward SHT i.e. evaluate the given SHT coefficients given the values of the function at the grid points used in the transform.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>ndarray</code> <p>the evaluated function at the SHT grid points</p> required <p>Returns:</p> Type Description <p>np.ndarray the set of spherical harmonic coefficients</p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>def analysis(self, values):\n    \"\"\"\n    Perform the forward SHT i.e. evaluate the given SHT coefficients\n    given the values of the function at the grid points used in the transform.\n\n    Arguments:\n        values (np.ndarray): the evaluated function at the SHT grid points\n\n    Returns:\n        np.ndarray the set of spherical harmonic coefficients\n    \"\"\"\n\n    real = not np.iscomplexobj(values)\n    if real:\n        kernel = analysis_kernel_real\n        coeffs = np.zeros(self.nplm(), dtype=np.complex128)\n    else:\n        kernel = analysis_kernel_cplx\n        coeffs = np.zeros(self.nlm(), dtype=np.complex128)\n    for itheta, (ct, w) in enumerate(\n        zip(self.cos_theta, self.weights, strict=False)\n    ):\n        self.fft_work_array[:] = values[itheta, :]\n\n        fft(self.fft_work_array, norm=\"forward\", overwrite_x=True)\n        self.plm.evaluate_batch(ct, result=self.plm_work_array)\n        kernel(self, w, coeffs)\n    return coeffs\n</code></pre>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.analysis_pure_python","title":"<code>analysis_pure_python(values)</code>","text":"<p>Perform the forward SHT i.e. evaluate the given SHT coefficients given the values of the (real-valued) function at the grid points used in the transform.</p> <p>NOTE: this is implemented in pure python so will be much slower than just calling analysis, but it is provided here as a reference implementation</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>ndarray</code> <p>the evaluated function at the SHT grid points</p> required <p>Returns:</p> Type Description <p>np.ndarray the set of spherical harmonic coefficients</p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>def analysis_pure_python(self, values):\n    \"\"\"\n    Perform the forward SHT i.e. evaluate the given SHT coefficients\n    given the values of the (real-valued) function at the grid points\n    used in the transform.\n\n    *NOTE*: this is implemented in pure python so will be much slower than\n    just calling analysis, but it is provided here as a reference implementation\n\n    Arguments:\n        values (np.ndarray): the evaluated function at the SHT grid points\n\n    Returns:\n        np.ndarray the set of spherical harmonic coefficients\n    \"\"\"\n    coeffs = np.zeros(self.nplm(), dtype=np.complex128)\n    for itheta, (ct, w) in enumerate(\n        zip(self.cos_theta, self.weights, strict=False)\n    ):\n        self.fft_work_array[:] = values[itheta, :]\n\n        fft(self.fft_work_array, norm=\"forward\", overwrite_x=True)\n        self.plm.evaluate_batch(ct, result=self.plm_work_array)\n        plm_idx = 0\n        # m = 0 case\n        for _l in range(self.lmax + 1):\n            p = self.plm_work_array[plm_idx]\n            coeffs[plm_idx] += self.fft_work_array[0] * p * w\n            plm_idx += 1\n\n        # because we don't include a phase factor (-1)^m in our\n        # Associated Legendre Polynomials, we need a factor here.\n        # which alternates with m and l\n        for m in range(1, self.lmax + 1):\n            sign = -1 if m &amp; 1 else 1\n            for _l in range(m, self.lmax + 1):\n                p = self.plm_work_array[plm_idx]\n                coeffs[plm_idx] += sign * self.fft_work_array[m] * p * w\n                plm_idx += 1\n    return coeffs\n</code></pre>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.analysis_pure_python_cplx","title":"<code>analysis_pure_python_cplx(values)</code>","text":"<p>Perform the forward SHT i.e. evaluate the given SHT coefficients given the values of the (complex-valued) function at the grid points used in the transform.</p> <p>NOTE: this is implemented in pure python so will be much slower than just calling analysis, but it is provided here as a reference implementation</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>ndarray</code> <p>the evaluated function at the SHT grid points</p> required <p>Returns:</p> Type Description <p>np.ndarray the set of spherical harmonic coefficients</p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>def analysis_pure_python_cplx(self, values):\n    \"\"\"\n    Perform the forward SHT i.e. evaluate the given SHT coefficients\n    given the values of the (complex-valued) function at the grid points\n    used in the transform.\n\n    *NOTE*: this is implemented in pure python so will be much slower than\n    just calling analysis, but it is provided here as a reference implementation\n\n    Arguments:\n        values (np.ndarray): the evaluated function at the SHT grid points\n\n    Returns:\n        np.ndarray the set of spherical harmonic coefficients\n    \"\"\"\n\n    coeffs = np.zeros(self.nlm(), dtype=np.complex128)\n    np.zeros(self.nlm(), dtype=np.complex128)\n    np.zeros(self.nlm(), dtype=np.complex128)\n    for itheta, (ct, w) in enumerate(\n        zip(self.cos_theta, self.weights, strict=False)\n    ):\n        self.fft_work_array[:] = values[itheta, :]\n\n        fft(self.fft_work_array, norm=\"forward\", overwrite_x=True)\n        self.plm.evaluate_batch(ct, result=self.plm_work_array)\n\n        plm_idx = 0\n        for l in range(self.lmax + 1):\n            l_offset = l * (l + 1)\n            pw = self.plm_work_array[plm_idx] * w\n            coeffs[l_offset] = coeffs[l_offset] + self.fft_work_array[0] * pw\n            plm_idx += 1\n\n        # because we don't include a phase factor (-1)^m in our\n        # Associated Legendre Polynomials, we need a factor here.\n        # which alternates with m\n        for m in range(1, self.lmax + 1):\n            sign = -1 if m &amp; 1 else 1\n            for l in range(m, self.lmax + 1):\n                l_offset = l * (l + 1)\n                pw = self.plm_work_array[plm_idx] * w\n                m_idx_neg = self.nphi - m\n                m_idx_pos = m\n                rr = sign * self.fft_work_array[m_idx_pos] * pw\n                ii = sign * self.fft_work_array[m_idx_neg] * pw\n                if m &amp; 1:\n                    ii = -ii\n\n                coeffs[l_offset - m] = coeffs[l_offset - m] + ii\n                coeffs[l_offset + m] = coeffs[l_offset + m] + rr\n                plm_idx += 1\n    return coeffs\n</code></pre>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.complete_coefficients","title":"<code>complete_coefficients(coeffs)</code>","text":"<p>Construct the complete set of SHT coefficients for a given real analysis. Should be equivalent to performing a complex valued SHT with the imaginary values being zero.</p> <p>Parameters:</p> Name Type Description Default <code>coefficients</code> <code>ndarray</code> <p>the set of spherical harmonic coefficients</p> required <p>Returns:</p> Type Description <p>np.ndarray the full set of spherical harmonic coefficients for a complex transform</p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>def complete_coefficients(self, coeffs):\n    \"\"\"\n    Construct the complete set of SHT coefficients\n    for a given real analysis. Should be equivalent to performing\n    a complex valued SHT with the imaginary values being zero.\n\n    Arguments:\n        coefficients (np.ndarray): the set of spherical harmonic coefficients\n\n    Returns:\n        np.ndarray the full set of spherical harmonic coefficients for a\n            complex transform\n    \"\"\"\n    return expand_coeffs_to_full(self.lmax, coeffs)\n</code></pre>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.compute_on_grid","title":"<code>compute_on_grid(func)</code>","text":"<p>compute the values of <code>func</code> on the SHT grid</p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>def compute_on_grid(self, func):\n    \"compute the values of `func` on the SHT grid\"\n    values = func(*self.grid)\n    return values\n</code></pre>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.evaluate_at_points","title":"<code>evaluate_at_points(coeffs, theta, phi)</code>","text":"<p>Evaluate the value of the function described in terms of the provided SH coefficients at the provided (angular) points. Will attempt to detect if the provided coefficients are from a real or a complex transform.</p> <p>Note that this can be quite slow, especially in comparison with just synthesis step.</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>ndarray</code> <p>the set of spherical harmonic coefficients</p> required <code>theta</code> <code>ndarray</code> <p>the angular coordinates \\theta</p> required <code>phi</code> <code>ndarray</code> <p>the angular coordinates \\phi</p> required <p>Returns:</p> Type Description <p>np.ndarray the evaluated function values</p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>def evaluate_at_points(self, coeffs, theta, phi):\n    r\"\"\"\n    Evaluate the value of the function described in terms of the\n    provided SH coefficients at the provided (angular) points.\n    Will attempt to detect if the provided coefficients are from a real\n    or a complex transform.\n\n    Note that this can be quite slow, especially in comparison with just\n    synthesis step.\n\n    Arguments:\n        coeffs (np.ndarray): the set of spherical harmonic coefficients\n        theta (np.ndarray): the angular coordinates \\theta\n        phi (np.ndarray): the angular coordinates \\phi\n\n    Returns:\n        np.ndarray the evaluated function values\n    \"\"\"\n    real = coeffs.size == self.nplm()\n    if real:\n        return self._eval_at_points_real(coeffs, theta, phi)\n    # assumes coeffs are the real transform order\n    else:\n        return self._eval_at_points_cplx(coeffs, theta, phi)\n</code></pre>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.faces","title":"<code>faces()</code>","text":"<p>Generate the triangular faces for the grid vertices. Returns:     list: A list of lists representing the faces, where each inner list         contains the indices of the vertices that form a triangular face.</p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>def faces(self):\n    \"\"\"\n    Generate the triangular faces for the grid vertices.\n    Returns:\n        list: A list of lists representing the faces, where each inner list\n            contains the indices of the vertices that form a triangular face.\n    \"\"\"\n    faces = []\n    for i in range(self.ntheta - 1):\n        for j in range(self.nphi):\n            # Create two triangles for each quad\n            triangle1 = [\n                i * self.nphi + j,\n                i * self.nphi + (j + 1) % self.nphi,\n                (i + 1) * self.nphi + j,\n            ]\n            triangle2 = [\n                (i + 1) * self.nphi + j,\n                i * self.nphi + (j + 1) % self.nphi,\n                (i + 1) * self.nphi + (j + 1) % self.nphi,\n            ]\n            faces.append(triangle1)\n            faces.append(triangle2)\n    return faces\n</code></pre>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.invariants_kazhdan","title":"<code>invariants_kazhdan(coeffs)</code>","text":"<p>Evaluate the rotation invariants as detailed in Kazhdan et al.[1] for the provided set of SHT coefficients</p> <p>NOTE this is not a well-tested implementation, and is not complete for the set of invariants described in the work.</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>ndarray</code> <p>the set of spherical harmonic coefficients</p> required <p>Returns:</p> Type Description <p>np.ndarray the evaluated rotation invariants</p> <p>References: <pre><code>[1] Kazhdan et al. Proc. 2003 Eurographics/ACM SIGGRAPH SGP, (2003)\n    https://dl.acm.org/doi/10.5555/882370.882392\n</code></pre></p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>def invariants_kazhdan(self, coeffs):\n    r\"\"\"\n    Evaluate the rotation invariants as detailed in Kazhdan et al.[1] for the\n    provided set of SHT coefficients\n\n    *NOTE* this is not a well-tested implementation, and is not complete\n    for the set of invariants described in the work.\n\n    Arguments:\n        coeffs(np.ndarray): the set of spherical harmonic coefficients\n\n    Returns:\n        np.ndarray the evaluated rotation invariants\n\n    References:\n    ```\n    [1] Kazhdan et al. Proc. 2003 Eurographics/ACM SIGGRAPH SGP, (2003)\n        https://dl.acm.org/doi/10.5555/882370.882392\n    ```\n\n    \"\"\"\n\n    invariants = np.empty(self.lmax + 1)\n    for lvalue in range(0, self.lmax + 1):\n        values = np.zeros((self.ntheta, self.nphi))\n        for itheta, ct in enumerate(self.cos_theta):\n            self.fft_work_array[:] = 0\n            self.plm.evaluate_batch(ct, result=self.plm_work_array)\n\n            plm_idx = 0\n            # m = 0 case\n            for l in range(self.lmax + 1):\n                if l == lvalue:\n                    p = self.plm_work_array[plm_idx]\n                    self.fft_work_array[0] += coeffs[plm_idx] * p\n                plm_idx += 1\n\n            for m in range(1, self.lmax + 1):\n                sign = -1 if m &amp; 1 else 1\n                for l in range(m, self.lmax + 1):\n                    if l == lvalue:\n                        p = self.plm_work_array[plm_idx]\n                        rr = 2 * sign * coeffs[plm_idx] * p\n                        self.fft_work_array[m] += rr\n                    plm_idx += 1\n\n            ifft(self.fft_work_array, norm=\"forward\", overwrite_x=True)\n            values[itheta, :] = self.fft_work_array[:].real\n        invariants[lvalue] = np.sum(values**2) / values.size / (2 * lvalue + 1)\n    return invariants\n</code></pre>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.nlm","title":"<code>nlm()</code>","text":"<p>the number of complex SHT coefficients</p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>def nlm(self):\n    \"the number of complex SHT coefficients\"\n    return (self.lmax + 1) * (self.lmax + 1)\n</code></pre>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.nplm","title":"<code>nplm()</code>","text":"<p>the number of real SHT coefficients (i.e. legendre polynomial terms)</p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>def nplm(self):\n    \"the number of real SHT coefficients (i.e. legendre polynomial terms)\"\n    return (self.lmax + 1) * (self.lmax + 2) // 2\n</code></pre>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.power_spectrum","title":"<code>power_spectrum(coeffs)</code>","text":"<p>Evaluate the power spectrum of the function described in terms of the provided SH coefficients.</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>ndarray</code> <p>the set of spherical harmonic coefficients</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray the evaluated power spectrum</p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>def power_spectrum(self, coeffs) -&gt; np.ndarray:\n    r\"\"\"\n    Evaluate the power spectrum of the function described in terms of the\n    provided SH coefficients.\n\n    Arguments:\n        coeffs (np.ndarray): the set of spherical harmonic coefficients\n\n    Returns:\n        np.ndarray the evaluated power spectrum\n    \"\"\"\n\n    real = coeffs.size == self.nplm()\n    if real:\n        n = len(coeffs)\n        l_max = int((-3 + np.sqrt(8 * n + 1)) // 2)\n        spectrum = np.zeros(l_max + 1)\n\n        pattern = np.concatenate(\n            [np.arange(m, l_max + 1) for m in range(l_max + 1)]\n        )\n        boundary = l_max + 1\n        np.add.at(spectrum, pattern[:boundary], np.abs(coeffs[:boundary]) ** 2)\n        np.add.at(spectrum, pattern[boundary:], 2 * np.abs(coeffs[boundary:]) ** 2)\n        spectrum /= 2 * pattern[:boundary] + 1\n\n        return spectrum\n    else:\n        l_max = int(np.sqrt(len(coeffs))) - 1\n        spectrum = np.empty(l_max + 1)\n        coeffs2 = np.abs(coeffs) ** 2\n        idx = 0\n        for l in range(l_max + 1):\n            count = 2 * l + 1\n            spectrum[l] = np.sum(coeffs2[idx : idx + count]) / count\n            idx += count\n        return spectrum\n</code></pre>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.synthesis","title":"<code>synthesis(coeffs)</code>","text":"<p>Perform the inverse SHT i.e. evaluate the given function at the grid points used in the transform.</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>ndarray</code> <p>the set of spherical harmonic coefficients</p> required <p>Returns:</p> Type Description <p>np.ndarray the evaluated function at the SHT grid points</p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>def synthesis(self, coeffs):\n    \"\"\"\n    Perform the inverse SHT i.e. evaluate the given function at the\n    grid points used in the transform.\n\n    Arguments:\n        coeffs (np.ndarray): the set of spherical harmonic coefficients\n\n    Returns:\n        np.ndarray the evaluated function at the SHT grid points\n    \"\"\"\n    real = coeffs.size == self.nplm()\n    if real:\n        kernel = synthesis_kernel_real\n        values = np.zeros(self.grid[0].shape)\n    else:\n        kernel = synthesis_kernel_cplx\n        values = np.zeros(self.grid[0].shape, dtype=np.complex128)\n\n    for itheta, ct in enumerate(self.cos_theta):\n        self.fft_work_array[:] = 0\n        self.plm.evaluate_batch(ct, result=self.plm_work_array)\n        kernel(self, coeffs)\n        ifft(self.fft_work_array, norm=\"forward\", overwrite_x=True)\n\n        if real:\n            values[itheta, :] = self.fft_work_array[:].real\n        else:\n            values[itheta, :] = self.fft_work_array[:]\n    return values\n</code></pre>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.synthesis_pure_python","title":"<code>synthesis_pure_python(coeffs)</code>","text":"<p>Perform the inverse SHT i.e. evaluate the given (real-valued) function at the grid points used in the transform.</p> <p>NOTE</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>ndarray</code> <p>the set of spherical harmonic coefficients</p> required <p>Returns:</p> Type Description <p>np.ndarray the evaluated function at the SHT grid points</p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>def synthesis_pure_python(self, coeffs):\n    \"\"\"\n    Perform the inverse SHT i.e. evaluate the given (real-valued) function at the\n    grid points used in the transform.\n\n    *NOTE*\n\n    Arguments:\n        coeffs (np.ndarray): the set of spherical harmonic coefficients\n\n    Returns:\n        np.ndarray the evaluated function at the SHT grid points\n    \"\"\"\n\n    values = np.zeros((self.ntheta, self.nphi))\n    for itheta, ct in enumerate(self.cos_theta):\n        self.fft_work_array[:] = 0\n        self.plm.evaluate_batch(ct, result=self.plm_work_array)\n\n        plm_idx = 0\n        # m = 0 case\n        for _l in range(self.lmax + 1):\n            p = self.plm_work_array[plm_idx]\n            self.fft_work_array[0] += coeffs[plm_idx] * p\n            plm_idx += 1\n\n        for m in range(1, self.lmax + 1):\n            sign = -1 if m &amp; 1 else 1\n            for _l in range(m, self.lmax + 1):\n                p = self.plm_work_array[plm_idx]\n                rr = 2 * sign * coeffs[plm_idx] * p\n                self.fft_work_array[m] += rr\n                plm_idx += 1\n\n        ifft(self.fft_work_array, norm=\"forward\", overwrite_x=True)\n        values[itheta, :] = self.fft_work_array[:].real\n    return values\n</code></pre>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.SHT.synthesis_pure_python_cplx","title":"<code>synthesis_pure_python_cplx(coeffs)</code>","text":"<p>Perform the inverse SHT i.e. evaluate the given (complex-valued) function at the grid points used in the transform.</p> <p>NOTE: this is implemented in pure python so will be much slower than just calling analysis, but it is provided here as a reference implementation</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>ndarray</code> <p>the set of spherical harmonic coefficients</p> required <p>Returns:</p> Type Description <p>np.ndarray the evaluated function at the SHT grid points</p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>def synthesis_pure_python_cplx(self, coeffs):\n    \"\"\"\n    Perform the inverse SHT i.e. evaluate the given (complex-valued) function at the\n    grid points used in the transform.\n\n\n    *NOTE*: this is implemented in pure python so will be much slower than\n    just calling analysis, but it is provided here as a reference implementation\n\n    Arguments:\n        coeffs (np.ndarray): the set of spherical harmonic coefficients\n\n    Returns:\n        np.ndarray the evaluated function at the SHT grid points\n    \"\"\"\n\n    values = np.zeros((self.ntheta, self.nphi), dtype=np.complex128)\n    for itheta, ct in enumerate(self.cos_theta):\n        self.fft_work_array[:] = 0\n        self.plm.evaluate_batch(ct, result=self.plm_work_array)\n\n        plm_idx = 0\n        # m = 0 case\n        for l in range(self.lmax + 1):\n            l_offset = l * (l + 1)\n            p = self.plm_work_array[plm_idx]\n            self.fft_work_array[0] += coeffs[l_offset] * p\n            plm_idx += 1\n\n        for m in range(1, self.lmax + 1):\n            sign = -1 if m &amp; 1 else 1\n            for l in range(m, self.lmax + 1):\n                l_offset = l * (l + 1)\n                p = self.plm_work_array[plm_idx]\n                m_idx_neg = self.nphi - m\n                m_idx_pos = m\n                rr = sign * coeffs[l_offset + m] * p\n                ii = sign * coeffs[l_offset - m] * p\n                if m &amp; 1:\n                    ii = -ii\n                self.fft_work_array[m_idx_neg] += ii\n                self.fft_work_array[m_idx_pos] += rr\n                plm_idx += 1\n\n        ifft(self.fft_work_array, norm=\"forward\", overwrite_x=True)\n        values[itheta, :] = self.fft_work_array[:]\n    return values\n</code></pre>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.plot_sphere","title":"<code>plot_sphere(name, grid, values)</code>","text":"<p>Plot a function on a spherical surface.</p>"},{"location":"reference/chmpy/shape/sht/#chmpy.shape.sht.plot_sphere--parameters","title":"Parameters","text":"<p>name: str     used for the title and the output filename grid: array_like     theta, phi values from an angular grid on a sphere values: array_like     scalar values of the function associated with each grid point</p> Source code in <code>chmpy/shape/sht.py</code> <pre><code>def plot_sphere(name, grid, values):\n    \"\"\"Plot a function on a spherical surface.\n\n    Parameters\n    ----------\n    name: str\n        used for the title and the output filename\n    grid: array_like\n        theta, phi values from an angular grid on a sphere\n    values: array_like\n        scalar values of the function associated with each grid point\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib import cm\n\n    fig = plt.figure(figsize=plt.figaspect(1.0))\n    theta, phi = grid\n    x = np.sin(theta) * np.cos(phi)\n    y = np.sin(theta) * np.sin(phi)\n    z = np.cos(theta)\n    fmin, fmax = np.min(values), np.max(values)\n    fcolors = (values - fmin) / (fmax - fmin)\n    fcolors = fcolors.reshape(theta.shape)\n\n    ax = fig.add_subplot(111, projection=\"3d\")\n    ax.plot_surface(\n        x, y, z, rstride=1, cstride=1, facecolors=cm.viridis(fcolors), shade=True\n    )\n    ax.set_axis_off()\n    plt.title(f\"Contours of {name}\")\n    plt.savefig(f\"{name}.png\", dpi=300, bbox_inches=\"tight\")\n</code></pre>"},{"location":"reference/chmpy/shape/spherical_harmonics/","title":"spherical_harmonics","text":""},{"location":"reference/chmpy/shape/spherical_harmonics/#chmpy.shape.spherical_harmonics.SphericalHarmonics","title":"<code>SphericalHarmonics</code>","text":"Source code in <code>chmpy/shape/spherical_harmonics.py</code> <pre><code>class SphericalHarmonics:\n    def __init__(self, lm, phase=True):\n        self.lmax = lm\n        self.phase = phase\n        self.plm = AssocLegendre(lm)\n        self.plm_work_array = np.empty(self.nplm(), dtype=np.float64)\n\n    def idx_c(self, l, m):\n        return l * (l + 1) + m\n\n    def nlm(self):\n        \"the number of complex SHT coefficients\"\n        return (self.lmax + 1) * (self.lmax + 1)\n\n    def nplm(self):\n        \"the number of real SHT coefficients (i.e. legendre polynomial terms)\"\n        return (self.lmax + 1) * (self.lmax + 2) // 2\n\n    def single_angular(self, theta, phi, result=None):\n        if result is None:\n            result = np.empty(self.nlm(), dtype=np.complex128)\n\n        ct = np.cos(theta)\n        self.plm.evaluate_batch(ct, result=self.plm_work_array)\n\n        plm_idx = 0\n        for l in range(0, self.lmax + 1):\n            offset = l * (l + 1)\n            result[offset] = self.plm_work_array[plm_idx]\n            plm_idx += 1\n\n        c = np.exp(phi * 1j)\n        cm = c\n        for m in range(1, self.lmax + 1):\n            sign = 1\n            if self.phase and (m &amp; 1):\n                sign = -1\n            for l in range(m, self.lmax + 1):\n                l_offset = l * (l + 1)\n                rr = cm\n                ii = np.conj(rr)\n                rr = sign * self.plm_work_array[plm_idx] * rr\n                ii = sign * self.plm_work_array[plm_idx] * ii\n                if m &amp; 1:\n                    ii = -ii\n                result[l_offset - m] = ii\n                result[l_offset + m] = rr\n                plm_idx += 1\n            cm *= c\n        return result\n\n    def batch_angular(self, pos, result=None):\n        if result is None:\n            result = np.empty((pos.shape[0], self.nlm()), dtype=np.complex128)\n\n        for i in range(pos.shape[0]):\n            result[i, :] = self.single_angular(*pos[i], result=result[i, :])\n        return result\n\n    def single_cartesian(self, x, y, z, result=None):\n        if result is None:\n            result = np.empty(self.nlm(), dtype=np.complex128)\n        pass\n        epsilon = 1e-12\n        ct = z\n        self.plm.evaluate_batch(ct, result=self.plm_work_array)\n\n        st = 0.0\n        if abs(1.0 - ct) &gt; epsilon:\n            st = np.sqrt(1.0 - ct * ct)\n\n        plm_idx = 0\n        for l in range(0, self.lmax + 1):\n            l_offset = l * (l + 1)\n            result[l_offset] = self.plm_work_array[plm_idx]\n            plm_idx += 1\n\n        c = 0j\n        if st &gt; epsilon:\n            c = complex(x / st, y / st)\n        cm = c\n        for m in range(1, self.lmax + 1):\n            sign = 1\n            if self.phase and (m &amp; 1):\n                sign = -1\n            for l in range(m, self.lmax + 1):\n                l_offset = l * (l + 1)\n                rr = sign * cm * self.plm_work_array[plm_idx]\n                ii = sign * np.conj(cm) * self.plm_work_array[plm_idx]\n                if m &amp; 1:\n                    ii = -ii\n                result[l_offset - m] = ii\n                result[l_offset + m] = rr\n                plm_idx += 1\n            cm *= c\n        return result\n\n    def batch_cartesian(self, pos, result=None):\n        if result is None:\n            result = np.empty((pos.shape[0], self.nlm()), dtype=np.complex128)\n        pass\n\n    def __eval__(self, *parameters, result=None, cartesian=False):\n        pass\n</code></pre>"},{"location":"reference/chmpy/shape/spherical_harmonics/#chmpy.shape.spherical_harmonics.SphericalHarmonics.nlm","title":"<code>nlm()</code>","text":"<p>the number of complex SHT coefficients</p> Source code in <code>chmpy/shape/spherical_harmonics.py</code> <pre><code>def nlm(self):\n    \"the number of complex SHT coefficients\"\n    return (self.lmax + 1) * (self.lmax + 1)\n</code></pre>"},{"location":"reference/chmpy/shape/spherical_harmonics/#chmpy.shape.spherical_harmonics.SphericalHarmonics.nplm","title":"<code>nplm()</code>","text":"<p>the number of real SHT coefficients (i.e. legendre polynomial terms)</p> Source code in <code>chmpy/shape/spherical_harmonics.py</code> <pre><code>def nplm(self):\n    \"the number of real SHT coefficients (i.e. legendre polynomial terms)\"\n    return (self.lmax + 1) * (self.lmax + 2) // 2\n</code></pre>"},{"location":"reference/chmpy/util/color/","title":"color","text":""},{"location":"reference/chmpy/util/color/#chmpy.util.color.property_to_color","title":"<code>property_to_color(prop, cmap='viridis', **kwargs)</code>","text":"<p>Convert a scalar array of property values to colors, given a provided color map (or property name).</p> <p>Parameters:</p> Name Type Description Default <code>prop</code> <code>array_like</code> <p>the scalar array of property values</p> required <code>cmap</code> <code>str</code> <p>the color map name or property name</p> <code>'viridis'</code> <code>vmin</code> <code>float</code> <p>the minimum value of the property color scale</p> required <code>vmax</code> <code>float</code> <p>the maximum value of the property color scale</p> required <code>kwargs</code> <code>dict</code> <p>optional keyword arguments</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>array_like</code> <p>the array of color values for the given property</p> Source code in <code>chmpy/util/color.py</code> <pre><code>def property_to_color(prop, cmap=\"viridis\", **kwargs):\n    \"\"\"\n    Convert a scalar array of property values to colors,\n    given a provided color map (or property name).\n\n    Args:\n        prop (array_like): the scalar array of property values\n        cmap (str): the color map name or property name\n        vmin (float): the minimum value of the property color scale\n        vmax (float): the maximum value of the property color scale\n        kwargs (dict): optional keyword arguments\n\n    Returns:\n        array_like: the array of color values for the given property\n    \"\"\"\n    from matplotlib import colormaps\n\n    colormap = colormaps[kwargs.get(\"colormap\", DEFAULT_COLORMAPS.get(cmap, cmap))]\n\n    norm = None\n    vmin = kwargs.get(\"vmin\", prop.min())\n    vmax = kwargs.get(\"vmax\", prop.max())\n    midpoint = kwargs.get(\n        \"midpoint\",\n        max(min(0.0, vmax - 0.01), vmin + 0.01) if cmap in (\"d_norm\", \"esp\") else None,\n    )\n    if midpoint is not None:\n        try:\n            from matplotlib.colors import TwoSlopeNorm\n        except ImportError:\n            from matplotlib.colors import DivergingNorm as TwoSlopeNorm\n        assert vmin &lt;= midpoint, f\"vmin={vmin} midpoint={midpoint}\"\n        assert vmax &gt;= midpoint, f\"vmin={vmax} midpoint={midpoint}\"\n        norm = TwoSlopeNorm(vmin=vmin, vcenter=midpoint, vmax=vmax)\n        prop = norm(prop)\n        return colormap(prop)\n    else:\n        import numpy as np\n\n        prop = np.clip(prop, vmin, vmax) - vmin\n        return colormap(prop)\n</code></pre>"},{"location":"reference/chmpy/util/dict/","title":"dict","text":""},{"location":"reference/chmpy/util/dict/#chmpy.util.dict.nested_dict_delete","title":"<code>nested_dict_delete(root, key, sep='.')</code>","text":"<p>Iterate through a dict, deleting items recursively based on a key.</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>dict</code> <p>dictionary to remove an entry from</p> required <code>key</code> <code>str</code> <p>the string used to locate the key to delete in the root dictionary</p> required <code>sep</code> <code>str</code> <p>the separator for dictionary key items</p> <code>'.'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>the modified dict_to</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d1 = {\"test\": {\"test_val\": 3}}\n&gt;&gt;&gt; d2 = {\"test\": {\"test_val\": 5, \"test_val_2\": 7}, \"other\": 3}\n&gt;&gt;&gt; nested_dict_delete(d1, \"test.test_val\")\n&gt;&gt;&gt; d1\n{}\n&gt;&gt;&gt; nested_dict_delete(d2, \"test.test_val\")\n&gt;&gt;&gt; d2\n{'test': {'test_val_2': 7}, 'other': 3}\n</code></pre> Source code in <code>chmpy/util/dict.py</code> <pre><code>def nested_dict_delete(root, key, sep=\".\"):\n    \"\"\"\n    Iterate through a dict, deleting items\n    recursively based on a key.\n\n    Args:\n        root (dict): dictionary to remove an entry from\n        key (str): the string used to locate the key to delete in the root dictionary\n        sep (str): the separator for dictionary key items\n\n    Returns:\n        dict: the modified dict_to\n\n    Examples:\n        &gt;&gt;&gt; d1 = {\"test\": {\"test_val\": 3}}\n        &gt;&gt;&gt; d2 = {\"test\": {\"test_val\": 5, \"test_val_2\": 7}, \"other\": 3}\n        &gt;&gt;&gt; nested_dict_delete(d1, \"test.test_val\")\n        &gt;&gt;&gt; d1\n        {}\n        &gt;&gt;&gt; nested_dict_delete(d2, \"test.test_val\")\n        &gt;&gt;&gt; d2\n        {'test': {'test_val_2': 7}, 'other': 3}\n    \"\"\"\n\n    levels = key.split(sep)\n    level_key = levels[0]\n    if level_key in root:\n        if isinstance(root[level_key], MutableMapping):\n            nested_dict_delete(root[level_key], sep.join(levels[1:]), sep=sep)\n            if not root[level_key]:\n                del root[level_key]\n        else:\n            del root[level_key]\n    else:\n        raise KeyError\n</code></pre>"},{"location":"reference/chmpy/util/dict/#chmpy.util.dict.recursive_dict_update","title":"<code>recursive_dict_update(dict_to, dict_from)</code>","text":"<p>Iterate through a dictionary , updating items inplace recursively from a second dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dict_to</code> <code>dict</code> <p>the first dictionary (to update)</p> required <code>dict_from</code> <code>dict</code> <p>the second dictionary (to pull updates from)</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>the modified dict_to</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d1 = {\"test\": {\"test_val\": 3}}\n&gt;&gt;&gt; d2 = {\"test\": {\"test_val\": 5}, \"other\": 3}\n&gt;&gt;&gt; recursive_dict_update(d1, d2)\n{'test': {'test_val': 5}, 'other': 3}\n</code></pre> Source code in <code>chmpy/util/dict.py</code> <pre><code>def recursive_dict_update(dict_to, dict_from):\n    \"\"\"\n    Iterate through a dictionary , updating items inplace\n    recursively from a second dictionary.\n\n    Args:\n        dict_to (dict): the first dictionary (to update)\n        dict_from (dict): the second dictionary (to pull updates from)\n\n    Returns:\n        dict: the modified dict_to\n\n    Examples:\n        &gt;&gt;&gt; d1 = {\"test\": {\"test_val\": 3}}\n        &gt;&gt;&gt; d2 = {\"test\": {\"test_val\": 5}, \"other\": 3}\n        &gt;&gt;&gt; recursive_dict_update(d1, d2)\n        {'test': {'test_val': 5}, 'other': 3}\n    \"\"\"\n    for key, val in dict_from.items():\n        if isinstance(val, Mapping):\n            dict_to[key] = recursive_dict_update(dict_to.get(key, {}), val)\n        else:\n            dict_to[key] = val\n    return dict_to\n</code></pre>"},{"location":"reference/chmpy/util/exe/","title":"exe","text":""},{"location":"reference/chmpy/util/exe/#chmpy.util.exe.libc_version","title":"<code>libc_version()</code>","text":"<p>Get the version of glibc this python was compiled with return None if we don't have any info on it</p> Source code in <code>chmpy/util/exe.py</code> <pre><code>def libc_version():\n    \"\"\"Get the version of glibc this python was compiled with\n    return None if we don't have any info on it\n    \"\"\"\n    try:\n        version = platform.libc_ver()[1]\n    except Exception:\n        version = None\n    return version\n</code></pre>"},{"location":"reference/chmpy/util/exe/#chmpy.util.exe.linux_version","title":"<code>linux_version()</code>","text":"<p>Get the version of linux this system is running If it's not linux, return None</p> Source code in <code>chmpy/util/exe.py</code> <pre><code>def linux_version():\n    \"\"\"Get the version of linux this system is running\n    If it's not linux, return None\n    \"\"\"\n    s = platform.platform()\n    if not s.startswith(\"Linux\"):\n        return None\n    version_string = s.split(\"-\")[1]\n    return version_string\n</code></pre>"},{"location":"reference/chmpy/util/mesh/","title":"mesh","text":""},{"location":"reference/chmpy/util/mesh/#chmpy.util.mesh.molecule_to_meshes","title":"<code>molecule_to_meshes(molecule, **kwargs)</code>","text":"<p>Convert the provided molecule into a list of trimesh Meshes representing the molecule either as van der Waals spheres or as a CPK representation.</p> <p>Parameters:</p> Name Type Description Default <code>molecule</code> <code>Molecule</code> <p>The molecule to represent</p> required <code>kwargs</code> <code>dict</code> <p>Optional Keyword arguments</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>list</code> <p>a list of meshes representing atoms and (optionally) bonds</p> Source code in <code>chmpy/util/mesh.py</code> <pre><code>def molecule_to_meshes(molecule, **kwargs):\n    \"\"\"\n    Convert the provided molecule into a list\n    of trimesh Meshes representing the molecule\n    either as van der Waals spheres or as a CPK\n    representation.\n\n    Args:\n        molecule (Molecule): The molecule to represent\n        kwargs (dict): Optional Keyword arguments\n\n    Returns:\n        list: a list of meshes representing atoms and (optionally) bonds\n    \"\"\"\n\n    import numpy as np\n    from trimesh.creation import cylinder, icosphere\n\n    representation = kwargs.get(\"representation\", \"ball_stick\")\n    base_sphere = icosphere(subdivisions=3)\n    n_points = len(base_sphere.vertices)\n    meshes = {}\n    for atom_index, (el, pos) in enumerate(molecule):\n        m = base_sphere.copy()\n        m.apply_scale(getattr(el, f\"{representation}_radius\"))\n        m.apply_translation(pos)\n        m.visual.vertex_colors = np.repeat([el.color], n_points, axis=0)\n        meshes[f\"atom_{molecule.labels[atom_index]}\"] = m\n        LOG.debug(\"Add atom %d\", atom_index)\n    if representation == \"ball_stick\":\n        bond_thickness = 0.12\n        for bond_index, (a, b, d) in enumerate(molecule.unique_bonds):\n            x1 = molecule.positions[a]\n            x3 = molecule.positions[b]\n            cyl = cylinder(bond_thickness, d, segment=(x1, x3))\n            cyl.visual.vertex_colors = np.repeat(\n                [\n                    (100, 100, 100, 255),\n                ],\n                cyl.vertices.shape[0],\n                axis=0,\n            )\n            bond_label = f\"bond_{molecule.labels[a]}_{molecule.labels[b]}\"\n            LOG.debug(\"Add bond %d\", bond_index)\n            meshes[bond_label] = cyl\n    return meshes\n</code></pre>"},{"location":"reference/chmpy/util/mesh/#chmpy.util.mesh.save_mesh","title":"<code>save_mesh(mesh, filename)</code>","text":"<p>Save the given Trimesh to a file.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Trimesh</code> <p>The mesh to save.</p> required <code>filename</code> <code>str</code> <p>The path to the destination file.</p> required Source code in <code>chmpy/util/mesh.py</code> <pre><code>def save_mesh(mesh, filename):\n    \"\"\"\n    Save the given Trimesh to a file.\n\n    Args:\n        mesh (trimesh.Trimesh): The mesh to save.\n        filename (str): The path to the destination file.\n    \"\"\"\n    ext = filename.split(\".\")[-1]\n    with open(filename, \"wb\") as f:\n        mesh.export(f, ext)\n\n    LOG.debug(\"Saved mesh %s to %s\", mesh, filename)\n</code></pre>"},{"location":"reference/chmpy/util/num/","title":"num","text":""},{"location":"reference/chmpy/util/num/#chmpy.util.num.cartesian_product","title":"<code>cartesian_product(*arrays)</code>","text":"<p>Efficiently calculate the Cartesian product of the provided vectors A x B x C ... etc. This will maintain order in loops from the right most array.</p> <p>Parameters:</p> Name Type Description Default <code>*arrays</code> <code>array_like</code> <p>1D arrays to use for the Cartesian product</p> <code>()</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The Cartesian product of the provided vectors.</p> Source code in <code>chmpy/util/num.py</code> <pre><code>def cartesian_product(*arrays) -&gt; np.ndarray:\n    \"\"\"\n    Efficiently calculate the Cartesian product of the\n    provided vectors A x B x C ... etc. This will maintain\n    order in loops from the right most array.\n\n    Args:\n        *arrays (array_like): 1D arrays to use for the Cartesian product\n\n    Returns:\n        np.ndarray: The Cartesian product of the provided vectors.\n    \"\"\"\n    arrays = [np.asarray(a) for a in arrays]\n    la = len(arrays)\n    dtype = np.result_type(*arrays)\n    arr = np.empty([len(a) for a in arrays] + [la], dtype=dtype)\n    for i, a in enumerate(np.ix_(*arrays)):\n        arr[..., i] = a\n    return arr.reshape(-1, la)\n</code></pre>"},{"location":"reference/chmpy/util/num/#chmpy.util.num.cartesian_to_spherical","title":"<code>cartesian_to_spherical(xyz, dtype=np.float64)</code>","text":"<p>Given an N by 3 array of (x, y, z) spherical coordinates return an N by 3 array of Cartesian(r, theta, phi) coordinates.</p> <p>Uses the following convention::</p> <pre><code>x = r sin(theta) cos(phi)\ny = r sin(theta) sin(phi)\nz = r cos(theta)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>rtp</code> <code>array_like</code> <p>(N,3) array of of r, theta, phi coordinates in the above spherical coordinate system.</p> required <code>dtype</code> <p>numpy datatype or string</p> <code>float64</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: (N,3) array of x,y,z Cartesian coordinates</p> Source code in <code>chmpy/util/num.py</code> <pre><code>def cartesian_to_spherical(xyz: np.ndarray, dtype=np.float64) -&gt; np.ndarray:\n    \"\"\"\n    Given an N by 3 array of (x, y, z) spherical coordinates\n    return an N by 3 array of Cartesian(r, theta, phi) coordinates.\n\n    Uses the following convention::\n\n        x = r sin(theta) cos(phi)\n        y = r sin(theta) sin(phi)\n        z = r cos(theta)\n\n    Args:\n        rtp (array_like): (N,3) array of of r, theta, phi coordinates\n            in the above spherical coordinate system.\n        dtype: numpy datatype or string\n\n    Returns:\n        np.ndarray: (N,3) array of x,y,z Cartesian coordinates\n    \"\"\"\n    rtp = np.empty(xyz.shape, dtype=dtype)\n    rtp[:, 0] = np.sqrt(\n        xyz[:, 0] * xyz[:, 0] + xyz[:, 1] * xyz[:, 1] + xyz[:, 2] * xyz[:, 2]\n    )\n    rtp[:, 1] = np.fmod(np.arctan2(xyz[:, 1], xyz[:, 0]) + 4 * np.pi, 2 * np.pi)\n    rtp[:, 2] = np.arccos(xyz[:, 2] / rtp[:, 0])\n    return rtp\n</code></pre>"},{"location":"reference/chmpy/util/num/#chmpy.util.num.cartesian_to_spherical_mgrid","title":"<code>cartesian_to_spherical_mgrid(x, y, z)</code>","text":"<p>Given 3 arrays of of (x, y, z) Cartesian coordinates return 3 arrays of of spherical (r, theta, phi) coordinates.</p> <p>Uses the following convention::</p> <pre><code>x = r sin(theta) cos(phi)\ny = r sin(theta) sin(phi)\nz = r cos(theta)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array_like</code> <p>(N) array of of z coordinates in the above spherical coordinate system.</p> required <code>y</code> <code>array_like</code> <p>(N) array of of y coordinates in the above spherical coordinate system.</p> required <code>z</code> <code>array_like</code> <p>(N) array of of z coordinates in the above spherical coordinate system.</p> required <p>Returns:     Tuple[np.ndarray]: 3 arrays of r, theta, phi spherical coordinates</p> Source code in <code>chmpy/util/num.py</code> <pre><code>def cartesian_to_spherical_mgrid(x: np.ndarray, y: np.ndarray, z: np.ndarray):\n    \"\"\"\n    Given 3 arrays of of (x, y, z) Cartesian coordinates\n    return 3 arrays of of spherical (r, theta, phi) coordinates.\n\n    Uses the following convention::\n\n        x = r sin(theta) cos(phi)\n        y = r sin(theta) sin(phi)\n        z = r cos(theta)\n\n    Args:\n        x (array_like): (N) array of of z coordinates\n            in the above spherical coordinate system.\n        y (array_like): (N) array of of y coordinates\n            in the above spherical coordinate system.\n        z (array_like): (N) array of of z coordinates\n            in the above spherical coordinate system.\n    Returns:\n        Tuple[np.ndarray]: 3 arrays of r, theta, phi spherical coordinates\n    \"\"\"\n    r = np.sqrt(x * x + y * y + z * z)\n    return r, np.arccos(z / r), np.arctan2(y, x)\n</code></pre>"},{"location":"reference/chmpy/util/num/#chmpy.util.num.is_perfect_square","title":"<code>is_perfect_square(value)</code>","text":"<p>Check if a number is perfect square.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Number</code> <p>the number in question</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the number is a perfect square, otherwise <code>False</code></p> Source code in <code>chmpy/util/num.py</code> <pre><code>def is_perfect_square(value: Number) -&gt; bool:\n    \"\"\"\n    Check if a number is perfect square.\n\n    Args:\n        value (Number): the number in question\n\n    Returns:\n        bool: `True` if the number is a perfect square, otherwise `False`\n    \"\"\"\n    import math\n\n    root = math.sqrt(value)\n    if int(root + 0.5) ** 2 == value:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"reference/chmpy/util/num/#chmpy.util.num.kabsch_rotation_matrix","title":"<code>kabsch_rotation_matrix(A, B)</code>","text":"<p>Calculate the optimal rotation matrix <code>R</code> to rotate <code>A</code> onto <code>B</code>, minimising root-mean-square deviation so that this may be then calculated.</p> <p>See https://en.wikipedia.org/wiki/Kabsch_algorithm</p> References <p>Kabsch, W. Acta Cryst. A, 32, 922-923, (1976)     DOI: http://dx.doi.org/10.1107/S0567739476001873</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>ndarray</code> <p>(N,D) matrix where N is the number of vectors and D is the dimension of each vector</p> required <code>B</code> <code>ndarray</code> <p>(N,D) matrix where N is the number of vectors and D is the dimension of each vector</p> required <p>Returns:     np.ndarray (D,D) rotation matrix where D is the dimension of each vector</p> Source code in <code>chmpy/util/num.py</code> <pre><code>def kabsch_rotation_matrix(A, B):\n    \"\"\"\n    Calculate the optimal rotation matrix `R` to rotate\n    `A` onto `B`, minimising root-mean-square deviation so that\n    this may be then calculated.\n\n    See https://en.wikipedia.org/wiki/Kabsch_algorithm\n\n    References:\n        Kabsch, W. Acta Cryst. A, 32, 922-923, (1976)\n            DOI: http://dx.doi.org/10.1107/S0567739476001873\n\n    Args:\n        A (np.ndarray): (N,D) matrix where N is the number of vectors and D\n            is the dimension of each vector\n        B (np.ndarray): (N,D) matrix where N is the number of\n            vectors and D is the dimension of each vector\n    Returns:\n        np.ndarray (D,D) rotation matrix where D is the dimension of each vector\n    \"\"\"\n\n    # Calculate the covariance matrix\n    cov = np.dot(np.transpose(A), B)\n\n    # Use singular value decomposition to calculate\n    # the optimal rotation matrix\n    v, s, w = np.linalg.svd(cov)\n\n    # check the determinant to ensure a right-handed\n    # coordinate system\n    if (np.linalg.det(v) * np.linalg.det(w)) &lt; 0.0:\n        s[-1] = -s[-1]\n        v[:, -1] = -v[:, -1]\n    R = np.dot(v, w)\n    return R\n</code></pre>"},{"location":"reference/chmpy/util/num/#chmpy.util.num.reorient_points","title":"<code>reorient_points(A, B, method='kabsch')</code>","text":"<p>Rotate the points in <code>A</code> onto <code>B</code></p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>ndarray</code> <p>(N,D) matrix where N is the number of vectors and D is the dimension of each vector</p> required <code>B</code> <code>ndarray</code> <p>(N,D) matrix where N is the number of vectors and D is the dimension of each vector</p> required <p>Returns:</p> Type Description <p>np.ndarray: (N,D) matrix where N is the number of vectors and D is the dimension of each vector, now rotated to align with B</p> Source code in <code>chmpy/util/num.py</code> <pre><code>def reorient_points(A, B, method=\"kabsch\"):\n    \"\"\"\n    Rotate the points in `A` onto `B`\n\n    Args:\n        A (np.ndarray): (N,D) matrix where N is the number of vectors and D\n            is the dimension of each vector\n        B (np.ndarray): (N,D) matrix where N is the number of\n            vectors and D is the dimension of each vector\n\n    Returns:\n        np.ndarray: (N,D) matrix where N is the number of vectors and D\n            is the dimension of each vector, now rotated to align with B\n    \"\"\"\n    if method != \"kabsch\":\n        raise NotImplementedError(\"Only kabsch algorithm is currently implemented\")\n    R = kabsch_rotation_matrix(A, B)\n    A = np.dot(A, R)\n    return A\n</code></pre>"},{"location":"reference/chmpy/util/num/#chmpy.util.num.rmsd_points","title":"<code>rmsd_points(A, B, reorient='kabsch')</code>","text":"<p>Rotate the points in <code>A</code> onto <code>B</code> and calculate their RMSD</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>ndarray</code> <p>(N,D) matrix where N is the number of vectors and D is the dimension of each vector</p> required <code>B</code> <code>ndarray</code> <p>(N,D) matrix where N is the number of vectors and D is the dimension of each vector</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>root mean squared deviation</p> Source code in <code>chmpy/util/num.py</code> <pre><code>def rmsd_points(A, B, reorient=\"kabsch\"):\n    \"\"\"\n    Rotate the points in `A` onto `B` and calculate\n    their RMSD\n\n    Args:\n        A (np.ndarray): (N,D) matrix where N is the number of vectors and D\n            is the dimension of each vector\n        B (np.ndarray): (N,D) matrix where N is the number of\n            vectors and D is the dimension of each vector\n\n    Returns:\n        float: root mean squared deviation\n    \"\"\"\n    if reorient:\n        A = reorient_points(A, B, method=reorient)\n    diff = B - A\n    return np.sqrt(np.vdot(diff, diff) / diff.shape[0])\n</code></pre>"},{"location":"reference/chmpy/util/num/#chmpy.util.num.spherical_to_cartesian","title":"<code>spherical_to_cartesian(rtp, dtype=np.float64)</code>","text":"<p>Given an N by 3 array of (r, theta, phi) spherical coordinates return an N by 3 array of Cartesian(x, y, z) coordinates.</p> <p>Uses the following convention::</p> <pre><code>x = r sin(theta) cos(phi)\ny = r sin(theta) sin(phi)\nz = r cos(theta)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>rtp</code> <code>array_like</code> <p>(N,3) array of of r, theta, phi coordinates in the above spherical coordinate system.</p> required <code>dtype</code> <p>numpy datatype or string</p> <code>float64</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: (N,3) array of x,y,z Cartesian coordinates</p> Source code in <code>chmpy/util/num.py</code> <pre><code>def spherical_to_cartesian(rtp: np.ndarray, dtype=np.float64) -&gt; np.ndarray:\n    \"\"\"\n    Given an N by 3 array of (r, theta, phi) spherical coordinates\n    return an N by 3 array of Cartesian(x, y, z) coordinates.\n\n    Uses the following convention::\n\n        x = r sin(theta) cos(phi)\n        y = r sin(theta) sin(phi)\n        z = r cos(theta)\n\n    Args:\n        rtp (array_like): (N,3) array of of r, theta, phi coordinates\n            in the above spherical coordinate system.\n        dtype: numpy datatype or string\n\n    Returns:\n        np.ndarray: (N,3) array of x,y,z Cartesian coordinates\n    \"\"\"\n    xyz = np.empty(rtp.shape, dtype=dtype)\n\n    xyz[:, 0] = rtp[:, 0] * np.sin(rtp[:, 1]) * np.cos(rtp[:, 2])\n    xyz[:, 1] = rtp[:, 0] * np.sin(rtp[:, 1]) * np.sin(rtp[:, 2])\n    xyz[:, 2] = rtp[:, 0] * np.cos(rtp[:, 1])\n\n    return xyz\n</code></pre>"},{"location":"reference/chmpy/util/num/#chmpy.util.num.spherical_to_cartesian_mgrid","title":"<code>spherical_to_cartesian_mgrid(r, t, p)</code>","text":"<p>Given 3 arrays of (r, theta, phi) spherical coordinates return 3 arrays of Cartesian(x, y, z) coordinates.</p> <p>Uses the following convention::</p> <pre><code>x = r sin(theta) cos(phi)\ny = r sin(theta) sin(phi)\nz = r cos(theta)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>array_like</code> <p>array of of r coordinates in the above spherical coordinate system.</p> required <code>t</code> <code>array_like</code> <p>array of of theta coordinates in the above spherical coordinate system.</p> required <code>p</code> <code>array_like</code> <p>array of phi coordinates in the above spherical coordinate system.</p> required <code>dtype</code> <p>numpy datatype or string</p> required <p>Returns:</p> Type Description <p>Tuple[np.ndarray]: 3 arrays of x,y,z Cartesian coordinates</p> Source code in <code>chmpy/util/num.py</code> <pre><code>def spherical_to_cartesian_mgrid(r: np.ndarray, t: np.ndarray, p: np.ndarray):\n    \"\"\"\n    Given 3 arrays of (r, theta, phi) spherical coordinates\n    return 3 arrays of Cartesian(x, y, z) coordinates.\n\n    Uses the following convention::\n\n        x = r sin(theta) cos(phi)\n        y = r sin(theta) sin(phi)\n        z = r cos(theta)\n\n    Args:\n        r (array_like): array of of r coordinates\n            in the above spherical coordinate system.\n\n        t (array_like): array of of theta coordinates\n            in the above spherical coordinate system.\n\n        p (array_like): array of phi coordinates\n            in the above spherical coordinate system.\n        dtype: numpy datatype or string\n\n    Returns:\n        Tuple[np.ndarray]: 3 arrays of x,y,z Cartesian coordinates\n    \"\"\"\n    return r * np.sin(t) * np.cos(p), r * np.sin(t) * np.sin(p), r * np.cos(t)\n</code></pre>"},{"location":"reference/chmpy/util/path/","title":"path","text":""},{"location":"reference/chmpy/util/path/#chmpy.util.path.dir_exists","title":"<code>dir_exists(pathname)</code>","text":"<p>Return <code>True</code> if the given pathname is valid for the current OS and currently exists as a dir, <code>False</code> otherwise.</p> Source code in <code>chmpy/util/path.py</code> <pre><code>def dir_exists(pathname):\n    \"\"\"Return `True` if the given pathname is valid for\n    the current OS and currently exists as a dir,\n    `False` otherwise.\"\"\"\n    try:\n        if not is_valid_pathname(pathname):\n            return False\n        return os.path.exists(pathname) and os.path.isdir(pathname)\n    except OSError:\n        return False\n</code></pre>"},{"location":"reference/chmpy/util/path/#chmpy.util.path.dir_exists_or_is_creatable","title":"<code>dir_exists_or_is_creatable(pathname)</code>","text":"<p>Return <code>True</code> if the given pathname is valid for the current OS and currently exists as a dir or is createable by the current user, <code>False</code> otherwise.</p> Source code in <code>chmpy/util/path.py</code> <pre><code>def dir_exists_or_is_creatable(pathname):\n    \"\"\"Return `True` if the given pathname is valid for\n    the current OS and currently exists as a dir or is\n    createable by the current user, `False` otherwise.\"\"\"\n    try:\n        if not is_valid_pathname(pathname):\n            return False\n        return (\n            os.path.exists(pathname) and os.path.isdir(pathname)\n        ) or is_path_creatable(pathname)\n    except OSError:\n        return False\n</code></pre>"},{"location":"reference/chmpy/util/path/#chmpy.util.path.is_path_creatable","title":"<code>is_path_creatable(pathname)</code>","text":"<p>Return <code>True</code> if we have permissions to create the given pathname, <code>False</code> otherwise</p> Source code in <code>chmpy/util/path.py</code> <pre><code>def is_path_creatable(pathname):\n    \"\"\"Return `True` if we have permissions to create\n    the given pathname, `False` otherwise\"\"\"\n    dirname = os.path.dirname(pathname) or os.getcwd()\n    return os.access(dirname, os.W_OK)\n</code></pre>"},{"location":"reference/chmpy/util/path/#chmpy.util.path.is_valid_pathname","title":"<code>is_valid_pathname(pathname)</code>","text":"<p>Return <code>True</code> if the passed string is a valid pathname for the current OS, <code>False</code> otherwise</p> Source code in <code>chmpy/util/path.py</code> <pre><code>def is_valid_pathname(pathname):\n    \"\"\"Return `True` if the passed string is a valid\n    pathname for the current OS, `False` otherwise\"\"\"\n    try:\n        if not isinstance(pathname, str) or not pathname:\n            return False\n\n        # Strip the drivename on windows\n        _, pathname = os.path.splitdrive(pathname)\n\n        root_dirname = (\n            os.environ.get(\"HOMEDRIVE\", \"C:\")\n            if sys.platform == \"win32\"\n            else os.path.sep\n        )\n        assert os.path.isdir(root_dirname)\n\n        root_dirname = root_dirname.rstrip(os.path.sep) + os.path.sep\n\n        for pathname_part in pathname.split(os.path.sep):\n            try:\n                os.lstat(root_dirname + pathname_part)\n            except OSError as e:\n                if hasattr(e, \"winerror\"):\n                    if e.winerror == ERR_INVALID_NAME:\n                        return False\n                elif e.errno in {errno.ENAMETOOLONG, errno.ERANGE}:\n                    return False\n\n    except TypeError:\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/chmpy/util/path/#chmpy.util.path.path_exists_or_is_creatable","title":"<code>path_exists_or_is_creatable(pathname)</code>","text":"<p>Return <code>True</code> if the given pathname is valid for the current OS and currently exists or is createable by the current user, <code>False</code> otherwise.</p> Source code in <code>chmpy/util/path.py</code> <pre><code>def path_exists_or_is_creatable(pathname):\n    \"\"\"Return `True` if the given pathname is valid for\n    the current OS and currently exists or is createable\n    by the current user, `False` otherwise.\"\"\"\n    try:\n        return is_valid_pathname(pathname) and (\n            os.path.exists(pathname) or is_path_creatable(pathname)\n        )\n    except OSError:\n        return False\n</code></pre>"},{"location":"reference/chmpy/util/text/","title":"text","text":""},{"location":"reference/chmpy/util/text/#chmpy.util.text.natural_sort_key","title":"<code>natural_sort_key(s, _nsre=re.compile('([a-zA-Z]+)(\\\\d+)'))</code>","text":"<p>Utility function for sorting strings of the form A1, B_2, A12 etc. so that the suffixes will be in numeric order rather than lexicographical order.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>the string whose sort key to determine</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>the (str, int) natural sort key for the provided string</p> Source code in <code>chmpy/util/text.py</code> <pre><code>def natural_sort_key(s: str, _nsre=re.compile(r\"([a-zA-Z]+)(\\d+)\")):\n    \"\"\"\n    Utility function for sorting strings of the form A1, B_2, A12\n    etc. so that the suffixes will be in numeric order rather than\n    lexicographical order.\n\n    Args:\n        s (str): the string whose sort key to determine\n\n    Returns:\n        tuple: the (str, int) natural sort key for the provided string\n    \"\"\"\n    m = _nsre.match(s)\n    if not m:\n        return s\n    c, i = m.groups(0)\n    return (c, int(i))\n</code></pre>"},{"location":"reference/chmpy/util/text/#chmpy.util.text.overline","title":"<code>overline(x)</code>","text":"<p>Add a unicode overline modifier to the provided string.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>str</code> <p>the string to be overlined</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the overlined string</p> Source code in <code>chmpy/util/text.py</code> <pre><code>def overline(x: str) -&gt; str:\n    \"\"\"\n    Add a unicode overline modifier\n    to the provided string.\n\n    Args:\n        x (str): the string to be overlined\n\n    Returns:\n        str: the overlined string\n    \"\"\"\n    return f\"\\u0305{x}\"\n</code></pre>"},{"location":"reference/chmpy/util/text/#chmpy.util.text.subscript","title":"<code>subscript(x)</code>","text":"<p>Convert the provided string to its subscript equivalent in unicode</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>str</code> <p>the string to be converted</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the converted string</p> Source code in <code>chmpy/util/text.py</code> <pre><code>def subscript(x: str) -&gt; str:\n    \"\"\"\n    Convert the provided string to its subscript\n    equivalent in unicode\n\n    Args:\n        x (str): the string to be converted\n\n    Returns:\n        str: the converted string\n    \"\"\"\n    return SUBSCRIPT_MAP.get(x, x)\n</code></pre>"},{"location":"reference/chmpy/util/unit/","title":"unit","text":""},{"location":"reference/chmpy/util/util/","title":"util","text":""}]}